include "spud_base.rnc"
include "../tools/solvers.rnc"
include "../tools/adaptivity_options.rnc"

start =
   (
      ## The root node of the options dictionary.
      element qg_strat_options {
         comment,
         ## Model output files are named according to the simulation name, e.g. [simulation_name]_0.vtu. Non-standard characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
         ## Options dealing with the specification of geometry
         element geometry {
            ## Dimension of the problem.
            ## <b>This can only be set once</b>
            element dimension {
               element integer_value {
                  attribute rank {"0"},
                  ("3")
               }
            },
            ## The position mesh
            element mesh {
               attribute name { "CoordinateMesh" },
               mesh_info
            },
            element mesh {
               attribute name { "PotentialVorticityMesh" },
               mesh_info
            }?,
            element mesh {
               attribute name { "StreamfunctionMesh" },
               mesh_info
            }?,
            ## Quadrature
            element quadrature {
               ## Quadrature degree
               ## note: this specifies the degree of quadrature not the number of gauss points
               element degree {
                  integer
               }
            }
         },
         ## Input/output options
         element io {
            ## Period between dumps in time units.
            ## Specifies the period between each dump of the solution to disk.
            ## A value of 0.0 indicates that there would be a dump at every timestep.
            element dump_period {
               real
            }
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               real
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               real
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               real
            },
            ## Settings for Runge-Kutta timestepping
            element rungekutta {
               element stages {
                  real_vector
               },
               element weights {
                  real_vector
               }
            }
         },
         ## The physical parameters
         element physical_parameters {
            ## Set buoyancy frequency N where N^2=-(g/rho)(d rho/dz)
            element buoyancy_frequency {
               real
            },
            element coriolis {
               (
                  ## f-plane approximation
                  ## f / 2 = f_0
                  element f_plane {
                     ## f / 2 = f_0
                     element f_0 {
                        real
                     }
                  }|
                  ## Beta-plane approximation
                  ## f / 2 = f_0 + beta_vector . x
                  element beta_plane {
                     ## f_0, where:
                     ##
                     ## f / 2 = f_0 + beta_vector . x
                     element f_0 {
                        real
                     },
                     ## beta_vector, where:
                     ## f / 2 = f_0 + beta_vector . x
                     ## Note that this is not necessarily a unit vector (unlike GravityDirection).
                     element beta_vector {
                        real_dim_vector
                     }
                  }|
                  ## Full Coriolis parameter:
                  ## f / 2 = omega sin (latitude)
                  ## Specify omega.
                  element sine_of_latitude {
                     element omega {
                        real
                     }
                  }|
                  ## Full representation on sphere
                  element on_sphere {
                     ## Domain rotation vector
                     element omega {
                        real_dim_vector
                     }
                  }
               )
            }
         },
         element material_phase {
            attribute name { xsd:string },
            element scalar_field {
               attribute rank { "0" },
               attribute name { "PotentialVorticity" },
               ## Field type
               element prognostic {
                  mesh_choice,
                  prognostic_scalar_field
               }
            },
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Streamfunction" },
               ## Field type
               (
                  element prognostic {
                     mesh_choice,
                     prognostic_streamfunction_field
                  }|
                  element prescribed {
                     mesh_choice,
                     prescribed_scalar_field
                  }
               )
            }
         },
         mesh_adaptivity_options?
      }
   )

input_choice_real_dim_vector =
   (
      ## Constant value
      element constant {
         real_dim_vector
      }|
      ## Python function prescribing dimensional vector input. Functions should be of the form:
      ##
      ## def val(X, t):
      ##    # Function code
      ##    return # Return value
      ##
      ## where X and the return value are tuples of length geometry dimension.
      element python {
         python_code
      }
   )

prescribed_scalar_field =
   (
     prescribed_scalar_field_no_adapt,
     adaptivity_options_scalar_field
   )

prescribed_scalar_field_no_adapt =
   (
      ## Value for WholeMesh
      element value {
         attribute name { "WholeMesh" },
         input_choice_real
      }
   )

prognostic_scalar_field =
   (
      element temporal_discretisation {
      ## Implicit/explicit control (TTHETA)
      ## =0.  -- explicit
      ## =0.5 -- Crank-Nicholson
      ## =1.  -- implicit
         element theta {
            real
         }
      },
      element spatial_discretisation {
         element conservative_advection {
            real
         }
      },
      ## Initial condition for WholeMesh
      element initial_condition {
         attribute name { "WholeMesh" },
         input_choice_initial_condition_real
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      ## Diffusivity for field
      element tensor_field {
         attribute name { "Diffusivity" },
         attribute rank { "2" },
         element prescribed {
            prescribed_values_tensor_field
         }
      }?,
      ## source term
      element scalar_field {
         attribute name { "Source" },
         attribute rank { "0" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt
            }
         )
      }?,
      ## Absorption term
      element scalar_field {
         attribute name { "Absorption" },
         attribute rank { "0" },
         element prescribed {
            prescribed_scalar_field_no_adapt
         }
      }?,
      ## adaptivity options
      adaptivity_options_scalar_field
   )

prognostic_buoyancy_field =
   (
      element temporal_discretisation {
      ## Implicit/explicit control (TTHETA)
      ## =0.  -- explicit
      ## =0.5 -- Crank-Nicholson
      ## =1.  -- implicit
         element theta {
            real
         }
      },
      element spatial_discretisation {
         element conservative_advection {
            real
         }
      },
      ## Initial condition for WholeMesh
      element initial_condition {
         attribute name { "WholeMesh" },
         input_choice_initial_condition_real
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      ## Diffusivity for field
      element tensor_field {
         attribute name { "Diffusivity" },
         attribute rank { "2" },
         element prescribed {
            prescribed_values_dim_minus_one_tensor_field
         }
      }?
   )

prognostic_streamfunction_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      ## Boundary conditions
      ## You must specify the surface ids for the side boundaries where we set the streamfunction to zero.
      ## For the top and bottom boundaries, we solve an advection-diffusion equation for the buoyancy.
      element boundary_conditions {
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         (
            element type {
               attribute name { "dirichlet" },
               element constant {
                  real
               }
            }|
            element type {
               attribute name { "buoyancy" },
               element scalar_field {
                  element prognostic {
                     prognostic_buoyancy_field
                  }
               }
            }
         )
      }*
   )

# Choice of input method for initial conditions
# Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
input_choice_initial_condition_real =
   (
      ## Constant value
      element constant {
         real
      }|
      ## Python function prescribing real input. Functions should be of the form:
      ##
      ## def val(X, t):
      ##    # Function code
      ##    return # Return value
      ##
      ## where X is a tuple of length geometry dimension.
      element python {
         python_code
      }|
      ## Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field. In parallel the process number is appended to the filename, e.g. if the file_name attribute is set to "input.vtu", process 0 reads from "input-0.vtu".
      element from_file {
         attribute file_name { xsd:string },
         ## The format of the input file containing field data.
         element format {
            element string_value {
            "vtu"
            }
         },
         comment
      }
   )

prescribed_values_tensor_field =
   (
      ## Value for WholeMesh
      ## Only specify one value if not using mesh regions.
      ## Otherwise select other value option, specify region_ids
      ## and distinct names.  Then add extra values for other regions.
      element value {
         attribute name { "WholeMesh" },
         input_choice_tensor_field
      }
   )

prescribed_values_dim_minus_one_tensor_field =
   (
      ## Value for WholeMesh
      ## Only specify one value if not using mesh regions.
      ## Otherwise select other value option, specify region_ids
      ## and distinct names.  Then add extra values for other regions.
      element value {
         attribute name { "WholeMesh" },
         input_choice_dim_minus_one_tensor_field
      }
   )


# Choice of input method, e.g. for boundary conditions
input_choice_real =
   (
      ## Constant value
      element constant {
         real
      }|
      ## Python function prescribing real input. Functions should be of the form:
      ##
      ## def val(X, t):
      ##    # Function code
      ##    return # Return value
      ##
      ## where X is a tuple of length geometry dimension.
      element python {
         python_code
      }
   )

input_choice_tensor_field =
   (
      (
         element isotropic {
            input_choice_real
         }|
         element anisotropic_symmetric {
            input_choice_real_dim_symmetric_tensor
         }|
         element anisotropic_asymmetric {
            input_choice_real_dim_tensor
         }
      )
   )

# Choice of input method for initial/boundary conditions
# version for real symmetric tensor
input_choice_real_dim_symmetric_tensor =
   (
      ## Constant symmetric tensor
      element constant {
         real_dim_symmetric_tensor
      }
   )

input_choice_dim_minus_one_tensor_field =
   (
      (
         element isotropic {
            input_choice_real
         }|
         element anisotropic_symmetric {
            input_choice_real_dim_minus_one_symmetric_tensor
         }|
         element anisotropic_asymmetric {
            input_choice_real_dim_minus_one_tensor
         }
      )
   )

# Choice of input method for initial/boundary conditions
# version for real symmetric tensor
input_choice_real_dim_minus_one_symmetric_tensor =
   (
      ## Constant symmetric tensor
      element constant {
         real_dim_minus_one_symmetric_tensor
      }
   )

# Choice of input method for initial/boundary conditions
# version for real tensor
input_choice_real_dim_minus_one_tensor =
   (
      ## Constant tensor
      element constant {
         real_dim_minus_one_tensor
      }
   )

mesh_choice =
   # Most common mesh choices
   (
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { "PotentialVorticityMesh" }
      }|
      element mesh {
         attribute name { "StreamfunctionMesh" }
      }
   )

mesh_info =
   (
      ## Read mesh from file.
      element from_file {
         (
            ## Triangle mesh format.
            ## Enter the base name without the .edge .ele, .face or .node extensions, and without process numbers.
            element format {
              attribute name { "triangle" },
              # string_value elements are used only for backwards compatibility - any new format choices should NOT have these
              element string_value {
                 "triangle"
              },
              comment
            }
         ),
         attribute file_name { xsd:string },
         comment
      }|
      ## Make mesh from existing mesh. The existing mesh cannot itself be made from an existing mesh (i.e. it must be read from a file).
      element from_mesh {
         mesh_choice,
         element mesh_shape {
            element polynomial_degree {
               integer
            }
         }?,
         element mesh_continuity {
            element string_value{
               "continuous" | "discontinuous"
            }
         }?,
         ## Make mesh periodic
         element periodic_boundary_conditions {
            attribute name { xsd:string },
            ## List of boundary ids that are aliased to
            element physical_boundary_ids {
               integer_vector
            },
            ## List of boundary ids that are aliased
            element  aliased_boundary_ids {
               integer_vector
            },
            ## Python code which takes coordinate of an aliased boundary node and returns the coordinate of a physical boundary node
            element coordinate_map {
               python_code
            }
         }*,
         comment
      }
    )
