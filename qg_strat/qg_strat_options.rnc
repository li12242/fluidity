include "spud_base.rnc"
include "../tools/solvers.rnc"

start =
   (
      ## The root node of the options dictionary.
      element qg_strat_options {
         comment,
         ## Model output files are named according to the simulation name, e.g. [simulation_name]_0.vtu. Non-standard characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
         ## Options dealing with the specification of geometry
         element geometry {
            ## Dimension of the problem.
            ## <b>This can only be set once</b>
            element dimension {
               element integer_value {
                  attribute rank {"0"},
                  ("3")
               }
            },
            ## The position mesh
            element mesh {
               attribute name { "CoordinateMesh" },
               mesh_info
            },
            element mesh {
               attribute name { "PotentialVorticityMesh" },
               mesh_info
            }?,
            element mesh {
               attribute name { "StreamfunctionMesh" },
               mesh_info
            }?,
            ## Quadrature
            element quadrature {
               ## Quadrature degree
               ## note: this specifies the degree of quadrature not the number of gauss points
               element degree {
                  integer
               }
            }
         },
         ## Input/output options
         element io {
            ## Period between dumps in time units.
            ## Specifies the period between each dump of the solution to disk.
            ## A value of 0.0 indicates that there would be a dump at every timestep.
            element dump_period {
               real
            }
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               real
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               real
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               real
            },
            ## Settings for Runge-Kutta timestepping
            element rungekutta {
               element stages {
                  real_vector
               },
               element weights {
                  real_vector
               }
            }
         },
         ## The physical parameters
         element physical_parameters {
            ## Set buoyancy frequency N where N^2=-(g/rho)(d rho/dz)
            element buoyancy_frequency {
               real
            },
            element coriolis {
               (
                  ## f-plane approximation
                  ## f / 2 = f_0
                  element f_plane {
                     ## f / 2 = f_0
                     element f_0 {
                        real
                     }
                  }|
                  ## Beta-plane approximation
                  ## f / 2 = f_0 + beta_vector . x
                  element beta_plane {
                     ## f_0, where:
                     ##
                     ## f / 2 = f_0 + beta_vector . x
                     element f_0 {
                        real
                     },
                     ## beta_vector, where:
                     ## f / 2 = f_0 + beta_vector . x
                     ## Note that this is not necessarily a unit vector (unlike GravityDirection).
                     element beta_vector {
                        real_dim_vector
                     }
                  }|
                  ## Full Coriolis parameter:
                  ## f / 2 = omega sin (latitude)
                  ## Specify omega.
                  element sine_of_latitude {
                     element omega {
                        real
                     }
                  }|
                  ## Full representation on sphere
                  element on_sphere {
                     ## Domain rotation vector
                     element omega {
                        real_dim_vector
                     }
                  }
               )
            }
         },
         element material_phase {
            attribute name { xsd:string },
            element scalar_field {
               attribute rank { "0" },
               attribute name { "PotentialVorticity" },
               ## Field type
               element prognostic {
                  mesh_choice,
                  prognostic_scalar_field
               }
            },
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Streamfunction" },
               ## Field type
               (
                  element prognostic {
                     mesh_choice,
                     prognostic_streamfunction_field
                  }|
                  element prescribed {
                     mesh_choice,
                     prescribed_scalar_field
                  }
               )
            }
         },
         element mesh_adaptivity {
            ## Anisotropic mesh hr-adaptivity
            element hr_adaptivity {
               attribute replaces {"ADMESH"},
               (
                  ## Time interval (in simulation time) when mesh adaptivity performed.
                  ## Usually set to 10-20 times the timestep.
                  element period {
                     attribute replaces {"TIMMES"},
                     real
                  }|
                  ## Adapt period in timesteps.
                  element period_in_timesteps {
                     integer
                  }
               ),
               ## Time interval (in cpu time) when mesh adaptivity performed
               ## Manual suggests disabling this option.
               element cpu_period {
                  attribute replaces {"CPUMES"},
                  real
               }?,
               ## The maximum number of nodes this simulation may use.
               ## In parallel, this is the maximum number of nodes per process.
               ## If the mesh adaptivity algorithm wants to place more
               ## nodes than this, the desired mesh is coarsened
               ## everywhere in space until it will fit within this limit.
               ## In general, the error tolerances should be set so that
               ## this is never reached; it should only be a safety catch.
               ## A typical value is 100000.
               element maximum_number_of_nodes {
                  attribute replaces {"MXNODS"},
                  integer
               },
               ## Functional value above which elements are considered for adaption.
               ## 0.5 to 1.0 seems O.K- it can be negative.
               ## 0.5 corresponds to a minimum insphere radius 0f 0.3 relative 1 and max-edge size 2.
               ## Value used in code is MAX(ABS(MESTP1), 0.15)
               ## Manual suggests 0.0
               element functional_tolerance {
                  attribute replaces {"MESTP1"},
                  real
               }?,
               (
                  ## Gradation constrains the jump
                  ## in desired edge lengths along an edge, i.e.
                  ## it controls how fast the mesh size may change.
                  element enable_gradation {
                     ## The gradation parameter. Must be a real >= 1.0.
                     ## The gradation parameter constrains the jump
                     ## in desired edge lengths along an edge, i.e.
                     ## it controls how fast the mesh size may change.
                     ## A constant of 1.0 enforces a mesh of constant
                     ## edge length everywhere. A value of 2.0 would
                     ## allow the element size to double from element
                     ## to element. The default value is 1.5.
                     element gradation_parameter {
                        real
                     }?
                  }|
                  ## Gradation constrains the jump
                  ## in desired edge lengths along an edge, i.e.
                  ## it controls how fast the mesh size may change.
                  element disable_gradation {
                     empty
                  }
               ),
               ## Apply geometric constraints to the metric formation.
               ##
               ## As specified in (Pain, 2001), the mesh adaptivity
               ## scheme attempts to formulate an appropriate edge length
               ## for each direction at each point in space, independent
               ## of problem, PDE or domain.
               ##
               ## This option instructs the error metric formation
               ## code to inspect the boundaries of the domain
               ## and to bound the edge lengths requested appropriately.
               ## This procedure stops the metric from asking for edge lengths
               ## that are inappropriately large in comparison to the
               ## resolution required to preserve the geometric accuracy
               ## of the boundaries.
               ##
               ## If you get 'knife elements' near domain boundaries,
               ## turn this on.
               element geometric_constraints {
                  empty
               }?,
               ## Bounding box factor.
               ##
               ## If the length scales specified by the metric are
               ## unrealistically large, the mesh optimisation
               ## algorithm can get confused. An example
               ## would be specifying a length scale in a direction to be an
               ## order of magnitude greater than the width
               ## of the domain.
               ##
               ## In order to fix this, the edge lengths requested
               ## are bounded by the bounding box of the domain
               ## (the smallest cuboid that contains the domain).
               ## However, it was found that bounding by the bounding
               ## box impairs the generation of anisotropic elements
               ## in the mesh optimisation algorithm.
               ##
               ## This option is multiplied by the bounding box of the domain
               ## before it bounds the metric formed from other
               ## considerations. By default, it is set to 2.0.
               element bounding_box_factor {
                  real
               }?,
               ## Goal-based adaptivity. With this option,
               ## rather than taking the user-specified interpolation
               ## error bounds as the weights to form the error metric
               ## from the Hessians of the solution fields,
               ## the interpolation weight is computed to optimally
               ## represent the value of some specified functional
               ## of state. In other words, the mesh is optimised
               ## for the representation of a particular goal.
               ##
               ## This is currently experimental. Activating
               ## this option induces the code to ignore
               ## any error bounds associated with the fields
               ## specified under a material_phase.
               ##
               ## For more information on this scheme,
               ## see (Venditti & Darmofal, 2003), or
               ## (Power et. al, 2006).
               ##
               ## Coding your own goal is also possible
               ## but currently undocumented. See
               ## error_measures/Goals.F90
               ## for examples.
               element goal_based_adaptivity {
                  (
                     ## Optimise for the representation of
                     ## enstrophy,
                     ## 0.5 * int( |curl(velocity)|**2 ) dV.
                     element enstrophy_goal {
                        attribute subroutine {"goal_enstrophy"},
                        attribute dependencies {"Velocity%1 Velocity%2 Velocity%3"}
                     }|
                     ## Optimise for the representation of
                     ## gradients of temperature,
                     ## int(|grad(temperature)|**2) dV.
                     element temperature_gradient_goal {
                        attribute subroutine {"goal_temp"},
                        attribute dependencies {"Temperature"}
                     }|
                     ## Optimise for the contribution of the standard
                     ## Smagorinsky LES tensor.
                     ##
                     ## In effect, this goal minimises
                     ## the contribution of the sub-filter scale
                     ## model -- it applies mesh resolution where
                     ## the sub-grid scale model has an effect.
                     ##
                     ## int( transpose(grad(u)) . kappa . grad(u) ) dV,
                     ## with u ranging over the components of (nonlinear)
                     ## velocity and kappa the LES tensor.
                     element les_goal {
                        attribute subroutine {"goal_les_velocity"},
                        attribute dependencies {"NonlinearVelocity%1 NonlinearVelocity%2 NonlinearVelocity%3"},
                        ## The number of nonlinear iterations to perform when
                        ## forming the metric with this goal.
                        ##
                        ## Because the LES tensor explicitly depends on mesh sizing,
                        ## we can form a metric and feed this back into the goal,
                        ## using the proposed mesh sizing instead of the current mesh.
                        ## This allows us to simulate adapts without actually incurring
                        ## the cost of adaptation, for the purposes of converging the metric.
                        ## The default value is 3.
                        element nonlinear_iterations {
                           integer
                        }?
                     }|
                     ## Optimise for the contribution of the new 4th-order
                     ## LES tensor.
                     ##
                     ## In effect, this goal minimises
                     ## the contribution of the sub-filter scale
                     ## model -- it applies mesh resolution where
                     ## the sub-grid scale model has an effect.
                     ##
                     ## int( transpose(grad(u))   . kappa . grad(u) ) dV -
                     ## int( transpose(grad_h(u)) . kappa . grad_h(u) ) dV
                     ## with u ranging over the components of (nonlinear)
                     ## velocity, kappa the LES tensor,
                     ## grad(.) differentiation of basis functions and
                     ## grad_h(.) the Galerkin projection of the first derivative.
                     element higher_order_les_goal {
                        attribute subroutine {"goal_les_velocity_4th"},
                        attribute dependencies {"NonlinearVelocity%1 NonlinearVelocity%2 NonlinearVelocity%3"},
                        ## The number of nonlinear iterations to perform when
                        ## forming the metric with this goal.
                        ##
                        ## Because the LES tensor explicitly depends on mesh sizing,
                        ## we can form a metric and feed this back into the goal,
                        ## using the proposed mesh sizing instead of the current mesh.
                        ## This allows us to simulate adapts without actually incurring
                        ## the cost of adaptation, for the purposes of converging the metric.
                        ## The default value is 3.
                        element nonlinear_iterations {
                           integer
                        }?
                     }
                  ),
                  (
                     ## The tolerance of the goal specifies the acceptable
                     ## error in the quantity computed. The adaptation scheme
                     ## attempts to adapt the mesh to ensure that the
                     ## goal computed from the primitive solution is 
                     ## within the tolerance specified here.
                     ##
                     ## A relative tolerance specifies that the acceptable error
                     ## in the goal is some fraction of the value as computed
                     ## from the primitive solution. It is generally 
                     ## the easiest to use. This is a unitless percentage.
                     element relative_tolerance {
                        real
                     }|
                     ## The tolerance of the goal specifies the acceptable
                     ## error in the quantity computed. The adaptation scheme
                     ## attempts to adapt the mesh to ensure that the
                     ## goal computed from the primitive solution is 
                     ## within the tolerance specified here.
                     ##
                     ## An absolute tolerance specifies the acceptable error
                     ## in the goal, in the units of the goal itself.
                     element absolute_tolerance {
                        real
                     }
                  )
               }?,
               (
                  ## The mesh size constraint. This choice specifies
                  ## a mesh size constraint that is both spatially
                  ## and directionally homogenous.
                  ##
                  ## OPHSAM = 0 -- Constant size constraint
                  ## OPHSAM = 1 -- Variable size constraint
                  element constant_size_constraint{
                     attribute replaces {"OPHSAM = 0"},
                     ## The minimum edge length of the mesh.
                     ## This should only be used as a safety net to ensure
                     ## sanity of the resulting mesh; ideally you should set your adaptivity
                     ## weights appropriately so that this is never used.
                     element minimum_edge_length {
                        attribute replaces {"MINCH"},
                        real
                     },
                     ## The maximum edge length of the mesh.
                     ## This should only be used as a safety net to ensure
                     ## sanity of the resulting mesh; ideally you should set your adaptivity
                     ## weights appropriately so that this is never used.
                     element maximum_edge_length {
                        attribute replaces {"MAXCH"},
                        real
                     }
                  }|
                  ## The mesh size constraint. This choice specifies
                  ## a mesh size constraint that can vary both spatially
                  ## and directionally. To vary it directionally,
                  ## specify a symmetric metric tensor for the maximum
                  ## and minimum edge lengths; to vary it spatially,
                  ## add more size_tensors and place them appropriately:
                  ## the mesh size constraint at a given point will be
                  ## the interpolant of the size_tensors you have specified.
                  ##
                  ## OPHSAM = 0 -- Constant size constraint
                  ## OPHSAM = 1 -- Variable size constraint
                  element variable_size_constraint{
                     attribute replaces {"OPHSAM = 1"},
                     ## The minimum and maximum edge lengths are symmetric tensors;
                     ## the position specifies where it is in the domain.
                     element size_tensor{
                        attribute replaces {"NHSAMP"},
                        ## The minimum edge length, expressed as a symmetric tensor.
                        element minimum_edge_length{
                           attribute replaces {"HMINXX HMINXY HMINXZ HMINYY HMINYZ HMINZZ"},
                           real_dim_symmetric_tensor
                        },
                        ## The maximum edge length, expressed as a symmetric tensor.
                        element maximum_edge_length{
                           attribute replaces {"HMAXXX HMAXXY HMAXXZ HMAXYY HMAXYZ HMAXZZ"},
                           real_dim_symmetric_tensor
                        },
                        ## The position of these tensors in the domain.
                        element position{
                           attribute replaces {"XHSAMP YHSAMP ZHSAMP"},
                           real_dim_vector
                        }
                     }+
                  }
               ),
               ## lower & upper limits for derefinment and refinment
               ## respectively - we do not change mesh unless our mesh is outside
               ## these limits. These are the lower and upper limits of element
               ## lengths in the undistorted system where =1 is ideal.
               element element_length_limits {
                  attribute replaces { "CRIUP" },
                  element lower {
                     attribute replaces { "CRILOW = MOD(CRIUP,100.)" },
                     real
                  },
                  element upper {
                     attribute replaces { "(CRIUP-CRILOW)/100." },
                     real
                  }
               }?,
               element adapt_at_first_timestep {
                  ## Outputs mesh in triangle format, right after the first adapts are finished
                  ## this is useful when needing to re-run simulations and don`t want to wait
                  ## for first adapts again.
                  element output_adapted_mesh{empty}?
               }?,
               ## Enable this option to preserve any regions in your mesh (i.e. those specified by region_ids).
               ## Also, any prescribed fields using region_ids will be reinitialised using them on the new mesh.
               ## Therefore this is a required option if you want your prescribed region_id fields to survive adapts!
               ## Obviously this does not apply to initial conditions set using region_ids.
               element preserve_mesh_regions {
                  comment
               }?
            }?
         }?
      }
   )

input_choice_real_dim_vector =
   (
      ## Constant value
      element constant {
         real_dim_vector
      }|
      ## Python function prescribing dimensional vector input. Functions should be of the form:
      ##
      ## def val(X, t):
      ##    # Function code
      ##    return # Return value
      ##
      ## where X and the return value are tuples of length geometry dimension.
      element python {
         python_code
      }
   )

prescribed_scalar_field =
   (
     prescribed_scalar_field_no_adapt,
     adaptivity_options
   )

prescribed_scalar_field_no_adapt =
   (
      ## Value for WholeMesh
      element value {
         attribute name { "WholeMesh" },
         input_choice_real
      }
   )

prognostic_scalar_field =
   (
      element temporal_discretisation {
      ## Implicit/explicit control (TTHETA)
      ## =0.  -- explicit
      ## =0.5 -- Crank-Nicholson
      ## =1.  -- implicit
         element theta {
            real
         }
      },
      element spatial_discretisation {
         element conservative_advection {
            real
         }
      },
      ## Initial condition for WholeMesh
      element initial_condition {
         attribute name { "WholeMesh" },
         input_choice_initial_condition_real
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      ## Diffusivity for field
      element tensor_field {
         attribute name { "Diffusivity" },
         attribute rank { "2" },
         element prescribed {
            prescribed_values_tensor_field
         }
      }?,
      ## source term
      element scalar_field {
         attribute name { "Source" },
         attribute rank { "0" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt
            }
         )
      }?,
      ## Absorption term
      element scalar_field {
         attribute name { "Absorption" },
         attribute rank { "0" },
         element prescribed {
            prescribed_scalar_field_no_adapt
         }
      }?,
      ## adaptivity options
      adaptivity_options_scalar_field
   )

prognostic_buoyancy_field =
   (
      element temporal_discretisation {
      ## Implicit/explicit control (TTHETA)
      ## =0.  -- explicit
      ## =0.5 -- Crank-Nicholson
      ## =1.  -- implicit
         element theta {
            real
         }
      },
      element spatial_discretisation {
         element conservative_advection {
            real
         }
      },
      ## Initial condition for WholeMesh
      element initial_condition {
         attribute name { "WholeMesh" },
         input_choice_initial_condition_real
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      ## Diffusivity for field
      element tensor_field {
         attribute name { "Diffusivity" },
         attribute rank { "2" },
         element prescribed {
            prescribed_values_dim_minus_one_tensor_field
         }
      }?
   )

prognostic_streamfunction_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      ## Boundary conditions
      ## You must specify the surface ids for the side boundaries where we set the streamfunction to zero.
      ## For the top and bottom boundaries, we solve an advection-diffusion equation for the buoyancy.
      element boundary_conditions {
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         (
            element type {
               attribute name { "dirichlet" },
               element constant {
                  real
               }
            }|
            element type {
               attribute name { "buoyancy" },
               element scalar_field {
                  element prognostic {
                     prognostic_buoyancy_field
                  }
               }
            }
         )
      }*
   )

# Choice of input method for initial conditions
# Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
input_choice_initial_condition_real =
   (
      ## Constant value
      element constant {
         real
      }|
      ## Python function prescribing real input. Functions should be of the form:
      ##
      ## def val(X, t):
      ##    # Function code
      ##    return # Return value
      ##
      ## where X is a tuple of length geometry dimension.
      element python {
         python_code
      }|
      ## Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field. In parallel the process number is appended to the filename, e.g. if the file_name attribute is set to "input.vtu", process 0 reads from "input-0.vtu".
      element from_file {
         attribute file_name { xsd:string },
         ## The format of the input file containing field data.
         element format {
            element string_value {
            "vtu"
            }
         },
         comment
      }
   )

prescribed_values_tensor_field =
   (
      ## Value for WholeMesh
      ## Only specify one value if not using mesh regions.
      ## Otherwise select other value option, specify region_ids
      ## and distinct names.  Then add extra values for other regions.
      element value {
         attribute name { "WholeMesh" },
         input_choice_tensor_field
      }
   )

prescribed_values_dim_minus_one_tensor_field =
   (
      ## Value for WholeMesh
      ## Only specify one value if not using mesh regions.
      ## Otherwise select other value option, specify region_ids
      ## and distinct names.  Then add extra values for other regions.
      element value {
         attribute name { "WholeMesh" },
         input_choice_dim_minus_one_tensor_field
      }
   )


# Choice of input method, e.g. for boundary conditions
input_choice_real =
   (
      ## Constant value
      element constant {
         real
      }|
      ## Python function prescribing real input. Functions should be of the form:
      ##
      ## def val(X, t):
      ##    # Function code
      ##    return # Return value
      ##
      ## where X is a tuple of length geometry dimension.
      element python {
         python_code
      }
   )

input_choice_tensor_field =
   (
      (
         element isotropic {
            input_choice_real
         }|
         element anisotropic_symmetric {
            input_choice_real_dim_symmetric_tensor
         }|
         element anisotropic_asymmetric {
            input_choice_real_dim_tensor
         }
      )
   )

# Choice of input method for initial/boundary conditions
# version for real symmetric tensor
input_choice_real_dim_symmetric_tensor =
   (
      ## Constant symmetric tensor
      element constant {
         real_dim_symmetric_tensor
      }
   )

input_choice_dim_minus_one_tensor_field =
   (
      (
         element isotropic {
            input_choice_real
         }|
         element anisotropic_symmetric {
            input_choice_real_dim_minus_one_symmetric_tensor
         }|
         element anisotropic_asymmetric {
            input_choice_real_dim_minus_one_tensor
         }
      )
   )

# Choice of input method for initial/boundary conditions
# version for real symmetric tensor
input_choice_real_dim_minus_one_symmetric_tensor =
   (
      ## Constant symmetric tensor
      element constant {
         real_dim_minus_one_symmetric_tensor
      }
   )

# Choice of input method for initial/boundary conditions
# version for real tensor
input_choice_real_dim_minus_one_tensor =
   (
      ## Constant tensor
      element constant {
         real_dim_minus_one_tensor
      }
   )

mesh_choice =
   # Most common mesh choices
   (
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { "PotentialVorticityMesh" }
      }|
      element mesh {
         attribute name { "StreamfunctionMesh" }
      }
   )

mesh_info =
   (
      ## Read mesh from file.
      element from_file {
         (
            ## Triangle mesh format.
            ## Enter the base name without the .edge .ele, .face or .node extensions, and without process numbers.
            element format {
              attribute name { "triangle" },
              # string_value elements are used only for backwards compatibility - any new format choices should NOT have these
              element string_value {
                 "triangle"
              },
              comment
            }
         ),
         attribute file_name { xsd:string },
         comment
      }|
      ## Make mesh from existing mesh. The existing mesh cannot itself be made from an existing mesh (i.e. it must be read from a file).
      element from_mesh {
         mesh_choice,
         element mesh_shape {
            element polynomial_degree {
               integer
            }
         }?,
         element mesh_continuity {
            element string_value{
               "continuous" | "discontinuous"
            }
         }?,
         ## Make mesh periodic
         element periodic_boundary_conditions {
            attribute name { xsd:string },
            ## List of boundary ids that are aliased to
            element physical_boundary_ids {
               integer_vector
            },
            ## List of boundary ids that are aliased
            element  aliased_boundary_ids {
               integer_vector
            },
            ## Python code which takes coordinate of an aliased boundary node and returns the coordinate of a physical boundary node
            element coordinate_map {
               python_code
            }
         }*,
         comment
      }
    )

adaptivity_options_scalar_field =
   (
      element adaptivity_options {
         (
            element absolute_measure {
               attribute replaces { "ADOPTT = 0" },
               element scalar_field {
                  attribute rank { "0" },
                  attribute name { "InterpolationErrorBound" },
                  attribute replaces { "ADWEIT" },
                  element prescribed {
                     prescribed_scalar_field_no_adapt
                  }
               }
            }|
            element relative_measure {
               attribute replaces { "ADOPTT = 1" },
               element scalar_field {
                  attribute rank { "0" },
                  attribute name { "InterpolationErrorBound" },
                  attribute replaces { "ADADOT" },
                  element prescribed {
                     prescribed_scalar_field_no_adapt
                  }
               },
               ## The relative Hessian is calculated according to:
               ##
               ##   Q = H / max{ |psi|, psi_min}
               ##
               ## where H is the Hessian, psi is the field value and psi_min is the tolerance. The tolerance prevents division by zero errors.
               ##
               ## Source: Fluidity/ICOM manual draft version 1.2
               element tolerance {
                  attribute replaces { "ADATOT" },
                  real
               }
            }
         ),
         ## Normally, adaptivity optimises the mesh to minimise
         ## the L_\infty norm. By specifying p here, you can
         ## instruct adaptivity to optimise the mesh for
         ## the L_p norm instead.
         ##
         ## See
         ## F. Alauzet et al.
         ## Multi-Dimensional Continuous Metric for Mesh Adaptation
         ## Proceedings of the 15th International Meshing Roundtable
         element lp_norm {
            real
         }?
      }?
   )
