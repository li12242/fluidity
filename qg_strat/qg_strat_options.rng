<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="solvers.rng"/>
  <include href="adaptivity_options.rng"/>
  <include href="mesh_options.rng"/>
  <start>
    <element name="qg_strat_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation name, e.g. [simulation_name]_0.vtu. Non-standard characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="geometry">
        <a:documentation>Options dealing with the specification of geometry</a:documentation>
        <element name="dimension">
          <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
          <element name="integer_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <value>3</value>
          </element>
        </element>
        <element name="mesh">
          <a:documentation>The position mesh</a:documentation>
          <attribute name="name">
            <value>CoordinateMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <optional>
          <element name="mesh">
            <attribute name="name">
              <value>PotentialVorticityMesh</value>
            </attribute>
            <ref name="mesh_info"/>
          </element>
        </optional>
        <optional>
          <element name="mesh">
            <attribute name="name">
              <value>StreamfunctionMesh</value>
            </attribute>
            <ref name="mesh_info"/>
          </element>
        </optional>
        <element name="quadrature">
          <a:documentation>Quadrature</a:documentation>
          <element name="degree">
            <a:documentation>Quadrature degree
note: this specifies the degree of quadrature not the number of gauss points</a:documentation>
            <ref name="integer"/>
          </element>
        </element>
      </element>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_period">
          <a:documentation>Period between dumps in time units.
Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="rungekutta">
          <a:documentation>Settings for Runge-Kutta timestepping</a:documentation>
          <element name="stages">
            <ref name="real_vector"/>
          </element>
          <element name="weights">
            <ref name="real_vector"/>
          </element>
        </element>
      </element>
      <element name="physical_parameters">
        <a:documentation>The physical parameters</a:documentation>
        <element name="buoyancy_frequency">
          <a:documentation>Set buoyancy frequency N where N^2=-(g/rho)(d rho/dz)</a:documentation>
          <ref name="real"/>
        </element>
        <element name="coriolis">
          <choice>
            <element name="f_plane">
              <a:documentation>f-plane approximation
f / 2 = f_0</a:documentation>
              <element name="f_0">
                <a:documentation>f / 2 = f_0</a:documentation>
                <ref name="real"/>
              </element>
            </element>
            <element name="beta_plane">
              <a:documentation>Beta-plane approximation
f / 2 = f_0 + beta_vector . x</a:documentation>
              <element name="f_0">
                <a:documentation>f_0, where:

f / 2 = f_0 + beta_vector . x</a:documentation>
                <ref name="real"/>
              </element>
              <element name="beta_vector">
                <a:documentation>beta_vector, where:
f / 2 = f_0 + beta_vector . x
Note that this is not necessarily a unit vector (unlike GravityDirection).</a:documentation>
                <ref name="real_dim_vector"/>
              </element>
            </element>
            <element name="sine_of_latitude">
              <a:documentation>Full Coriolis parameter:
f / 2 = omega sin (latitude)
Specify omega.</a:documentation>
              <element name="omega">
                <ref name="real"/>
              </element>
            </element>
            <element name="on_sphere">
              <a:documentation>Full representation on sphere</a:documentation>
              <element name="omega">
                <a:documentation>Domain rotation vector</a:documentation>
                <ref name="real_dim_vector"/>
              </element>
            </element>
          </choice>
        </element>
      </element>
      <element name="material_phase">
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="scalar_field">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>PotentialVorticity</value>
          </attribute>
          <element name="prognostic">
            <a:documentation>Field type</a:documentation>
            <ref name="mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
        </element>
        <element name="scalar_field">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <attribute name="name">
            <value>Streamfunction</value>
          </attribute>
          <choice>
            <a:documentation>Field type</a:documentation>
            <element name="prognostic">
              <ref name="mesh_choice"/>
              <ref name="prognostic_streamfunction_field"/>
            </element>
            <element name="prescribed">
              <ref name="mesh_choice"/>
              <ref name="prescribed_scalar_field"/>
            </element>
          </choice>
        </element>
      </element>
      <optional>
        <ref name="mesh_adaptivity_options"/>
      </optional>
    </element>
  </start>
  <define name="input_choice_real_dim_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

def val(X, t):
   # Function code
   return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_scalar_field">
    <ref name="prescribed_scalar_field_no_adapt"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <define name="prescribed_scalar_field_no_adapt">
    <element name="value">
      <a:documentation>Value for WholeMesh</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="input_choice_real"/>
    </element>
  </define>
  <define name="prognostic_scalar_field">
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicit control (TTHETA)
=0.  -- explicit
=0.5 -- Crank-Nicholson
=1.  -- implicit</a:documentation>
        <ref name="real"/>
      </element>
    </element>
    <element name="spatial_discretisation">
      <element name="conservative_advection">
        <ref name="real"/>
      </element>
    </element>
    <element name="initial_condition">
      <a:documentation>Initial condition for WholeMesh</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="input_choice_initial_condition_real"/>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <optional>
      <element name="tensor_field">
        <a:documentation>Diffusivity for field</a:documentation>
        <attribute name="name">
          <value>Diffusivity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_values_tensor_field"/>
        </element>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>source term</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_scalar_field_no_adapt"/>
        </element>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Absorption term</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_scalar_field_no_adapt"/>
        </element>
      </element>
    </optional>
    <ref name="adaptivity_options_scalar_field">
      <a:documentation>adaptivity options</a:documentation>
    </ref>
  </define>
  <define name="prognostic_buoyancy_field">
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicit control (TTHETA)
=0.  -- explicit
=0.5 -- Crank-Nicholson
=1.  -- implicit</a:documentation>
        <ref name="real"/>
      </element>
    </element>
    <element name="spatial_discretisation">
      <element name="conservative_advection">
        <ref name="real"/>
      </element>
    </element>
    <element name="initial_condition">
      <a:documentation>Initial condition for WholeMesh</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="input_choice_initial_condition_real"/>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <optional>
      <element name="tensor_field">
        <a:documentation>Diffusivity for field</a:documentation>
        <attribute name="name">
          <value>Diffusivity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_values_dim_minus_one_tensor_field"/>
        </element>
      </element>
    </optional>
  </define>
  <define name="prognostic_streamfunction_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions
You must specify the surface ids for the side boundaries where we set the streamfunction to zero.
For the top and bottom boundaries, we solve an advection-diffusion equation for the buoyancy.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <element name="constant">
              <ref name="real"/>
            </element>
          </element>
          <element name="type">
            <attribute name="name">
              <value>buoyancy</value>
            </attribute>
            <element name="scalar_field">
              <element name="prognostic">
                <ref name="prognostic_buoyancy_field"/>
              </element>
            </element>
          </element>
        </choice>
      </element>
    </zeroOrMore>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_real">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

def val(X, t):
   # Function code
   return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field. In parallel the process number is appended to the filename, e.g. if the file_name attribute is set to "input.vtu", process 0 reads from "input-0.vtu".</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="format">
          <a:documentation>The format of the input file containing field data.</a:documentation>
          <element name="string_value">
            <value>vtu</value>
          </element>
        </element>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="prescribed_values_tensor_field">
    <element name="value">
      <a:documentation>Value for WholeMesh
Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="input_choice_tensor_field"/>
    </element>
  </define>
  <define name="prescribed_values_dim_minus_one_tensor_field">
    <element name="value">
      <a:documentation>Value for WholeMesh
Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="input_choice_dim_minus_one_tensor_field"/>
    </element>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

def val(X, t):
   # Function code
   return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_tensor_field">
    <choice>
      <element name="isotropic">
        <ref name="input_choice_real"/>
      </element>
      <element name="anisotropic_symmetric">
        <ref name="input_choice_real_dim_symmetric_tensor"/>
      </element>
      <element name="anisotropic_asymmetric">
        <ref name="input_choice_real_dim_tensor"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real symmetric tensor
  -->
  <define name="input_choice_real_dim_symmetric_tensor">
    <element name="constant">
      <a:documentation>Constant symmetric tensor</a:documentation>
      <ref name="real_dim_symmetric_tensor"/>
    </element>
  </define>
  <define name="input_choice_dim_minus_one_tensor_field">
    <choice>
      <element name="isotropic">
        <ref name="input_choice_real"/>
      </element>
      <element name="anisotropic_symmetric">
        <ref name="input_choice_real_dim_minus_one_symmetric_tensor"/>
      </element>
      <element name="anisotropic_asymmetric">
        <ref name="input_choice_real_dim_minus_one_tensor"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real symmetric tensor
  -->
  <define name="input_choice_real_dim_minus_one_symmetric_tensor">
    <element name="constant">
      <a:documentation>Constant symmetric tensor</a:documentation>
      <ref name="real_dim_minus_one_symmetric_tensor"/>
    </element>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real tensor
  -->
  <define name="input_choice_real_dim_minus_one_tensor">
    <element name="constant">
      <a:documentation>Constant tensor</a:documentation>
      <ref name="real_dim_minus_one_tensor"/>
    </element>
  </define>
  <define name="mesh_choice">
    <!-- Most common mesh choices -->
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PotentialVorticityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>StreamfunctionMesh</value>
        </attribute>
      </element>
    </choice>
  </define>
</grammar>
