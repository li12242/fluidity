# The radiation options

all_neutral_particle_mesh = 
   (
      neutral_particle_mesh?,
      
      neutral_particle_material_mesh?, 
      
      delayed_neutron_mesh?         
   )


neutral_particle_mesh = 
   (         
      ## The mesh associated with the neutral particle solution
      element mesh {
         comment,
         attribute name { "NeutralParticleMesh" },
         ## Derived from the mesh
         element from_mesh { 
            comment,
            (
               element mesh {
                  comment,
                  attribute name { "CoordinateMesh" }
               }
            ),
            ## The trial space basis function options
            element mesh_shape {
               comment,
               ## The order of the basis functions
               element polynomial_degree {
                  comment,
                  integer
               }?
            }?,
            ## The continuity associated with the mesh
            element mesh_continuity {
               comment,
               element string_value{
                  "continuous" 
               }
            },
            exclude_mesh_stat 
         } 
      }       
   )


neutral_particle_material_mesh = 
   (         
      ## The mesh associated with the material mapping used to solve for the neutral particle 
      ## is always volume element wise (ie. DG order zero or FV)
      element mesh {
         comment,
         attribute name { "NeutralParticleMaterialMesh" },
         
         ## Derived from the mesh
         element from_mesh { 
            comment,
            (
               element mesh{
                  comment,
                  attribute name { "CoordinateMesh" }
               }
            ),
            ## The trial space basis function options
            element mesh_shape {
               comment,
               ## The order of the basis functions
               element polynomial_degree {
                  comment,
                  element integer_value { 
                     attribute rank {"0"},
                     ("0")     
                  }       
               }
            },
            ## The continuity associated with the mesh
            element mesh_continuity {
               comment,
               element string_value{
                  "discontinuous" 
               }
            },
            exclude_mesh_stat 
         }        
      }
   )


delayed_neutron_mesh = 
   (         
      ## The mesh associated with the delayed precursor concentration solution
      element mesh {
         comment,
         attribute name { "DelayedNeutronMesh" },
         ## Derived from the mesh
         element from_mesh { 
            comment,
            (
               element mesh{
                  comment,
                  attribute name { "CoordinateMesh" }
               }
            ),
            ## The trial space basis function options
            element mesh_shape {
               comment,
               ## The order of the basis functions
               element polynomial_degree {
                  comment,
                  integer
               }?
            }?,
            ## The continuity associated with the mesh
            element mesh_continuity {
               comment,
               element string_value{
                  "continuous" | "discontinuous" 
               }
            }?, 
            exclude_mesh_stat
         }        
      }
   )


exclude_mesh_stat = 
   (
      element stat{ 
         comment,
         (
            ## Exclude this mesh from the .stat file
            element exclude_from_stat{
               comment
            }|
            ## Include this mesh in the .stat file
            element include_in_stat {
               comment
            }  
         )
      }
   )

radiation = 
   (
      ## Radiation model 
      element radiation {
         comment,
                  
         particle+    
      }
   )         


particle = 
   (
      ## neutral particle object, each instance is tagged with a string name
      element neutral_particle {
         comment,
         
         attribute name { xsd:string },
         
         number_of_energy_groups,
                  
         radiation_method,             

         problem_run,
                  
         read_radiation_material_data_set,
         
         radiation_material_mapping,
         
         Rad_Fission_and_Power_Template?,
                  
         delayed_precursor?    
      }  
   )  


radiation_method = 
   (
      ## Multigroup diffusion 
      element method_diffusion {
            comment,
                        
            neutral_particle_flux_template_diffusion
      }         
   )


number_of_energy_groups = 
   (
      ## The number of energy groups
      element number_of_energy_groups {
         comment, 
         integer
      }     
   )

   
neutral_particle_flux_template_diffusion =
   (
      ## The template neutral particle flux density scalar field for diffusion method equation
      element scalar_field {
         comment,
         attribute name { "NeutralParticleFluxTemplate" },
         prognostic_neutral_particle_diffusion_removal_source_scalar_field
      }          
   )


prognostic_neutral_particle_diffusion_removal_source_scalar_field = 
   (
      ## Field Type
      element prognostic {
         comment,
         
         radiation_diffusion_spatial_discretisation,
      
         radiation_diffusion_inner_solver_options,
      
         radiation_initial_conditions+,
      
         radiation_diffusion_boundary_conditions*,
           
         radiation_output_options,
      
         radiation_stat_options,
      
         scalar_convergence_options,
         prognostic_detector_options,
         scalar_steady_state_options,
         adaptivity_options_scalar_field,
         interpolation_algorithm_scalar
      }
   )
   
   
radiation_diffusion_spatial_discretisation = 
   (
      ## Spatial discretisation options
      element spatial_discretisation {
         comment,
         (
            ## Continuous galerkin formulation
            element continuous_galerkin {
               comment
            }           
         )
      }   
   )
   

radiation_diffusion_inner_solver_options = 
   (
      ## The inner solver options
      element solver {
         comment,
         linear_solver_options_sym
      }   
   )
   
   
radiation_initial_conditions = 
   (
      ## Initial condition for WholeMesh for all groups
      element initial_condition {
         comment,
         attribute name { "WholeMesh" },
     
         (
            ## Constant value
            element constant {
               real
            }|
            ## Initialise the field from an existing file (indended
            ## primarily for use in checkpointing). The file mesh must match
            ## the mesh of this field  (except for piecewise constant fields 
            ## which will be remapped back from the discontinuous nodal values). 
            ## In parallel the process number is
            ## appended to the filename, e.g. if the file_name attribute is
            ## set to "input.vtu", process 0 reads from "input-0.vtu".
            element from_file {
               attribute file_name { xsd:string },
               (
                  vtu_input_format
               ),
               comment
            } 
         )  
      }
   )
   
   
radiation_diffusion_boundary_conditions = 
   (
      ## The problem boundary conditions 
      element boundary_conditions {
         comment,
         
         attribute name { string },
         
         surface_ids,
         
         diffusion_bc_type
      }   
   )
   

surface_ids = 
   (
      ## The surface id associated with this boundary condition
      element surface_ids {
         comment,
         integer_vector
      }   
   )
   

diffusion_bc_type = 
   (
      ## Type
      (
         diffusion_vacuum|
         diffusion_reflective|
         diffusion_dirichlet
      )   
   )
   
      
diffusion_vacuum = 
   (
      ## Vacuum
      element type {
         comment,
         attribute name { "vacuum" },
         element constant {
            comment,
            attribute rank {"0"},
            ("0.5")  
         }                
      }
   )


diffusion_reflective = 
   (
      ## Reflective
      element type {
         comment,
         attribute name { "reflective" }
      }
   )


diffusion_dirichlet = 
   (
      ## Dirichlet 
      element type {
         comment,
         attribute name { "dirichlet" },
         input_choice_real
      }
   )
   

radiation_output_options = 
   (
      ## Specify what is written to vtu dump files
      element output {
         comment, 
         ## Exclude this field from dump files
         element exclude_from_vtu {
            comment
         }?
      }
   )
   
   
radiation_stat_options = 
   (
      ## Specify what is added to the .stat file
      element stat {
         comment,
         ## Exclude this field from the .stat file
         element exclude_from_stat {
            comment
         }?
      }
   )
   

problem_run = 
   (
      eigenvalue_run|
         
      time_run
   )


eigenvalue_run = 
   (
      ## Eigenvalue run 
      element eigenvalue_run {
         comment,
         
         eigenvalue_run_solver,
         
         flux_normalisation_options
      }         
   )


eigenvalue_run_solver = 
   (
      ## Eigen Solver Algorithm
      (
         ## Power Iterations
         element power_iteration {
            comment,
            power_iteration_element
         }
      )   
   )
   
      
flux_normalisation_options = 
   (
      ## The neutron flux eigenvector normalisation 
      element flux_normalisation { 
         comment,           
         (
            ## normalise too a total power
            element total_power {
               comment,
               real
            }|
            ## normalise too a total flux
            element total_flux {
               comment,
                  real
            }|
            ## normalise too a total fission
            element total_fission {
               comment,
                  real
            }|
            ## normalise too a total production
            element total_production {
               comment,
               real
            }            
         ),
         ## normalisation domain symmetry factor
         element domain_symmetry_factor {
            comment,
            integer
         }?
      }    
   )


power_iteration_element = 
   (
      ## The maximum number of power iterations
      element maximum {
         comment,
         integer
      },
      ## The power iteration tolerance for the flux
      element flux_tolerance {
         comment,
         real
      },
      ## The power iteration tolerance for the eigenvalue called keff
      element keff_tolerance {
         comment,
         real
      },
      scatter_group_iteration_options?,
      ## Exit the power iteration loop if a prescribed number of consecutive keff are converged
      ## irrespective of the flux eigenvector convergence 
      element exit_if_successive_keff_converged { 
         comment,
         integer
      }?, 
      ## Terminate the simulation if the maximum number of power
      ## iterations is reached and the tolerance criteria (both flux and keff) are not met.
      element terminate_if_not_converged {
         comment,
         empty
      }?            
   )   
   

scatter_group_iteration_options = 
   (
      ## The scatter group iteration options (if not present then only one iteration)
      element scatter_group_iteration {
         comment,
         ## The maximum number of scatter group iterations
         element maximum {
            comment,
            integer
         },
         ## The scatter group iteration tolerance for the flux
         element flux_tolerance {
            comment,
            real
         },                  
         ## The highest upscatter group, if enabled scatter iterations after the
         ## first will start sweeping down from this group
         element highest_upscatter_group {
            comment,
            integer
         }?,
         ## Terminate the simulation if the maximum number of scatter
         ## iterations is reached and the tolerance criterion is not met.
         element terminate_if_not_converged {
            comment
         }?,
         whole_domain_energy_group_rebalance_options?
      }        
   )
   

time_run = 
   (
      ## Perform a time dependent run. Can also be used for steady state run via one large time step.
      element time_run { 
         comment,
         
         radiation_temporal_discretisation,
         
         energy_group_iteration_options,
         
         prescribed_source?
      }      
   )


radiation_temporal_discretisation = 
   (
      ## The temporal discretisation options 
      element temporal_discretisation {
         comment,
         ## the theta value
         element theta {
            comment,
            real
         }
      }   
   )
   
   
energy_group_iteration_options = 
   (
      ## Set the energy group iteration
      element energy_group_iteration {
         comment,
         ## The maximum number of energy group iterations
         element maximum {
            comment,
            integer
         },
         ## The energy group iteration tolerance 
         element tolerance {
            comment,
            real
         },
         scatter_group_iteration_options?,
         ## Terminate the simulation if the maximum number of energy group
         ## iterations is reached and the tolerance criterion is not met.
         element terminate_if_not_converged {
            comment
         }?,
         whole_domain_energy_group_rebalance_options?
      }      
   )


whole_domain_energy_group_rebalance_options = 
   (
      ## Whole domain rebalance acceleration of group iteration   
      element whole_domain_group_rebalance {
         comment,
         (
            ## One rebalance factor for ALL groups 
            element all_group {
               comment
            }|
            ## One rebalance factor for EACH group
            element within_group {
               comment
            }
         )                  
      }                 
   )


prescribed_source = 
   (
      ## Include prescribed source
      element include_prescribed_source {
         comment,
         ## Prescribed source term for a particular energy group
         element source_scalar_field {
            comment,
            attribute name { xsd:string },
            (
               ## The energy group this source is associated with 
               element energy_group {
                  comment,
                  integer
               }|
               ## All energy groups associated with this source
               element all_group { 
                  comment
               }
            ),
            element prescribed {
               comment,
               prescribed_source_scalar_field
            }
         }+
      }
   )
   

prescribed_source_scalar_field = 
   (
      prescribed_values_scalar_field,
      radiation_output_options,
      radiation_stat_options,
      prescribed_detector_options   
   )
   
     
read_radiation_material_data_set =
   (
      ## Read radiation material data set from multiple external files
      element radiation_material_data_set_from_file {
         comment,
         attribute file_name { xsd:string },
         number_of_scatter_moments,
         (   
            ## a format that is a extension of the wims9 LISTTO interface that includes
            ## extra data (eg. velocity, delayed, energy released) and with the options 
            ## to read different data items (eg. total or absorption)
            element format_wims9plus {
               comment,
               ## The maximum line (or record) length of the input file
               element maximum_record_length {
                  comment,
                  integer
               }
            }                                             
         ),
         ## define each physical material
         element physical_material {
            comment,
            attribute name { xsd:string },
            ## define the tabulated interpolation dimensions for this physical material
            element interpolation_dimension {
               comment,
               attribute name { xsd:string },
               ## set the interpolation attribute for this dimension
               ( 
                  ## No attribute so the first radmat of this dimension of this physical material will be used
                  element interpolation_attribute_none{
                     comment
                  }|
                  ## Prescribed interpolation values
                  element interpolation_attribute_prescribed{
                     comment,
                     real
                  }|
                  ## Associate this dimension with a particular scalar field
                  element interpolation_attribute_scalar_field {
                     comment,
                     attribute name { xsd:string }
                  }
               ),                  
               ## define the interpolation values for this dimension as a float list
               element interpolation_values {
                  comment,
                  real_vector
               }               
            }+
         }+
      }+        
   )


number_of_scatter_moments = 
   (
      ## The number of scatter moments associated with this material data set
      element number_of_scatter_moments {
         comment, 
         integer
      }     
   )


radiation_material_mapping =
   (
      ## The region id to radiation physical material mapping. This option is intended for radiation alone with no consideration of 
      ## the rest of the fluids state. This must be used with a prescribed physical material interpolation attribute. 
      element region_id_material_mapping {
         comment,
         element region_to_physical_radiation_material_map {
            comment,
            attribute name { xsd:string },
            region_id,
            radiation_material
         }+, 
         Rad_Fission_and_Power_Template? 
      }?,      
      ## Link with multimaterial model
      element link_with_multimaterial {
         comment,
         ## The fluids material_phase to radiation physical material mapping
         element fluids_material_phase_to_physical_radiation_material_map {
            comment,
            radiation_material,   
            Rad_MaterialVolumeFraction_Template,        
            attribute name { xsd:string }
         }+,
         Rad_MaterialTemperature_Template?,
         Rad_Fission_and_Power_Template?
      }?,         
      ## Link with the porous media model
      element link_with_porous_media {
         comment,
         element porous_media_region_to_physical_radiation_material_map {
            comment,
            attribute name { xsd:string },
            region_id,
            radiation_material
         }+,
         Rad_Porosity_Template,
         Rad_PorousTemperature_Template?, 
         Rad_Fission_and_Power_Template?            
      }?   
   )
   
       
radiation_material = 
   (
      ## radiation physical data set file name
      element radiation_data_set_name {
         comment,
         attribute file_name { xsd:string }
      },
      ## radiation physical material name
      element radiation_physical_material_name {
         comment,
         attribute name { xsd:string }
      }      
   )


region_id = 
   (
      ## the region id
      element region_id {
         comment,
         integer_vector
      }
   )

         
Rad_MaterialVolumeFraction_Template =
   (
      ## The template for the neutral particle flux density material volume fraction scalar field
      ## that is used for the cross section mapping and interpolation,
      ## that is defined with the NeutralParticleMaterialMeshTemplate mesh
      element scalar_field {
         comment,
         attribute name { "RadMaterialVolumeFractionTemplate" },
         ## Field Type
         prescribed_or_scalar_diagnostic_algorithms_scalar_field        
      }          
   )   


Rad_MaterialTemperature_Template =
   (
      ## The template for the temperature scalar field associated with multimaterial
      ## that is used for the cross section interpolation,
      ## that is defined with the NeutralParticleMaterialMeshTemplate mesh
      element scalar_field {
         comment,
         attribute name { "RadMaterialTemperatureTemplate" },
         ## Field Type
         prescribed_or_scalar_diagnostic_algorithms_scalar_field         
      }          
   )   


Rad_Porosity_Template = 
   (
      ## The template for the porosity scalar field
      ## that is used for the cross section interpolation,
      ## that is defined with the NeutralParticleMaterialMeshTemplate mesh
      element scalar_field {
         comment,
         attribute name { "RadPorosityTemplate" },
         ## Field Type
         prescribed_or_scalar_diagnostic_algorithms_scalar_field         
      }          
   )   


Rad_PorousTemperature_Template = 
   (
      ## The template for the porous temperature scalar field
      ## that is used for the cross section interpolation,
      ## that is defined with the NeutralParticleMaterialMeshTemplate mesh
      element scalar_field {
         comment,
         attribute name { "RadPorousTemperatureTemplate" },
         ## Field Type
         prescribed_or_scalar_diagnostic_algorithms_scalar_field     
      }          
   )   


prescribed_or_scalar_diagnostic_algorithms_scalar_field = 
   ( 
      element prescribed {
         comment,
         prescribed_scalar_field
      }|            
      element diagnostic {
         comment,
         scalar_diagnostic_algorithms,
         diagnostic_scalar_field
      }            
   )


Rad_Fission_and_Power_Template = 
   (
       Rad_Fission_Template,
              
       Rad_Power_Template    
   )


Rad_Fission_Template = 
   (
      ## The template for the fission density scalar field, this is always defined on the NeutralParticleMaterialMesh
      element scalar_field {
         comment,
         attribute name { "RadFissionTemplate" },
         ## Field Type
         radiation_internal_algorithm_diagnostic_scalar_field_no_adapt     
      }          
   ) 


Rad_Power_Template = 
   (
      ## The template for the power density scalar field for diagnostics and coupling,
      ## this is always defined on the NeutralParticleMaterialMesh
      element scalar_field {
         comment,
         attribute name { "RadPowerTemplate" },
         ## Field Type
         radiation_internal_algorithm_diagnostic_scalar_field_no_adapt     
      }          
   ) 


radiation_internal_algorithm_diagnostic_scalar_field_no_adapt = 
   ( 
      element diagnostic {
         comment,
         
         internal_algorithm,
         
         radiation_output_options,
      
         radiation_stat_options,
      
         diagnostic_detector_options                  
      }            
   )


delayed_precursor =
   (
      ## Delayed neutron precursor 
      element delayed_neutron_precursor {  
         comment,  
         ## The number of delayed neutron precursor groups
         element number_delayed_neutron_precursor_groups {
            comment,
            integer
         },   
         ## The dataset from which to read the delayed lambda and spectrum from
         element read_delayed_lambda_spectrum_from_data_set {
            comment,
            attribute file_name { xsd:string }
         },      
         ## link with region id, requires the neutron object to be linked with region id also
         element link_with_region_id {
            comment,
            delayed_neutron_precursor_diagnostic_template
         }?,
         ## link with multimaterial, requires the neutron object to be linked with multimaterial also
         element link_with_multimaterial {
            comment,
            prompt_delayed_coupling_option,
            delayed_neutron_precursor_prognostic_or_diagnostic_template                
         }?,               
         ## link with porous media, requires the neutron object to be linked with porous media also
         element link_with_porous_media {
            comment,
            delayed_neutron_precursor_diagnostic_template            
         }?
      }               
   )


prompt_delayed_coupling_option =
   (
      prompt_delayed_coupling_semi_implicit_option|
      prompt_delayed_coupling_implicit_option|              
      prompt_delayed_coupling_explicit_option
   )


prompt_delayed_coupling_implicit_option = 
   (
      ## Implicit coupling between prompt and delayed neutron equations
      element prompt_delayed_coupling_implicit {
         comment
      }   
   )


prompt_delayed_coupling_semi_implicit_option = 
   (
      ## Semi-implicit coupling between prompt and delayed neutron equations
      element prompt_delayed_coupling_semi_implicit {
         comment
      }   
   )


prompt_delayed_coupling_explicit_option = 
   (
      ## Explicit coupling between prompt and delayed neutron equations
      element prompt_delayed_coupling_explicit {
         comment
      }         
   )       

   
delayed_neutron_precursor_prognostic_or_diagnostic_template =
   (
      ##  The template delayed neutron precursor scalar field,
      ##  that is defined with the DelayedNeutronMeshTemplate mesh
      ##  Field Type:
      ##   - use prognostic for time run
      ##   - use diagnostic for eigenvalue run
      element scalar_field {
         comment,
         attribute name { "DelayedNeutronPrecursorTemplate" },
         (
            prognostic_delayed_neutron_advection_decay_source_scalar_field|
            radiation_internal_algorithm_diagnostic_scalar_field_no_adapt
         )         
      }
   )

   
delayed_neutron_precursor_diagnostic_template =
   (
      ## The template delayed neutron precursor scalar field,
      ## that is defined with the DelayedNeutronMeshTemplate mesh
      element scalar_field {
         comment,
         attribute name { "DelayedNeutronPrecursorTemplate" },
         radiation_internal_algorithm_diagnostic_scalar_field_no_adapt
      }
   )


prognostic_delayed_neutron_advection_decay_source_scalar_field = 
   (
      element prognostic {
         comment,

         ## Solve a delayed neutron advection-decay-source equation
         element equation {
            comment,
            attribute name { "AdvectionDiffusion" }
         },
         ## Spatial discretisation options
         element spatial_discretisation {
            comment,
            (
               ## Continuous galerkin formulation
               element continuous_galerkin {
                  advection_stabilisation_options,
                  cg_advection_terms
               }|
               ## Discontinuous galerkin formulation
               element discontinuous_galerkin {
                  dg_advection_scheme,
                  dg_upwind_stabilisation
               }            
            ),
            conservative_advection_option
         },
         ## The temporal discretisation options 
         element temporal_discretisation {
            comment,
            ## the theta value
            element theta {
               comment,
               real
            },
            temporal_discontinuous_galerkin_options?
         },
         ## The solver options
         element solver {
            comment,
            linear_solver_options_asym
         },
         
         radiation_initial_conditions+,
         
         prognostic_scalar_output_options,
         prognostic_scalar_stat_options,
         scalar_convergence_options,
         prognostic_detector_options,
         scalar_steady_state_options,
         adaptivity_options_scalar_field,
         interpolation_algorithm_scalar
      }
   )
