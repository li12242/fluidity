<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <!-- The radiation options -->
  <define name="radiation">
    <element name="radiation">
      <a:documentation>Radiation model </a:documentation>
      <ref name="comment"/>
      <optional>
        <ref name="particle_type_neutron"/>
      </optional>
      <optional>
        <ref name="particle_type_photon"/>
      </optional>
    </element>
  </define>
  <define name="particle_type_neutron">
    <element name="particle_type">
      <a:documentation>Particle type neutron</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Neutron</value>
      </attribute>
      <ref name="equation_type_neutron"/>
      <ref name="particle_type_generic"/>
      <optional>
        <ref name="delayed_precursor"/>
      </optional>
    </element>
  </define>
  <define name="particle_type_photon">
    <element name="particle_type">
      <a:documentation>Particle type photon</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Photon</value>
      </attribute>
      <ref name="equation_type_photon"/>
      <ref name="particle_type_generic"/>
    </element>
  </define>
  <define name="equation_type_neutron">
    <choice>
      <ref name="eigenvalue_equation"/>
      <ref name="time_equation"/>
    </choice>
  </define>
  <define name="equation_type_photon">
    <ref name="time_equation"/>
  </define>
  <define name="particle_type_generic">
    <ref name="energy_discretisation"/>
    <oneOrMore>
      <ref name="radiation_material_data_set"/>
    </oneOrMore>
    <ref name="radiation_material_mapping"/>
  </define>
  <define name="energy_discretisation">
    <element name="energy_discretisation">
      <a:documentation>The energy discretisation for the whole spatial mesh</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="energy_continuity"/>
      <ref name="energy_degree"/>
      <oneOrMore>
        <ref name="energy_group_set"/>
      </oneOrMore>
    </element>
  </define>
  <define name="energy_continuity">
    <element name="continuity">
      <a:documentation>The energy discretisation continuity</a:documentation>
      <ref name="comment"/>
      <element name="string_value">
        <value>discontinuous</value>
      </element>
    </element>
  </define>
  <define name="energy_degree">
    <element name="degree">
      <a:documentation>The energy discretisation degree</a:documentation>
      <ref name="comment"/>
      <element name="integer_value">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <value>0</value>
      </element>
    </element>
  </define>
  <define name="energy_group_set">
    <element name="energy_group_set">
      <a:documentation>Define a group set of consecutive energy groups, where each group 
within the set shares the group set options. The global 
group numbering starts at 1 from the first group within 
the first group set then increases in the order the group 
sets are defined.</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="number_of_energy_groups"/>
      <ref name="angular_discretisation"/>
    </element>
  </define>
  <define name="number_of_energy_groups">
    <element name="number_of_energy_groups">
      <a:documentation>The number of energy groups</a:documentation>
      <ref name="comment"/>
      <ref name="integer"/>
    </element>
  </define>
  <define name="angular_discretisation">
    <element name="angular_discretisation">
      <a:documentation>The angular discetisation for the whole spatial mesh 
assoicated with this energy group set</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <ref name="angular_discretisation_method"/>
    </element>
  </define>
  <define name="angular_discretisation_method">
    <element name="method">
      <a:documentation>The spherical harmonic angular discretisation method </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>SphericalHarmonic</value>
      </attribute>
      <ref name="angular_parity"/>
    </element>
  </define>
  <define name="angular_parity">
    <element name="parity">
      <a:documentation>Solve for the even parity flux
of this angular discretisation </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Even</value>
      </attribute>
      <ref name="even_parity_source_options"/>
      <optional>
        <ref name="calculate_odd_parity"/>
      </optional>
      <ref name="angular_moment_set_even_parity"/>
    </element>
  </define>
  <define name="even_parity_source_options">
    <element name="exclude_odd_parity_time_source">
      <a:documentation> Exclude the odd parity time source
 NOT RELEVANT FOR EQUATION(EIGENVALUE)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="calculate_odd_parity">
    <element name="scalar_field">
      <a:documentation>The odd parity particle flux scalar field calculated 
diagnostically from the even parity solution </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>ParticleFluxOddParity</value>
      </attribute>
      <ref name="odd_parity_internal_algorithm_diagnostic_scalar_field_no_adapt"/>
    </element>
  </define>
  <define name="odd_parity_internal_algorithm_diagnostic_scalar_field_no_adapt">
    <element name="diagnostic">
      <ref name="comment"/>
      <ref name="internal_algorithm"/>
      <ref name="odd_parity_mesh_choice"/>
      <ref name="radiation_output_options"/>
      <ref name="radiation_stat_options"/>
      <ref name="diagnostic_detector_options"/>
    </element>
  </define>
  <define name="odd_parity_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>OddParityParticleMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>ParticleMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="angular_moment_set_even_parity">
    <element name="angular_moment_set">
      <a:documentation>Define a consecutive angular moment set, where each 
moment within the set shares the same options. Global
moment numbering starts from moment 1 of the first set
then increases in the order that the moment sets are defined.
The moment sets defined are only for the prognostically 
calculated parity flux moments (e.g. for even parity only
define the necessary even parity moments)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>AllMoments</value>
      </attribute>
      <ref name="number_of_angular_moments"/>
      <ref name="particle_type_material_mesh_choice"/>
      <ref name="particle_flux_diffusion_field"/>
    </element>
  </define>
  <define name="number_of_angular_moments">
    <element name="number_of_angular_moments">
      <a:documentation>The number of angular moments</a:documentation>
      <ref name="comment"/>
      <element name="integer_value">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <value>1</value>
      </element>
    </element>
  </define>
  <define name="particle_type_material_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>ParticleMaterialMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="particle_flux_diffusion_field">
    <element name="scalar_field">
      <a:documentation>The particle flux scalar field for the angular discretised
even parity formulation for this group set</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>ParticleFlux</value>
      </attribute>
      <ref name="prognostic_particle_diffusion_removal_source_scalar_field"/>
    </element>
  </define>
  <define name="prognostic_particle_diffusion_removal_source_scalar_field">
    <element name="prognostic">
      <a:documentation>Field Type</a:documentation>
      <ref name="comment"/>
      <ref name="particle_type_mesh_choice"/>
      <ref name="radiation_spatial_diffusion_equation"/>
      <ref name="radiation_diffusion_spatial_discretisation"/>
      <optional>
        <ref name="radiation_temporal_discretisation"/>
      </optional>
      <ref name="radiation_diffusion_inner_solver_options"/>
      <oneOrMore>
        <ref name="radiation_initial_conditions"/>
      </oneOrMore>
      <zeroOrMore>
        <ref name="radiation_diffusion_boundary_conditions"/>
      </zeroOrMore>
      <optional>
        <ref name="radiation_diffusion_prescribed_source"/>
      </optional>
      <ref name="radiation_output_options"/>
      <ref name="radiation_stat_options"/>
      <ref name="prognostic_detector_options"/>
      <ref name="adaptivity_options_scalar_field"/>
      <ref name="interpolation_algorithm_scalar"/>
    </element>
  </define>
  <define name="particle_type_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>ParticleMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="radiation_spatial_diffusion_equation">
    <element name="equation">
      <a:documentation>The equation to solve for this scalar field</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Diffusion</value>
      </attribute>
    </element>
  </define>
  <define name="radiation_diffusion_spatial_discretisation">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <ref name="comment"/>
      <element name="continuous_galerkin">
        <a:documentation>Continuous galerkin formulation</a:documentation>
        <ref name="comment"/>
      </element>
    </element>
  </define>
  <define name="radiation_temporal_discretisation">
    <element name="temporal_discretisation">
      <a:documentation> The temporal discretisation options 
 NOT RELEVANT FOR EQUATION(EIGENVALUE)</a:documentation>
      <ref name="comment"/>
      <element name="theta">
        <a:documentation>the theta value</a:documentation>
        <ref name="comment"/>
        <ref name="real"/>
      </element>
    </element>
  </define>
  <define name="radiation_diffusion_inner_solver_options">
    <element name="solver">
      <a:documentation>The inner solver options</a:documentation>
      <ref name="comment"/>
      <ref name="linear_solver_options_sym"/>
    </element>
  </define>
  <define name="radiation_initial_conditions">
    <element name="initial_condition">
      <a:documentation>Initial condition for WholeSpatialMesh associated with this
angular moment set (itself associated with a energy group set)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>WholeMesh</value>
      </attribute>
      <choice>
        <element name="constant">
          <a:documentation>Constant value</a:documentation>
          <ref name="real"/>
        </element>
        <element name="from_file">
          <a:documentation>Initialise the field from an existing file (indended
primarily for use in checkpointing). The file mesh must match
the mesh of this field  (except for piecewise constant fields 
which will be remapped back from the discontinuous nodal values). 
In parallel the process number is
appended to the filename, e.g. if the file_name attribute is
set to "input.vtu", process 0 reads from "input-0.vtu".</a:documentation>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <ref name="vtu_input_format"/>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="radiation_diffusion_boundary_conditions">
    <element name="boundary_conditions">
      <a:documentation>The problem boundary conditions associated with this
angular moment set (itself associated with a energy group set)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <ref name="surface_ids"/>
      <ref name="diffusion_bc_type"/>
    </element>
  </define>
  <define name="surface_ids">
    <element name="surface_ids">
      <a:documentation>The surface id associated with this boundary condition</a:documentation>
      <ref name="comment"/>
      <ref name="integer_vector"/>
    </element>
  </define>
  <define name="diffusion_bc_type">
    <choice>
      <a:documentation>Type</a:documentation>
      <ref name="diffusion_albedo"/>
      <ref name="diffusion_dirichlet"/>
      <ref name="diffusion_source"/>
    </choice>
  </define>
  <define name="diffusion_albedo">
    <element name="type">
      <a:documentation>Albedo boundary condition, requires a value from 0.0 (perfect vacuum) 
to 1.0 (perfect reflective)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>albedo</value>
      </attribute>
      <ref name="input_choice_real"/>
    </element>
  </define>
  <define name="diffusion_dirichlet">
    <element name="type">
      <a:documentation>Dirichlet </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>dirichlet</value>
      </attribute>
      <ref name="input_choice_real"/>
    </element>
  </define>
  <define name="diffusion_source">
    <element name="type">
      <a:documentation>Isotropic particle source boundary condition, this value specifies the 
actually current into the domain NOT the total isotropic source strength 
located on the surface (the total source strength is twice the value input here) </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>source</value>
      </attribute>
      <ref name="input_choice_real"/>
    </element>
  </define>
  <define name="radiation_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <ref name="comment"/>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="radiation_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to the .stat file</a:documentation>
      <ref name="comment"/>
      <optional>
        <element name="exclude_from_stat">
          <a:documentation>Exclude this field from the .stat file</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="radiation_diffusion_prescribed_source">
    <element name="scalar_field">
      <a:documentation> Prescribed isotropic source term
 NOT RELEVANT FOR EQUATION(EIGENVALUE)</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Source</value>
      </attribute>
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <element name="prescribed">
        <ref name="comment"/>
        <ref name="radiation_diffusion_prescribed_source_scalar_field"/>
      </element>
    </element>
  </define>
  <define name="radiation_diffusion_prescribed_source_scalar_field">
    <ref name="prescribed_values_scalar_field"/>
    <ref name="radiation_output_options"/>
    <ref name="radiation_stat_options"/>
    <ref name="prescribed_detector_options"/>
  </define>
  <define name="eigenvalue_equation">
    <element name="equation">
      <a:documentation>Select the equation type to solve.</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>Eigenvalue</value>
      </attribute>
      <ref name="eigenvalue_equation_solver"/>
      <ref name="flux_normalisation_options"/>
    </element>
  </define>
  <define name="eigenvalue_equation_solver">
    <group>
      <a:documentation>Eigen Solver Algorithm</a:documentation>
      <element name="power_iteration">
        <a:documentation>Power Iterations</a:documentation>
        <ref name="comment"/>
        <ref name="power_iteration_element"/>
      </element>
    </group>
  </define>
  <define name="flux_normalisation_options">
    <choice>
      <element name="flux_normalisation">
        <a:documentation> The particle flux normalisation
 to a total flux</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>TotalFlux</value>
        </attribute>
        <ref name="flux_norm_value_and_symmetry"/>
      </element>
      <element name="flux_normalisation">
        <a:documentation> The particle flux normalisation
 to a total flux</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>TotalProduction</value>
        </attribute>
        <ref name="flux_norm_value_and_symmetry"/>
      </element>
      <element name="flux_normalisation">
        <a:documentation> The particle flux normalisation
 to a total flux</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>TotalFission</value>
        </attribute>
        <ref name="flux_norm_value_and_symmetry"/>
      </element>
      <element name="flux_normalisation">
        <a:documentation> The particle flux normalisation
 to a total flux</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>TotalPower</value>
        </attribute>
        <ref name="flux_norm_value_and_symmetry"/>
      </element>
    </choice>
  </define>
  <define name="flux_norm_value_and_symmetry">
    <element name="value">
      <a:documentation>Normalisation value</a:documentation>
      <ref name="comment"/>
      <ref name="real"/>
    </element>
    <optional>
      <element name="domain_symmetry_factor">
        <a:documentation>Normalisation domain symmetry factor
where for example 4 implies quarter geometry represented</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="power_iteration_element">
    <element name="maximum">
      <a:documentation>The maximum number of power iterations</a:documentation>
      <ref name="comment"/>
      <ref name="integer"/>
    </element>
    <element name="flux_tolerance_absolute">
      <a:documentation>The power iteration absolute tolerance for the flux</a:documentation>
      <ref name="comment"/>
      <ref name="real"/>
    </element>
    <element name="keff_tolerance_relative">
      <a:documentation>The power iteration relative tolerance for the eigenvalue called keff</a:documentation>
      <ref name="comment"/>
      <ref name="real"/>
    </element>
    <optional>
      <ref name="scatter_group_iteration_options"/>
    </optional>
    <optional>
      <element name="terminate_if_not_converged">
        <a:documentation>Terminate the simulation if the maximum number of power
iterations is reached and the tolerance criteria (both flux and keff) are not met.</a:documentation>
        <ref name="comment"/>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="scatter_group_iteration_options">
    <element name="scatter_group_iteration">
      <a:documentation>The scatter group iteration options (if not present then only one iteration)</a:documentation>
      <ref name="comment"/>
      <element name="maximum">
        <a:documentation>The maximum number of scatter group iterations</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
      <element name="flux_tolerance_absolute">
        <a:documentation>The scatter group iteration absolute tolerance for the flux</a:documentation>
        <ref name="comment"/>
        <ref name="real"/>
      </element>
      <optional>
        <element name="highest_upscatter_group">
          <a:documentation>The highest upscatter group, if enabled scatter iterations after the
first will start sweeping down from this group</a:documentation>
          <ref name="comment"/>
          <ref name="integer"/>
        </element>
      </optional>
      <optional>
        <element name="terminate_if_not_converged">
          <a:documentation>Terminate the simulation if the maximum number of scatter
iterations is reached and the tolerance criterion is not met.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <ref name="whole_domain_energy_group_rebalance_options"/>
      </optional>
    </element>
  </define>
  <define name="time_equation">
    <element name="equation">
      <a:documentation>Select the equation type to solve.</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>TimeDependent</value>
      </attribute>
      <ref name="energy_group_iteration_options"/>
    </element>
  </define>
  <define name="energy_group_iteration_options">
    <element name="energy_group_iteration">
      <a:documentation>Set the energy group iteration</a:documentation>
      <ref name="comment"/>
      <element name="maximum">
        <a:documentation>The maximum number of energy group iterations</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
      <element name="flux_tolerance_absolute">
        <a:documentation>The energy group iteration absolute flux tolerance </a:documentation>
        <ref name="comment"/>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="scatter_group_iteration_options"/>
      </optional>
      <optional>
        <element name="terminate_if_not_converged">
          <a:documentation>Terminate the simulation if the maximum number of energy group
iterations is reached and the tolerance criterion is not met.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <ref name="whole_domain_energy_group_rebalance_options"/>
      </optional>
    </element>
  </define>
  <define name="whole_domain_energy_group_rebalance_options">
    <choice>
      <element name="whole_domain_group_rebalance">
        <a:documentation>Whole domain rebalance acceleration of 
all energy groups together    </a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>AllEnergyGroup</value>
        </attribute>
      </element>
      <element name="whole_domain_group_rebalance">
        <a:documentation>Whole domain rebalance acceleration of 
each energy group individually</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>EachEnergyGroup</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="radiation_material_data_set">
    <element name="material_data_set">
      <a:documentation>Define a radiation material data set </a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <element name="from_file">
        <a:documentation>Read the radiation material data set from a file
(Include any file name extensions in the file name as well as the path if needed)</a:documentation>
        <ref name="comment"/>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="number_of_scatter_moments"/>
        <ref name="radiation_material_data_set_format"/>
        <oneOrMore>
          <ref name="radiation_physical_material"/>
        </oneOrMore>
      </element>
    </element>
  </define>
  <define name="radiation_material_data_set_format">
    <element name="format_radmats">
      <a:documentation>A keyword based embedded radiation data type format file, of which a subset 
includes the formatted file produced via a LISTTO from WIMS9</a:documentation>
      <ref name="comment"/>
      <element name="maximum_record_length">
        <a:documentation>The maximum line (or record) length of the input file</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
    </element>
  </define>
  <define name="radiation_physical_material">
    <element name="physical_material">
      <a:documentation>Define each physical material</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <oneOrMore>
        <element name="interpolation_dimension">
          <a:documentation>define the tabulated interpolation dimensions for this physical material</a:documentation>
          <ref name="comment"/>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <choice>
            <a:documentation>set the interpolation attribute for this dimension</a:documentation>
            <element name="interpolation_attribute_none">
              <a:documentation>No attribute so the first radmat of this dimension of this physical material will be used</a:documentation>
              <ref name="comment"/>
            </element>
            <element name="interpolation_attribute_prescribed">
              <a:documentation>Prescribed interpolation</a:documentation>
              <ref name="comment"/>
              <ref name="real"/>
            </element>
            <element name="interpolation_attribute_scalar_field">
              <a:documentation>Associate this dimension with a particular scalar field</a:documentation>
              <ref name="comment"/>
              <attribute name="name">
                <data type="string"/>
              </attribute>
            </element>
          </choice>
          <element name="interpolation_values">
            <a:documentation>define the interpolation values for this dimension as a float list</a:documentation>
            <ref name="comment"/>
            <ref name="real_vector"/>
          </element>
        </element>
      </oneOrMore>
    </element>
  </define>
  <define name="number_of_scatter_moments">
    <element name="number_of_scatter_moments">
      <a:documentation>The number of scatter moments associated with this material data set</a:documentation>
      <ref name="comment"/>
      <ref name="integer"/>
    </element>
  </define>
  <define name="radiation_material_mapping">
    <optional>
      <element name="region_id_material_mapping">
        <a:documentation>The region id to radiation physical material mapping. This option is intended for radiation alone with no consideration of 
the rest of the fluids state. This must be used with a prescribed physical material interpolation attribute. </a:documentation>
        <ref name="comment"/>
        <oneOrMore>
          <element name="region_to_physical_radiation_material_map">
            <ref name="comment"/>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="region_id"/>
            <ref name="radiation_material"/>
          </element>
        </oneOrMore>
      </element>
    </optional>
    <optional>
      <element name="link_with_multimaterial">
        <a:documentation>Link with multimaterial model</a:documentation>
        <ref name="comment"/>
        <oneOrMore>
          <element name="fluids_material_phase_to_physical_radiation_material_map">
            <a:documentation>The fluids material_phase to radiation physical material mapping</a:documentation>
            <ref name="comment"/>
            <ref name="radiation_material"/>
            <ref name="Rad_MaterialVolumeFraction"/>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </oneOrMore>
        <optional>
          <ref name="Rad_MaterialTemperature"/>
        </optional>
      </element>
    </optional>
    <optional>
      <element name="link_with_porous_media">
        <a:documentation>Link with the porous media model</a:documentation>
        <ref name="comment"/>
        <oneOrMore>
          <element name="porous_media_region_to_physical_radiation_material_map">
            <ref name="comment"/>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="region_id"/>
            <ref name="radiation_material"/>
          </element>
        </oneOrMore>
        <ref name="Rad_Porosity"/>
        <optional>
          <ref name="Rad_PorousTemperature"/>
        </optional>
      </element>
    </optional>
  </define>
  <define name="radiation_material">
    <element name="data_set">
      <a:documentation>Data set name</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
    </element>
    <element name="physical_material">
      <a:documentation>Physical material name</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <data type="string"/>
      </attribute>
    </element>
  </define>
  <define name="region_id">
    <element name="region_id">
      <a:documentation>the region id</a:documentation>
      <ref name="comment"/>
      <ref name="integer_vector"/>
    </element>
  </define>
  <define name="Rad_MaterialVolumeFraction">
    <element name="scalar_field">
      <a:documentation>The material volume fraction scalar field
that is used for the cross section mapping and interpolation</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>RadMaterialVolumeFraction</value>
      </attribute>
      <ref name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
        <a:documentation>Field Type</a:documentation>
      </ref>
    </element>
  </define>
  <define name="Rad_MaterialTemperature">
    <element name="scalar_field">
      <a:documentation>The temperature scalar field associated with multimaterial
that is used for the cross section interpolation</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>RadMaterialTemperature</value>
      </attribute>
      <ref name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
        <a:documentation>Field Type</a:documentation>
      </ref>
    </element>
  </define>
  <define name="Rad_Porosity">
    <element name="scalar_field">
      <a:documentation>The porosity scalar field that is used for the cross section interpolation</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>RadPorosity</value>
      </attribute>
      <ref name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
        <a:documentation>Field Type</a:documentation>
      </ref>
    </element>
  </define>
  <define name="Rad_PorousTemperature">
    <element name="scalar_field">
      <a:documentation>The porous temperature scalar field
that is used for the cross section interpolation</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>RadPorousTemperature</value>
      </attribute>
      <ref name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
        <a:documentation>Field Type</a:documentation>
      </ref>
    </element>
  </define>
  <define name="prescribed_or_scalar_diagnostic_algorithms_scalar_field">
    <choice>
      <element name="prescribed">
        <ref name="comment"/>
        <ref name="particle_type_material_mesh_choice"/>
        <ref name="prescribed_scalar_field"/>
      </element>
      <element name="diagnostic">
        <ref name="comment"/>
        <ref name="scalar_diagnostic_algorithms"/>
        <ref name="particle_type_material_mesh_choice"/>
        <ref name="diagnostic_scalar_field"/>
      </element>
    </choice>
  </define>
  <define name="delayed_precursor">
    <element name="delayed_neutron_precursor">
      <a:documentation>Delayed neutron precursor </a:documentation>
      <ref name="comment"/>
      <element name="number_delayed_neutron_precursor_groups">
        <a:documentation>The number of delayed neutron precursor groups</a:documentation>
        <ref name="comment"/>
        <ref name="integer"/>
      </element>
      <element name="read_delayed_lambda_spectrum_from_data_set">
        <a:documentation>The dataset from which to read the delayed lambda and spectrum from</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <optional>
        <element name="link_with_region_id">
          <a:documentation>link with region id, requires the neutron object to be linked with region id also</a:documentation>
          <ref name="comment"/>
          <ref name="delayed_neutron_precursor_diagnostic"/>
        </element>
      </optional>
      <optional>
        <element name="link_with_multimaterial">
          <a:documentation>link with multimaterial, requires the neutron object to be linked with multimaterial also</a:documentation>
          <ref name="comment"/>
          <ref name="prompt_delayed_coupling_option"/>
          <ref name="delayed_neutron_precursor_prognostic_or_diagnostic"/>
        </element>
      </optional>
      <optional>
        <element name="link_with_porous_media">
          <a:documentation>link with porous media, requires the neutron object to be linked with porous media also</a:documentation>
          <ref name="comment"/>
          <ref name="delayed_neutron_precursor_diagnostic"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="prompt_delayed_coupling_option">
    <choice>
      <ref name="prompt_delayed_coupling_semi_implicit_option"/>
      <ref name="prompt_delayed_coupling_explicit_option"/>
    </choice>
  </define>
  <define name="prompt_delayed_coupling_semi_implicit_option">
    <element name="prompt_delayed_coupling_semi_implicit">
      <a:documentation>Semi-implicit coupling between prompt and delayed neutron equations</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="prompt_delayed_coupling_explicit_option">
    <element name="prompt_delayed_coupling_explicit">
      <a:documentation>Explicit coupling between prompt and delayed neutron equations</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="delayed_neutron_precursor_prognostic_or_diagnostic">
    <element name="scalar_field">
      <a:documentation> The delayed neutron precursor scalar field
 Field Type:
  - use prognostic for time run
  - use diagnostic for eigenvalue run</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>DelayedNeutronPrecursor</value>
      </attribute>
      <choice>
        <ref name="prognostic_delayed_neutron_advection_decay_source_scalar_field"/>
        <ref name="delayed_internal_algorithm_diagnostic_scalar_field_no_adapt"/>
      </choice>
    </element>
  </define>
  <define name="delayed_neutron_precursor_diagnostic">
    <element name="scalar_field">
      <a:documentation>The delayed neutron precursor scalar field</a:documentation>
      <ref name="comment"/>
      <attribute name="name">
        <value>DelayedNeutronPrecursor</value>
      </attribute>
      <ref name="delayed_internal_algorithm_diagnostic_scalar_field_no_adapt"/>
    </element>
  </define>
  <define name="delayed_internal_algorithm_diagnostic_scalar_field_no_adapt">
    <element name="diagnostic">
      <ref name="comment"/>
      <ref name="internal_algorithm"/>
      <ref name="delayed_particle_type_mesh_choice"/>
      <ref name="radiation_output_options"/>
      <ref name="radiation_stat_options"/>
      <ref name="diagnostic_detector_options"/>
    </element>
  </define>
  <define name="prognostic_delayed_neutron_advection_decay_source_scalar_field">
    <element name="prognostic">
      <ref name="comment"/>
      <ref name="delayed_particle_type_mesh_choice"/>
      <element name="equation">
        <a:documentation>Solve a delayed neutron advection-decay-source equation</a:documentation>
        <ref name="comment"/>
        <attribute name="name">
          <value>AdvectionDiffusion</value>
        </attribute>
      </element>
      <element name="spatial_discretisation">
        <a:documentation>Spatial discretisation options</a:documentation>
        <ref name="comment"/>
        <choice>
          <element name="continuous_galerkin">
            <a:documentation>Continuous galerkin formulation</a:documentation>
            <ref name="advection_stabilisation_options"/>
            <ref name="cg_advection_terms"/>
          </element>
          <element name="discontinuous_galerkin">
            <a:documentation>Discontinuous galerkin formulation</a:documentation>
            <ref name="dg_advection_scheme"/>
            <ref name="dg_upwind_stabilisation"/>
          </element>
        </choice>
        <ref name="conservative_advection_option"/>
      </element>
      <element name="temporal_discretisation">
        <a:documentation>The temporal discretisation options </a:documentation>
        <ref name="comment"/>
        <element name="theta">
          <a:documentation>the theta value</a:documentation>
          <ref name="comment"/>
          <ref name="real"/>
        </element>
        <optional>
          <ref name="temporal_discontinuous_galerkin_options"/>
        </optional>
      </element>
      <element name="solver">
        <a:documentation>The solver options</a:documentation>
        <ref name="comment"/>
        <ref name="linear_solver_options_asym"/>
      </element>
      <oneOrMore>
        <ref name="radiation_initial_conditions"/>
      </oneOrMore>
      <ref name="prognostic_scalar_output_options"/>
      <ref name="prognostic_scalar_stat_options"/>
      <ref name="scalar_convergence_options"/>
      <ref name="prognostic_detector_options"/>
      <ref name="scalar_steady_state_options"/>
      <ref name="adaptivity_options_scalar_field"/>
      <ref name="interpolation_algorithm_scalar"/>
    </element>
  </define>
  <define name="delayed_particle_type_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>DelayedParticleMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
</grammar>
