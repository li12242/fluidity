<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <define name="source_field">
    <attribute name="source_field_name">
      <data type="string"/>
    </attribute>
  </define>
  <define name="scalar_source_field">
    <ref name="source_field"/>
  </define>
  <define name="scalar_source_field" combine="interleave">
    <attribute name="source_field_type">
      <value>scalar</value>
    </attribute>
  </define>
  <define name="vector_source_field">
    <ref name="source_field"/>
  </define>
  <define name="vector_source_field" combine="interleave">
    <attribute name="source_field_type">
      <value>vector</value>
    </attribute>
  </define>
  <define name="tensor_source_field">
    <ref name="source_field"/>
  </define>
  <define name="tensor_source_field" combine="interleave">
    <attribute name="source_field_type">
      <value>tensor</value>
    </attribute>
  </define>
  <define name="component_source_field">
    <ref name="source_field"/>
  </define>
  <define name="component_source_field" combine="interleave">
    <attribute name="source_field_type">
      <value>component</value>
    </attribute>
    <optional>
      <element name="source_field_component">
        <a:documentation>If enabled, uses the component of a vector field as a source field.
Otherwise, uses a scalar field as a source field.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="source_field_1">
    <attribute name="source_field_1_name">
      <data type="string"/>
    </attribute>
  </define>
  <define name="source_field_2">
    <attribute name="source_field_2_name">
      <data type="string"/>
    </attribute>
  </define>
  <define name="scalar_source_field_1">
    <ref name="source_field_1"/>
  </define>
  <define name="scalar_source_field_1" combine="interleave">
    <attribute name="source_field_1_type">
      <value>scalar</value>
    </attribute>
  </define>
  <define name="scalar_source_field_2">
    <ref name="source_field_2"/>
  </define>
  <define name="scalar_source_field_2" combine="interleave">
    <attribute name="source_field_2_type">
      <value>scalar</value>
    </attribute>
  </define>
  <define name="vector_source_field_1">
    <ref name="source_field_1"/>
  </define>
  <define name="vector_source_field_1" combine="interleave">
    <attribute name="source_field_1_type">
      <value>vector</value>
    </attribute>
  </define>
  <define name="vector_source_field_2">
    <ref name="source_field_2"/>
  </define>
  <define name="vector_source_field_2" combine="interleave">
    <attribute name="source_field_2_type">
      <value>vector</value>
    </attribute>
  </define>
  <define name="tensor_source_field_1">
    <ref name="source_field_1"/>
  </define>
  <define name="tensor_source_field_1" combine="interleave">
    <attribute name="source_field_1_type">
      <value>tensor</value>
    </attribute>
  </define>
  <define name="tensor_source_field_2">
    <ref name="source_field_2"/>
  </define>
  <define name="tensor_source_field_2" combine="interleave">
    <attribute name="source_field_2_type">
      <value>tensor</value>
    </attribute>
  </define>
  <define name="component_source_field_1">
    <ref name="source_field_1"/>
  </define>
  <define name="component_source_field_1" combine="interleave">
    <attribute name="source_field_1_type">
      <value>component</value>
    </attribute>
    <optional>
      <element name="source_field_1_component">
        <a:documentation>If enabled, uses the component of a vector field as a source field.
Otherwise, uses a scalar field as a source field.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="component_source_field_2">
    <ref name="source_field_2"/>
  </define>
  <define name="component_source_field_2" combine="interleave">
    <attribute name="source_field_2_type">
      <value>component</value>
    </attribute>
    <optional>
      <element name="source_field_2_component">
        <a:documentation>If enabled, uses the component of a vector field as a source field.
Otherwise, uses a scalar field as a source field.</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="internal_algorithm">
    <element name="algorithm">
      <a:documentation>This diagnostic is internal - i.e. it is calculated somewhere within
the main code, and is not wrapped by the automatic diagnostics
wrappers.</a:documentation>
      <attribute name="name">
        <value>Internal</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
    </element>
  </define>
  <define name="internal_velocity_source_algorithm">
    <element name="algorithm">
      <a:documentation>Some code paths (e.g. porous media and the traffic model)
use their own internal diagnostic source field. Select
this option to these these internal algorithms.</a:documentation>
      <attribute name="name">
        <value>Internal</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
    </element>
  </define>
  <define name="internal_velocity_absorption_algorithm">
    <element name="algorithm">
      <a:documentation>Some code paths (e.g. porous media and the traffic model)
use their own internal diagnostic absorption field. Select
this option to these these internal algorithms.</a:documentation>
      <attribute name="name">
        <value>Internal</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple</value>
      </attribute>
    </element>
  </define>
  <!-- Simple equality algorithms -->
  <define name="scalar_copy_algorithm">
    <element name="algorithm">
      <a:documentation>Copies the source field. This is intended for testing purposes
&lt;b&gt;only&lt;/b&gt;.</a:documentation>
      <attribute name="name">
        <value>scalar_copy</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="extract_scalar_component_algorithm">
    <element name="algorithm">
      <a:documentation>Extract a component from a vector field as a scalar</a:documentation>
      <attribute name="name">
        <value>extract_scalar_component</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="component_source_field"/>
    </element>
  </define>
  <define name="vector_copy_algorithm">
    <element name="algorithm">
      <a:documentation>Copies the source field. This is intended for testing purposes
&lt;b&gt;only&lt;/b&gt;.</a:documentation>
      <attribute name="name">
        <value>vector_copy</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="tensor_copy_algorithm">
    <element name="algorithm">
      <a:documentation>Copies the source field. This is intended for testing purposes
&lt;b&gt;only&lt;/b&gt;.</a:documentation>
      <attribute name="name">
        <value>tensor_copy</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="tensor_source_field"/>
    </element>
  </define>
  <define name="scalar_galerkin_projection_algorithm">
    <element name="algorithm">
      <a:documentation>Galerkin projects the source field.</a:documentation>
      <attribute name="name">
        <value>scalar_galerkin_projection</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="solver">
          <a:documentation>Solver options. Required if projecting onto a continuous mesh.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="vector_galerkin_projection_algorithm">
    <element name="algorithm">
      <a:documentation>Galerkin projects the source field.</a:documentation>
      <attribute name="name">
        <value>vector_galerkin_projection</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="solver">
          <a:documentation>Solver options. Required if projecting onto a continuous mesh.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="helmholtz_smoothed_scalar_algorithm">
    <element name="algorithm">
      <a:documentation>Smooth a scalar field by inverting a Helmholtz operator.</a:documentation>
      <attribute name="name">
        <value>helmholtz_smoothed_scalar</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="component_source_field"/>
      <element name="smoothing_length_scale">
        <a:documentation>The characteristic length scale used by the smoother.</a:documentation>
        <ref name="real_dim_symmetric_tensor"/>
      </element>
      <element name="solver">
        <a:documentation>Solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <!-- Binary operators -->
  <define name="scalar_difference_algorithm">
    <element name="algorithm">
      <a:documentation>Difference between two scalar fields, field 1 - field 2</a:documentation>
      <attribute name="name">
        <value>scalar_difference</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field_1"/>
      <ref name="scalar_source_field_2"/>
    </element>
  </define>
  <define name="vector_difference_algorithm">
    <element name="algorithm">
      <a:documentation>Difference between two vector fields, field 1 - field 2</a:documentation>
      <attribute name="name">
        <value>vector_difference</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field_1"/>
      <ref name="vector_source_field_2"/>
    </element>
  </define>
  <!-- Time aggregated diagnostics -->
  <!-- Temporal maximum diagnostic algorithm. -->
  <define name="temporalmax_algorithm">
    <element name="algorithm">
      <a:documentation>temporalmax (source field). Calculates the nodewise maximum over time. Note: Does not work with adaptive meshes!</a:documentation>
      <attribute name="name">
        <value>temporalmax</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="persistent">
        <value>true</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="initial_condition">
          <a:documentation>Do not set an initial condition until you know what you are doing. Initial condition is mainly needed for checkpointing. </a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Temporal minimum diagnostic algorithm -->
  <define name="temporalmin_algorithm">
    <element name="algorithm">
      <a:documentation>temporalmin (source field). Calculates the nodewise minimum over time. Note: Does not work with adaptive meshes!</a:documentation>
      <attribute name="name">
        <value>temporalmin</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="persistent">
        <value>true</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="initial_condition">
          <a:documentation>Do not set an initial condition until you know what you are doing. Initial condition is mainly needed for checkpointing. </a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Differential operator diagnostic algorithms -->
  <define name="div_algorithm">
    <element name="algorithm">
      <a:documentation>div (source field)</a:documentation>
      <attribute name="name">
        <value>div</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="finite_element_divergence_algorithm">
    <element name="algorithm">
      <a:documentation>div (source field)
Divergence of the velocity field where
the divergence operator is defined using
the finite element C^T matrix.</a:documentation>
      <attribute name="name">
        <value>finite_element_divergence</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="integrate_divergence_by_parts">
          <a:documentation>Integrate the divergence operator by parts</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <choice>
        <element name="solver">
          <a:documentation>Consistent mass Galerkin projection of divergence. Requires
solver options.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
        <element name="lump_mass">
          <a:documentation>Lumped mass Galerkin projection of divergence</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="grad_algorithm">
    <element name="algorithm">
      <a:documentation>grad (source field)</a:documentation>
      <attribute name="name">
        <value>grad</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="curl_algorithm">
    <element name="algorithm">
      <a:documentation>curl (source field)</a:documentation>
      <attribute name="name">
        <value>curl</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="scalar_advection_algorithm">
    <element name="algorithm">
      <a:documentation>u dot nabla (source field)</a:documentation>
      <attribute name="name">
        <value>scalar_advection</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="vector_advection_algorithm">
    <element name="algorithm">
      <a:documentation>u dot nabla (source field)</a:documentation>
      <attribute name="name">
        <value>vector_advection</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="scalar_laplacian_algorithm">
    <element name="algorithm">
      <a:documentation>nabla^2 (source field). Applies natural boundary conditions on all
boundaries.</a:documentation>
      <attribute name="name">
        <value>scalar_laplacian</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
    </element>
  </define>
  <define name="vector_laplacian_algorithm">
    <element name="algorithm">
      <a:documentation>nabla^2 (source field). Applies natural boundary conditions on all
boundaries.</a:documentation>
      <attribute name="name">
        <value>vector_laplacian</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <!-- Surface diagnostics -->
  <define name="grad_normal_algorithm">
    <element name="algorithm">
      <a:documentation> /
 | grad (source field) dot dn
 /

The output is P0 on the surface. Errors will occur at domain edges -
this is a limitation of current output formats.</a:documentation>
      <attribute name="name">
        <value>grad_normal</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <optional>
        <element name="surface_ids">
          <a:documentation>Surface IDs defining the surface over which to compute the
diagnostic. If disabled, computes over the whole surface.</a:documentation>
          <ref name="integer_vector"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Momentum diagnostics -->
  <define name="buoyancy_algorithm">
    <element name="algorithm">
      <a:documentation>Computes the buoyancy term. Must be on the VelocityBuoyancyDensity mesh.</a:documentation>
      <attribute name="name">
        <value>buoyancy</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="coriolis_algorithm">
    <element name="algorithm">
      <a:documentation>Interpolates the Coriolis term onto the mesh of this diagnostic field</a:documentation>
      <attribute name="name">
        <value>coriolis</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="depends">
        <value>Velocity</value>
      </attribute>
      <choice>
        <element name="consistent_interpolation">
          <a:documentation>Consistently interpolate Coriolis onto this mesh</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="galerkin_projection">
          <a:documentation>Galerkin project Coriolis onto this mesh</a:documentation>
          <choice>
            <element name="solver">
              <a:documentation>Consistent mass Galerkin projection. Requires solver options.</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <element name="lump_mass">
              <a:documentation>Lumped mass Galerkin projection.</a:documentation>
              <ref name="comment"/>
            </element>
          </choice>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="scalar_potential_algorithm">
    <element name="algorithm">
      <a:documentation>Compute the scalar potential phi where:
  F = nabla phi + nabla x A + H
with a Neumann boundary condition of nabla phi dot n = F dot n on
all boundaries.</a:documentation>
      <attribute name="name">
        <value>scalar_potential</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <optional>
        <element name="reference_node">
          <a:documentation>Solver reference node</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
      <element name="solver">
        <a:documentation>Linear solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="projection_scalar_potential_algorithm">
    <element name="algorithm">
      <a:documentation>Compute the scalar potential phi where:
  F = nabla phi + nabla x A + H
using a pressure projection method</a:documentation>
      <attribute name="name">
        <value>projection_scalar_potential</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field_1"/>
      <optional>
        <element name="source_field_2_name">
          <a:documentation>If enabled, applies geopressure preconditioning using this field</a:documentation>
          <attribute name="source_field_2_type">
            <value>scalar</value>
          </attribute>
          <ref name="anystring"/>
        </element>
      </optional>
      <element name="spatial_discretisation">
        <a:documentation>Spatial discretisation options</a:documentation>
        <element name="mass">
          <a:documentation>Options relating to the mass matrix</a:documentation>
          <optional>
            <element name="lump_mass">
              <a:documentation>Lump the mass matrix. Required for continuous fields.</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
        </element>
        <element name="continuous_galerkin">
          <a:documentation>Use a continuous Galerkin discretisation</a:documentation>
          <optional>
            <element name="integrate_divergence_by_parts">
              <a:documentation>Integrate the divergence operator by parts</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="remove_stabilisation_term">
              <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="comment"/>
        </element>
      </element>
      <optional>
        <element name="reference_node">
          <a:documentation>Solver reference node</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
      <element name="solver">
        <a:documentation>Linear solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="vector_potential_algorithm">
    <element name="algorithm">
      <a:documentation>Computes the vector potential A where:
  F = nabla phi + nabla x A + H
with a strong Dirichlet boundary condition of zero on all boundaries.</a:documentation>
      <attribute name="name">
        <value>vector_potential</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
      <element name="solver">
        <a:documentation>Linear solver options.</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </element>
  </define>
  <define name="geostrophic_velocity_algorithm">
    <element name="algorithm">
      <a:documentation>Compute the velocity in geostrophic balance with a pressure field</a:documentation>
      <attribute name="name">
        <value>geostrophic_velocity</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <attribute name="depends">
        <value>Velocity</value>
      </attribute>
      <ref name="scalar_source_field"/>
      <element name="mass">
        <a:documentation>Options relating to the mass matrix</a:documentation>
        <optional>
          <element name="lump_mass">
            <a:documentation>Lump the mass matrix. Required for continuous fields.</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
      </element>
      <optional>
        <element name="integrate_divergence_by_parts">
          <a:documentation>Integrate the divergence operator by parts</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="scale_factor">
          <a:documentation>Scale the computed geostrophic velocity by some factor. This is
useful if the pressure field is divided by some reference value
e.g., in a shallow water with gravity magnitude g, this should
take the value g.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="bulk_viscosity_algorithm">
    <element name="algorithm">
      <a:documentation>The average (or bulk) viscosity formed from the MaterialViscosity for
each material_phase, weighted according to the MaterialVolumeFraction
fields from each material_phase:

  \bar\nu = \alpha^i\nu^i
 
where \bar\nu is the bulk viscosity, \alpha^i is the volume fraction
for material i and \nu^i is the viscosity of material i</a:documentation>
      <attribute name="name">
        <value>bulk_viscosity</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple </value>
      </attribute>
    </element>
  </define>
  <define name="imposed_material_velocity_source_algorithm">
    <element name="algorithm">
      <attribute name="name">
        <value>imposed_material_velocity_source</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple </value>
      </attribute>
      <attribute name="depends">
        <value>VelocityAbsorption</value>
      </attribute>
    </element>
  </define>
  <define name="imposed_material_velocity_absorption_algorithm">
    <element name="algorithm">
      <attribute name="name">
        <value>imposed_material_velocity_absorption</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>multiple </value>
      </attribute>
      <optional>
        <element name="relaxation_factor">
          <a:documentation>Time relaxation factor, defaults to 1 if not selected.</a:documentation>
          <ref name="real_dim_vector"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Parallel diagnostics -->
  <define name="node_halo_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Paints the node halo.</a:documentation>
      <attribute name="name">
        <value>node_halo</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="element_halo_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Paints the element halo. Requires a degree 0 mesh.</a:documentation>
      <attribute name="name">
        <value>element_halo</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <!-- Python diagnostics -->
  <define name="scalar_python_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for the diagnostic value coded in Python. 
The object 'state' has the attributes 'scalar_fields', 'vector_fields'
and 'tensor_fields';
'field' is the diagnostic field to be set</a:documentation>
      <attribute name="name">
        <value>scalar_python_diagnostic</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="python_code"/>
      <optional>
        <element name="depends">
          <a:documentation>Enable to specify dependencies manually</a:documentation>
          <ref name="anystring"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="vector_python_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for the diagnostic value coded in Python. 
The object 'state' has the attributes 'scalar_fields', 'vector_fields'
and 'tensor_fields';
'field' is the diagnostic field to be set</a:documentation>
      <attribute name="name">
        <value>vector_python_diagnostic</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="python_code"/>
      <optional>
        <element name="depends">
          <a:documentation>Enable to specify dependencies manually</a:documentation>
          <ref name="anystring"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="tensor_python_diagnostic_algorithm">
    <element name="algorithm">
      <a:documentation>Algorithm for the diagnostic value coded in Python. 
The object 'state' has the attributes 'scalar_fields', 'vector_fields'
and 'tensor_fields';
'field' is the diagnostic field to be set</a:documentation>
      <attribute name="name">
        <value>tensor_python_diagnostic</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="python_code"/>
      <optional>
        <element name="depends">
          <a:documentation>Enable to specify dependencies manually</a:documentation>
          <ref name="anystring"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Adaptivity diagnostics -->
  <define name="scalar_edge_lengths_algorithm">
    <element name="algorithm">
      <a:documentation>Computes the edge lengths of the Coordinate mesh</a:documentation>
      <attribute name="name">
        <value>scalar_edge_lengths</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
    </element>
  </define>
  <define name="field_tolerance_algorithm">
    <element name="algorithm">
      <a:documentation>From a field on a mesh, diagnose the anisotropic
interpolation weight that would give the mesh back.
It is computed as:
\Eps = M^-1 |H|</a:documentation>
      <attribute name="name">
        <value>field_tolerance</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="component_source_field"/>
      <optional>
        <element name="p_norm">
          <a:documentation>Scale the Hessian to return the L_p norm tolerance, rather than the
default L_inf norm tolerance. See
Chen Sun and Zu, Mathematics of Computation, Volume 76,
Number 257, January 2007, pp. 179-204.</a:documentation>
          <ref name="integer"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="eigenvalues_symmetric_algorithm">
    <element name="algorithm">
      <a:documentation>Computes the eigenvalues of a given symmetric tensor field. The output
eigenvalues are sorted from lowest to highest.</a:documentation>
      <attribute name="name">
        <value>eigenvalues_symmetric</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="tensor_source_field"/>
    </element>
  </define>
  <!-- Misc -->
  <!-- l2norm diagnostic algorithm -->
  <define name="l2norm_algorithm">
    <element name="algorithm">
      <a:documentation>l2norm (source field). Calculates the nodewise l2norm of a vector field.</a:documentation>
      <attribute name="name">
        <value>l2norm</value>
      </attribute>
      <attribute name="material_phase_support">
        <value>single</value>
      </attribute>
      <ref name="vector_source_field"/>
    </element>
  </define>
  <define name="scalar_diagnostic_algorithms">
    <ref name="scalar_python_diagnostic_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_copy_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="extract_scalar_component_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="helmholtz_smoothed_scalar_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_galerkin_projection_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="temporalmax_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="temporalmin_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="div_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="finite_element_divergence_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_advection_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_laplacian_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_potential_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="projection_scalar_potential_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="grad_normal_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="node_halo_diagnostic_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="element_halo_diagnostic_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="l2norm_algorithm"/>
  </define>
  <define name="scalar_diagnostic_algorithms" combine="choice">
    <ref name="scalar_difference_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms">
    <ref name="vector_python_diagnostic_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_copy_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_galerkin_projection_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="grad_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="curl_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_advection_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_laplacian_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_potential_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="geostrophic_velocity_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="eigenvalues_symmetric_algorithm"/>
  </define>
  <define name="vector_diagnostic_algorithms" combine="choice">
    <ref name="vector_difference_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms">
    <ref name="tensor_python_diagnostic_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="tensor_copy_algorithm"/>
  </define>
  <define name="tensor_diagnostic_algorithms" combine="choice">
    <ref name="field_tolerance_algorithm"/>
  </define>
</grammar>
