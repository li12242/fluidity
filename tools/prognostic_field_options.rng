<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="">
  <define name="prognostic_scalar_field">
    <ref name="scalar_equation_choice"/>
    <ref name="spatial_discretisation_options"/>
    <ref name="temporal_discretisation_options"/>
    <choice>
      <element name="solver">
        <a:documentation>Solver</a:documentation>
        <ref name="linear_solver_options_asym"/>
      </element>
      <element name="explicit">
        <a:documentation>Assume this field is being solved explicitly and skip the solver.

ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.

Assumes lhs matrix only has diagonal lumped mass (times
density if appropriate for equation)
and divides the rhs by this.</a:documentation>
        <empty/>
      </element>
    </choice>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <optional>
              <element name="apply_weakly">
                <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin and
control_volume
spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
                <optional>
                  <element name="boundary_overwrites_initial_condition">
                    <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>robin</value>
            </attribute>
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
          <element name="type">
            <a:documentation>Prevent the field from fluxing out of the boundary.
Only applicable to control volume spatial discretisations.</a:documentation>
            <attribute name="name">
              <value>zero_flux</value>
            </attribute>
            <empty/>
          </element>
        </choice>
      </element>
    </zeroOrMore>
    <optional>
      <choice>
        <a:documentation>Choice of subgridscale model to apply to this field. 
Note that the selected parameterisation must be switched 
on for this material phase.

At this time, do not switch on this option if you are using Mellor-Yamada.</a:documentation>
        <element name="subgridscale_parameterisation">
          <attribute name="name">
            <value>Gent_McWilliams</value>
          </attribute>
        </element>
        <element name="subgridscale_parameterisation">
          <attribute name="name">
            <value>GLS</value>
          </attribute>
        </element>
        <element name="subgridscale_parameterisation">
          <attribute name="name">
            <value>prescribed_diffusivity</value>
          </attribute>
        </element>
      </choice>
    </optional>
    <optional>
      <element name="tensor_field">
        <a:documentation>Diffusivity for field</a:documentation>
        <attribute name="name">
          <value>Diffusivity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="replaces">
          <value>TMUXX TMUYY TMUZZ TMUYZ TMUXZ TMUXY TALLMU TCONMU</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_tensor_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <a:documentation>For electrical modelling only - holds electrical conductivity</a:documentation>
            <choice>
              <ref name="tensor_python_diagnostic_algorithm"/>
              <ref name="internal_algorithm"/>
            </choice>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>source term</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>ZSOT</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <a:documentation>This only works for traffic modelling</a:documentation>
            <choice>
              <ref name="scalar_python_diagnostic_algorithm"/>
              <ref name="internal_algorithm"/>
            </choice>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Absorption term</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>TABSZE TABS TABSCO TABSOR</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <choice>
              <ref name="scalar_python_diagnostic_algorithm"/>
              <ref name="internal_algorithm"/>
            </choice>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Velocity at which this substance sinks through the water column.

This velocity is in the direction of gravity so if the substance
floats or swims upwards, this field should be negative.</a:documentation>
        <attribute name="name">
          <value>SinkingVelocity</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <choice>
              <ref name="scalar_python_diagnostic_algorithm"/>
              <ref name="internal_algorithm"/>
            </choice>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
    <optional>
      <element name="profile">
        <empty/>
      </element>
    </optional>
  </define>
  <define name="prognostic_velocity_field">
    <ref name="velocity_equation_choice"/>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>A new version of continuous galerkin assembly.</a:documentation>
          <ref name="advection_stabilisation_options"/>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix - currently required if solving for pressure
and not using the schur complement scheme under Pressure</a:documentation>
                <optional>
                  <element name="use_submesh">
                    <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <optional>
              <element name="exclude_mass_terms">
                <a:documentation>Remove the mass terms from the equation.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms in the velocity equation.</a:documentation>
            <optional>
              <element name="integrate_advection_by_parts">
                <a:documentation>Integrate the advection terms of the momentum equation by parts.
This allows for the imposition of weak boundary conditions.
If activated the element advection matrix takes the form:
   /                                            /
 - | (grad N_A dot nu) N_B rho dV - (1. - beta) | N_A ( div nu ) N_B rho dV
   /                                            /
otherwise it takes the standard form:
   /                                     /
   | N_A (nu dot grad N_B) rho dV + beta | N_A ( div nu ) N_B rho dV
   /                                     /
where beta is set in conservative_advection, N is
a shape function and nu is the relative nonlinear
velocity.</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="exclude_advection_terms">
                <a:documentation>Remove the advection terms (u.grad u rho + beta
div u rho u) from the equation.
This overrides any other advection term options
(including conservative_advection below).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="stress_terms">
            <a:documentation>Discretisation options for the stress terms in the velocity equation.</a:documentation>
            <choice>
              <element name="tensor_form">
                <a:documentation>Use tensor form of the stress terms:

mu u_{i,jj}

This is only valid for incompressible
simulations as it is basically a simplication
of full stress form when divergent elements can
be cancelled out.

Only diaonal components of viscosity
(i.e. either isotropic or
diagonal) are physical for isotropic materials.

If components differ from each other
this must be for numerical reasons (i.e. not
physical variations in viscosity otherwise
simplification is not valid).

If activated, the dim x dim (in this example
3d) discrete stress matrix takes the form:

 /  mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z
 |   0                                             ...
 \   0

     0
 ... mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z   ...
     0

     0                                                           \
 ... 0                                                           |
    mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z   /

which is derived from b_a^T c b_b, where:

 b_a = / N_a,x  \   c = /  mu_xx    0      0    \
       | N_a,y  |       |    0    mu_yy    0    |
       \ N_a,z  /       \    0      0    mu_zz  /

where N_a and N_b are shape functions of the
ath and bth node respectively and mu are the
components of the viscosity tensor.</a:documentation>
                <empty/>
              </element>
              <element name="stress_form">
                <a:documentation>Use full stress form of the stress tensor:

2*mu (u_{(i,j)} - 1/3*\delta_{ij}u_{k,k})

This couples the velocity components together.
It is required if performing a compressible simulation.

If using a viscosity ALL COMPONENTS OF
VISCOSITY MUST BE SET (i.e. either
anisotropic_symmetric or
anisotropic_asymmetric tensors).

If components differ form each other this must
be for numerical reasons (i.e. not physical
variations in viscosity as the material is isotropic).

If activated, the dim x dim (in this example
3d) discrete stress matrix takes the form:

 /   4/3*N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_xy + N_a,z*N_b,z*mu_xz
 |   N_a,x*N_b,y*mu_xy - 2/3*N_a,y*N_b,x*mu_yx                       ...
 \   N_a,x*N_b,z*mu_xz - 2/3*N_a,z*N_b,x*mu_zx

     N_a,y*N_b,x*mu_xy - 2/3*N_a,x*N_b,y*mu_xy
 ... N_a,x*N_b,x*mu_xy + 4/3*N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_yz   ...
     N_a,y*N_b,z*mu_yz - 2/3*N_a,z*N_b,y*mu_zy

     N_a,z*N_b,x*mu_xz - 2/3*N_a,x*N_b,z*mu_xz                       \
 ... N_a,z*N_b,y*mu_yz - 2/3*N_a,y*N_b,z*mu_yz                       |
     N_a,x*N_b,x*mu_xz + N_a,y*N_b,y*mu_yz + 4/3*N_a,z*N_b,z*mu_zz   /

which is derived from b_a^T c b_b, where:

 b_a = / N_a,x   0     0   \   c = /  4/3*mu_xx  -2/3*mu_xy -2/3*mu_xz  0    0    0   \
       |  0    N_a,y   0   |       | -2/3*mu_yx   4/3*mu_yy -2/3*mu_yz  0    0    0   |
       |   0     0   N_a,z |       | -2/3*mu_zx  -2/3*mu_zy  4/3*mu_zz  0    0    0   |
       | N_a,y N_a,x   0   |       |     0           0          0     mu_xy  0    0   |
       | N_a,z   0   N_a,x |       |     0           0          0       0  mu_xz  0   |
       \   0   N_a,z N_a,y /       \     0           0          0       0    0  mu_yz /

where N_a and N_b are shape functions of the ath and bth node respectively and mu are the components of the viscosity tensor.</a:documentation>
                <optional>
                  <element name="legacy_stress_form">
                    <a:documentation>Use the legacy form of the stress tensor.

This differs from the standard method in how the components 
of the viscosity tensor are distributed.

If activated, the dim x dim (in this case
3d) stress matrix takes the form:

 /   4/3*N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_zz
 |   N_a,x*N_b,y*mu_yx - 2/3*N_a,y*N_b,x*mu_yy                     ...
 \   N_a,x*N_b,z*mu_zx - 2/3*N_a,z*N_b,x*mu_zz

     N_a,y*N_b,x*mu_xy - 2/3*N_a,x*N_b,y*mu_xx
 ... N_a,x*N_b,x*mu_xx + 4/3*N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_zz ...
     N_a,y*N_b,z*mu_zy - 2/3*N_a,z*N_b,y*mu_zz

     N_a,z*N_b,x*mu_xz - 2/3*N_a,x*N_b,z*mu_xx                     \
 ... N_a,z*N_b,y*mu_yz - 2/3*N_a,y*N_b,z*mu_yy                     |
     N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_yy + 4/3*N_a,z*N_b,z*mu_zz /

where N_a and N_b are shape functions of
the ath and bth node respectively and mu
are the components of the viscosity tensor.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </choice>
          </element>
          <optional>
            <element name="les_model">
              <a:documentation>large-eddy simulation</a:documentation>
              <element name="smagorinsky_coefficient">
                <a:documentation>literature sybol: Cs

suggested value 0.1</a:documentation>
                <ref name="real"/>
              </element>
              <element name="order">
                <a:documentation>les options</a:documentation>
                <choice>
                  <element name="second_order">
                    <a:documentation>similar to the original Smag model</a:documentation>
                    <empty/>
                  </element>
                  <element name="fourth_order">
                    <a:documentation>this adds a fourth order operator to tackle the
dissipation issues of the original Smag model

use this if your turbulence dissipates faster than it should

requires a fine mesh to perform well</a:documentation>
                    <empty/>
                  </element>
                </choice>
              </element>
            </element>
          </optional>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation. Confusingly it is not necessary to provide
a discontinuous velocity field for this to work!</a:documentation>
          <attribute name="replaces">
            <value>DISOPT</value>
          </attribute>
          <optional>
            <element name="mass_terms">
              <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
              <optional>
                <element name="lump_mass_matrix">
                  <a:documentation>Lump the mass matrix</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="exclude_mass_terms">
                  <a:documentation>Remove the mass terms from the equation.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <element name="viscosity_scheme">
            <choice>
              <element name="bassi_rebay">
                <a:documentation>Classical scheme from Bassi and Rebay 
(JCP 131 267-179 1997)</a:documentation>
                <empty/>
              </element>
              <element name="arbitrary_upwind">
                <a:documentation>Scheme in which upwinding is applied in
alternating directions. Devised by C.Pain.</a:documentation>
                <empty/>
              </element>
              <element name="interior_penalty">
                <a:documentation>Classical interior penalty scheme
see, e.g., SIAM Journal on Numerical Analysis
Vol. 39, No. 5 (2002), pp. 1749-1779 </a:documentation>
                <element name="penalty_parameter">
                  <a:documentation>Penalty_parameter
The penalty term Int [u][v] dS on element boundaries
is scaled by C = C_0 h**p
This option specifies the C_0
There is a theoretical lower bound for 
stability and hence convergence</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="edge_length_power">
                  <a:documentation>Penalty_parameter
The penalty term Int [u][v] dS on element boundaries
is scaled by C = C_0 h**p
This option specifies p
Theoretically p=-1 is required for linear elements</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="edge_length_option">
                  <a:documentation>Option for how to compute the edge length h</a:documentation>
                  <choice>
                    <element name="use_face_integral">
                      <a:documentation>Use face integral (take sqrt in 3D)</a:documentation>
                      <empty/>
                    </element>
                    <element name="use_element_centres">
                      <a:documentation>Use difference between element centre 
and neighbour centre
Use 2x distance to face centre on boundaries</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                </element>
                <optional>
                  <element name="debug">
                    <a:documentation>Switch on debugging output</a:documentation>
                    <element name="gradient_test_bound">
                      <a:documentation>Bound for testing element gradient matrix</a:documentation>
                      <ref name="real"/>
                    </element>
                    <optional>
                      <element name="remove_element_integral">
                        <a:documentation>Remove the elemental integral:
Int grad u.kappa.grad v dV</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_primal_fluxes">
                        <a:documentation>Remove the primal fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_penalty_fluxes">
                        <a:documentation>Remove the penalty fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </choice>
          </element>
          <element name="advection_scheme">
            <choice>
              <element name="upwind">
                <a:documentation>Straightforward upwinding of the nonlinear velocity.</a:documentation>
                <empty/>
              </element>
              <element name="none">
                <a:documentation>Disable advection</a:documentation>
                <empty/>
              </element>
            </choice>
            <element name="integrate_advection_by_parts">
              <a:documentation>Integrate the advection terms of the momentum equation by parts.

Integrating the advection term by parts is
necessary for a discontinuous
galerkin discretisation however it is possible to
select how many times the
integration by parts is performed.
Twice is the norm.</a:documentation>
              <choice>
                <element name="twice">
                  <a:documentation>If activated the element advection matrix takes the form:
   /                                 /
   | N_A (nu dot grad N_B) dV + beta | N_A ( div nu ) N_B dV
   /                                 /
     /                                         /
 + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - 1] | N_A_i (nu dot n) N_B_i ds
     /                                         /
where beta is set in conservative_advection,
N is a shape function (uppercase
subscripts indicate nodes A or B while
lowercase subscripts indicate inner or outer
faces i and o respectively), nu is the
nonlinear velocity and n is the outward
pointing normal from the element.</a:documentation>
                  <empty/>
                </element>
                <element name="once">
                  <a:documentation>If activated the element advection matrix takes the form:
   /                                        /
 - | (grad N_A dot nu) N_B dV - (1. - beta) | N_A ( div nu ) N_B dV
   /                                        /
     /                                   /
 + I | N_A_i (nu dot n) N_B_o ds + (1-I) | N_A_i (nu dot n) N_B_i ds
     /                                   /
where beta is set in conservative_advection,
N is a shape function (uppercase
subscripts indicate nodes A or B while
lowercase subscripts indicate inner or outer
faces i and o respectively), nu is the
nonlinear velocity and n is the outward
pointing normal from the element.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
            <optional>
              <element name="integrate_conservation_term_by_parts">
                <a:documentation>If activated the conservation term:
 /
 | N_A ( div nu ) N_B dV
 /
is integrated_by_parts such that the element
advection matrix becomes:
        /                                        /
 - beta | (grad N_A dot nu) N_B dV + (1. - beta) | N_A (nu dot grad N_B) dV
        /                                        /
     /                                                /
 + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - (1-beta)] | N_A_i (nu dot n) N_B_i ds
     /                                                /                  
where beta is set in conservative_advection, N is
a shape function (uppercase
subscripts indicate nodes A or B while lowercase
subscripts indicate inner or outer
faces i and o respectively), nu is the nonlinear
velocity and n is the outward pointing normal
from the element.
This is invariant regardless of whether the main
advection term is integrated by parts once or
twice.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of momentum equations
 BETA=1. -- conservative (divergence form)
 BETA=0. -- non-conservative
 0. &lt; BETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>BETA</value>
        </attribute>
        <ref name="real"/>
      </element>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <element name="theta">
        <a:documentation>Implicit/explicit control (THETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>THETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <element name="relaxation">
        <a:documentation>Non-linear relaxation term
 =0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
 =1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
 0. &lt; ITHETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>ITHETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <element name="discontinuous_galerkin">
          <optional>
            <element name="advection_cycling">
              <a:documentation>Use timestep subcycling to solve this equation.</a:documentation>
              <element name="number_advection_subcycles">
                <a:documentation>Specify the number of subcycles.</a:documentation>
                <ref name="integer"/>
              </element>
              <optional>
                <element name="coriolis_in_subcycles">
                  <a:documentation>Specify whether coriolis should be included in the 
subcycling.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TMPER1 TMPER2 TMPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="velocity_boundary_conditions"/>
      </element>
    </zeroOrMore>
    <optional>
      <element name="tensor_field">
        <a:documentation>For a Newtonian fluid this is the shear viscosity.

For continuous_galerkin see stress_terms to see how the
viscosity tensor is dealt with in the momentum equation.</a:documentation>
        <attribute name="replaces">
          <value>MUPTXX MUPTYY MUPTZZ MUPTYZ MUPTXZ MUPTXY RMUPXX RMUPYY RMUPZZ RMUPYZ RMUPXZ RMUPXY CONMU ALLMU TWOMU ONEMU</value>
        </attribute>
        <attribute name="name">
          <value>Viscosity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_tensor_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <choice>
              <ref name="internal_algorithm"/>
              <ref name="bulk_viscosity_algorithm"/>
              <ref name="tensor_python_diagnostic_algorithm"/>
            </choice>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Source</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>CONSOX CONSOY CONSOZ RONSOX RONSOY RONSOZ ZSOX ZSOY ZSOZ</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <choice>
              <ref name="vector_python_diagnostic_algorithm"/>
              <ref name="imposed_material_velocity_source_algorithm"/>
              <ref name="internal_velocity_source_algorithm"/>
            </choice>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <optional>
          <element name="lump_source">
            <attribute name="replaces">
              <value>SLUMP</value>
            </attribute>
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Absorption</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>XABSZE YABSZE ZABSZE XABS YABS ZABS XABSOR YABSOR ZABSOR XABSCO YABSCO ZABSCO</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <choice>
              <ref name="vector_python_diagnostic_algorithm"/>
              <ref name="imposed_material_velocity_absorption_algorithm"/>
              <ref name="internal_velocity_absorption_algorithm"/>
            </choice>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <choice>
          <element name="default_absorption">
            <a:documentation>Default absorption: no lumping, is fully evaluated before the
the pressure correction.</a:documentation>
            <attribute name="replaces">
              <value>ABSLUM</value>
            </attribute>
            <empty/>
          </element>
          <element name="lump_absorption">
            <a:documentation>Lump the inclusion of absorbtion terms.</a:documentation>
            <attribute name="replaces">
              <value>ABSLUM</value>
            </attribute>
            <optional>
              <element name="use_submesh">
                <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="include_pressure_correction">
            <a:documentation>Includes the pressure correction to the velocity in the
absorption term (for theta&gt;0). This makes the absorption
term more implicit. The absorption term is lumped if and
only if the mass matrix is lumped (lump_mass_matrix).</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="tensor_field">
        <a:documentation>SurfaceTension</a:documentation>
        <attribute name="name">
          <value>SurfaceTension</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name">
            <value>MaterialVolumeFraction</value>
          </attribute>
          <optional>
            <element name="lump_mass_matrix">
              <a:documentation>Choose whether the mass matrix is lumped or not for the calculation of the gradient</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="solver">
              <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
          </optional>
          <optional>
            <element name="integrate_by_parts">
              <a:documentation>Choose whether the surface tension term in the momentum equation is integrated by parts or not</a:documentation>
              <empty/>
            </element>
          </optional>
          <ref name="diagnostic_tensor_field"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_vector_output_options"/>
    <ref name="prognostic_velocity_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_vector_field"/>
    <ref name="interpolation_algorithm_vector"/>
    <optional>
      <ref name="discrete_properties_algorithm_vector"/>
    </optional>
    <optional>
      <element name="profile">
        <empty/>
      </element>
    </optional>
  </define>
  <define name="scalar_equation_choice">
    <choice>
      <element name="equation">
        <a:documentation>Select the equation used to solve for this field.
Advection Diffusion is the norm for scalar fields.
Works for all discretisation types.</a:documentation>
        <attribute name="name">
          <value>AdvectionDiffusion</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Conservation of Mass equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.</a:documentation>
        <attribute name="name">
          <value>ConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Reduced Conservation of Mass equation - requires the selection of a Density field.

ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.

This equation is very similar to a standard conservation of mass equation
except that the time discretisation uses only a single time level of density.
This enables consistency between the
MaterialVolumeFraction (ReducedConservationOfMass) and
MaterialDensity (Advection) equations in compressible multimaterial simulations.</a:documentation>
        <attribute name="name">
          <value>ReducedConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***

Select the equation used to solve for this field.
Internal Energy equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.
Solve the internal energy equation for this field.
Requires pressure and velocity fields to be present.
Uses a nonconservative time discretisation.</a:documentation>
        <attribute name="name">
          <value>InternalEnergy</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the bulk Density
Clearly this requires a Density field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>Option to solve for electrical potential from
electrokinetic, electrochemical or electrothermal sources </a:documentation>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="velocity_equation_choice">
    <choice>
      <element name="equation">
        <a:documentation>Select the equation used to solve for velocity.
LinearMomentum is the norm and works for all discretisation types.</a:documentation>
        <attribute name="name">
          <value>LinearMomentum</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>Select the equation used to solve for velocity.
Boussinesq only works for continuous_galerkin and discontinuous_galerkin.</a:documentation>
        <attribute name="name">
          <value>Boussinesq</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>Select the equation used to solve for velocity.
Drainage only works for continuous_galerkin and discontinuous_galerkin.</a:documentation>
        <attribute name="name">
          <value>Drainage</value>
        </attribute>
      </element>
    </choice>
  </define>
</grammar>
