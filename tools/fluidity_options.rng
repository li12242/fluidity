<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <include href="spud_base.rng"/>
  <include href="adaptivity_options.rng"/>
  <include href="diagnostic_algorithms.rng"/>
  <include href="input_output.rng"/>
  <include href="solvers.rng"/>
  <include href="stabilisation.rng"/>
  <include href="reduced_model.rng"/>
  <include href="prognostic_field_options.rng"/>
  <include href="prescribed_field_options.rng"/>
  <include href="spatial_discretisation.rng"/>
  <include href="temporal_discretisation.rng"/>
  <start>
    <element name="fluidity_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <ref name="comment"/>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation
name, e.g. [simulation_name]_0.vtu. Non-standard
characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="problem_type">
        <a:documentation>Option problem_type does not change the tree.  It is just used for options checking.</a:documentation>
        <element name="string_value">
          <!--
            Lines is a hint to the gui about the size of the text box.
            It is not an enforced limit on string length.
          -->
          <attribute name="lines">
            <value>1</value>
          </attribute>
          <choice>
            <value>fluids</value>
            <value>oceans</value>
            <value>multimaterial</value>
            <value>porous_media</value>
            <value>stokes</value>
          </choice>
        </element>
        <ref name="comment"/>
      </element>
      <ref name="geometry"/>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Only vtk for now.</a:documentation>
          <element name="string_value">
            <value>vtk</value>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.

Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <attribute name="replaces">
              <value>TIMDUM</value>
            </attribute>
            <ref name="real"/>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.

Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
        <optional>
          <element name="disable_dump_at_start">
            <a:documentation>Disable dump at simulation start</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="disable_dump_at_end">
            <a:documentation>Disable dump at simulation end</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <!-- every CPUDUM seconds write results to disc. -->
          <element name="cpu_dump_period">
            <a:documentation>This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>CPUDUM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_dump_period">
            <a:documentation>The period between dumps in walltime seconds. This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>WTIDUM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="max_dump_file_count">
            <a:documentation>Number of dumps before we overwrite previous dumps.</a:documentation>
            <attribute name="replaces">
              <value>DUMSAV</value>
            </attribute>
            <ref name="integer"/>
          </element>
        </optional>
        <choice>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>CoordinateMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be
interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
        <optional>
          <element name="convergence">
            <a:documentation>Options for convergence analysis.</a:documentation>
            <optional>
              <element name="convergence_file">
                <a:documentation>Whether to enable the creation of a convergence
file, giving details of the convergence of each
field over the global nonlinear iteration loop.
The .convergence file is in the same format as the .stat file.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="convergence_vtus">
                <a:documentation>Write state to a vtu on every iteration.

This is a useful debugging tool if things are not converging.
To prevent an excessive number of files being accumulated previous
timestep files will be overwritten hence it is best to use
in conjunction with /timestepping/nonlinear_iterations/terminate_if_not_converged</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="checkpointing">
            <a:documentation>Whether to enable dumping of checkpointing output.

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options</a:documentation>
            <element name="checkpoint_period_in_dumps">
              <a:documentation>Checkpointing period, in dumps. Non-negative value
required. A value of zero indicates that checkpoints
should be created at every dump. If
/io/max_dumpfile_count is exceeded then earlier
checkpoints may be overwritten.</a:documentation>
              <ref name="integer"/>
            </element>
            <optional>
              <element name="checkpoint_at_start">
                <a:documentation>Enable to checkpoint at simulation start.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="checkpoint_at_end">
                <a:documentation>Enable to force a checkpoint at simulation end.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <element name="stat">
          <a:documentation>Diagnostic output (.stat file) options</a:documentation>
          <optional>
            <element name="output_at_start">
              <a:documentation>Enable to write diagnostic output at simulation start</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="output_before_adapts">
              <a:documentation>Enable to write diagnostic output immediately before mesh adapts</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="output_after_adapts">
              <a:documentation>Enable to write diagnostic output immediately after mesh adapts</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="comment"/>
        </element>
        <optional>
          <element name="detectors">
            <a:documentation>Specification of detectors</a:documentation>
            <zeroOrMore>
              <choice>
                <element name="static_detector">
                  <a:documentation>A single static detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="lagrangian_detector">
                  <a:documentation>A single lagrangian detector</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <choice>
                    <element name="location">
                      <a:documentation>This is the initial location of a detector that moves with the fluid velocity.</a:documentation>
                      <ref name="real_dim_vector"/>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
                <element name="detector_array">
                  <a:documentation>Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.</a:documentation>
                  <attribute name="name">
                    <data type="string"/>
                  </attribute>
                  <element name="number_of_detectors">
                    <a:documentation>The number of detectors prescribed by the python function.</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <choice>
                    <element name="static">
                      <a:documentation>Create fixed detectors.</a:documentation>
                      <empty/>
                    </element>
                    <element name="lagrangian">
                      <a:documentation>Create detectors which move with the fluid velocity.</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                  <choice>
                    <element name="python">
                      <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

The return value must have length number_of_detectors.

*** IMPORTANT NOTE ***

The t argument is for future use only - currently detector locations are only set at simulation start.</a:documentation>
                      <ref name="python_code"/>
                    </element>
                    <element name="from_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                    <element name="from_checkpoint_file">
                      <a:documentation>File containing the detectors positions in binary form</a:documentation>
                      <attribute name="file_name">
                        <data type="string"/>
                      </attribute>
                      <element name="format">
                        <a:documentation>The format of the input file containing field data.</a:documentation>
                        <element name="string_value">
                          <value>binary</value>
                        </element>
                      </element>
                    </element>
                  </choice>
                </element>
              </choice>
            </zeroOrMore>
            <optional>
              <element name="binary_output">
                <a:documentation>Enable to write detector output in binary format</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="log_output">
            <a:documentation>Options to create even more output in the logs:

Note that the main option to control the log output is given on the command line:

-v0  only output error and warnings

-v1  also give "navigational information", to indicate where in the code we currently are

-v2  also give any additional information (mins and maxes of fields, etc.)
</a:documentation>
            <optional>
              <element name="memory_diagnostics">
                <a:documentation>Log all allocates and deallocates done for meshes, fields, sparsities and matrices.

NOTE: Requires -v2</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <attribute name="replaces">
            <value>ACCTIM</value>
          </attribute>
          <ref name="real"/>
          <optional>
            <element name="time_units">
              <a:documentation>The following excerpt from the Udunits
documentation explains the time unit encoding by
example:

The specification:

seconds since 1992-10-8 15:15:42.5 -6:00

indicates seconds since October 8th, 1992 at 3
hours, 15 minutes and 42.5 seconds in the afternoon
in the time zone which is six hours to the west of
Coordinated Universal Time (i.e.  Mountain Daylight
Time). The time zone specification can also be
written without a colon using one or two-digits
(indicating hours) or three or four digits
(indicating hours and minutes).

Time units are particularly required in situations
where the problem (time-varying) boundary conditions
and/ initial conditions are a function of time as
defined by a calendar.  Examples include atmospheric
forcing and climatology. The current time, specified
above, is zero at the reference data/time.</a:documentation>
              <attribute name="date">
                <data type="string"/>
              </attribute>
            </element>
          </optional>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <attribute name="replaces">
            <value>DT</value>
          </attribute>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <attribute name="replaces">
            <value>LTIME</value>
          </attribute>
          <ref name="real"/>
        </element>
        <optional>
          <element name="final_timestep">
            <a:documentation>Timestep after which the simulation should end.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="cpu_time_limit">
            <a:documentation>Maximum CPU time (secs) taken up before
simulation terminates writing results to disc.

Manual suggests 1.E+20</a:documentation>
            <attribute name="replaces">
              <value>CPULIM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_limit">
            <a:documentation>Maximum wall time (secs) taken up before
simulation terminates writing results to disc.

This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>WATIME</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="nonlinear_iterations">
            <a:documentation>maximum number of non-linear iterations.

Manual suggests 2</a:documentation>
            <attribute name="replaces">
              <value>ITINOI</value>
            </attribute>
            <ref name="integer"/>
            <optional>
              <element name="tolerance">
                <a:documentation>tolerance for non-linear iteration.
Manual suggests 1.0E-12</a:documentation>
                <attribute name="replaces">
                  <value>ITIERR</value>
                </attribute>
                <ref name="real"/>
                <choice>
                  <element name="infinity_norm">
                    <a:documentation>Select the norm with which you want the tolerance to be tested.

The infinity norm.</a:documentation>
                    <empty/>
                  </element>
                  <element name="l2_norm">
                    <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm.</a:documentation>
                    <empty/>
                  </element>
                  <element name="cv_l2_norm">
                    <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm evaluated on a control volume mesh.</a:documentation>
                    <empty/>
                  </element>
                </choice>
              </element>
            </optional>
            <optional>
              <element name="terminate_if_not_converged">
                <a:documentation>Terminate the simulation if the number of
nonlinear_iterations is reached
and the tolerance criterion is not met.
This is mostly useful as a debugging option if you
suspect the solution is not converging.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="adaptive_timestep">
            <a:documentation>Vary the timestep according to the courant number.</a:documentation>
            <attribute name="replaces">
              <value>TIMAUT</value>
            </attribute>
            <element name="requested_cfl">
              <a:documentation>The timestep will be adjusted (within the tolerance
and bounds specified) to target this courant
number. Timestep adapts occur at the end of each
timestep and after a mesh adapt.</a:documentation>
              <ref name="real"/>
            </element>
            <ref name="timestep_cfl_number_options"/>
            <optional>
              <element name="minimum_timestep">
                <a:documentation>Minimum time step size.
Manual suggests 0.0</a:documentation>
                <attribute name="replaces">
                  <value>MINDT</value>
                </attribute>
                <optional>
                  <element name="terminate_if_reached">
                    <a:documentation>If enabled, signals model termination if a timestep less
than or equal to the minimum_timestep is requested. The
model will stop at the end of the timestep in order to
allow for the latest output to be written. </a:documentation>
                    <ref name="comment"/>
                  </element>
                </optional>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="maximum_timestep">
                <a:documentation>Maximum time step size.
Manual suggests 1.E+10</a:documentation>
                <attribute name="replaces">
                  <value>MAXDT</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="increase_tolerance">
                <a:documentation>The maximum ratio by which the timestep is allowed
to increase in a timestep adapt. e.g., a value of
1.1 indicates that the timestep may be increased by
at most 10%.</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="at_first_timestep">
                <a:documentation>Specify whether you want to calculate a new timestep
at the first timestep or not.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <!-- Preprocessor legacy: STEDER = 0. is equivalent to inactive. -->
          <element name="steady_state">
            <a:documentation>Activate if you want to terminate the simulation once a
steady state is reached.

Enable/disable fields in this check under each field in
steady_state options.</a:documentation>
            <element name="tolerance">
              <a:documentation>Enter the tolerance to which you want a steady state to be judged.</a:documentation>
              <attribute name="replaces">
                <value>STEDER</value>
              </attribute>
              <ref name="real"/>
              <choice>
                <element name="infinity_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The infinity norm.</a:documentation>
                  <empty/>
                </element>
                <element name="l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm.</a:documentation>
                  <empty/>
                </element>
                <element name="cv_l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm evaluated on a control volume mesh.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
            <optional>
              <element name="acceleration_form">
                <a:documentation>If activated compare the above tolerance to the rate
of change of the fields. Otherwise compare it
directly to the change in the field.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="physical_parameters">
        <a:documentation>The physical parameters</a:documentation>
        <optional>
          <element name="gravity">
            <a:documentation>Set a gravity to be included in the buoyancy term.</a:documentation>
            <element name="magnitude">
              <a:documentation>Acceleration due to gravity. 9.8 m/s^2 on earth.</a:documentation>
              <attribute name="replaces">
                <value>GRAVTY</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="vector_field">
              <a:documentation>The direction of the gravity vector.</a:documentation>
              <attribute name="name">
                <value>GravityDirection</value>
              </attribute>
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="replaces">
                <value>BSOUX BSOUY BSOUZ</value>
              </attribute>
              <element name="prescribed">
                <element name="mesh">
                  <attribute name="name">
                    <value>CoordinateMesh</value>
                  </attribute>
                </element>
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
          </element>
        </optional>
        <optional>
          <element name="coriolis">
            <a:documentation>Options relating to Coriolis force. The rotation vector is
assumed to be in the z-direction:

  F_C = 2 \Omega \hat{k} \times u = f \hat{k} \times u</a:documentation>
            <attribute name="replaces">
              <value>OPTOME</value>
            </attribute>
            <choice>
              <element name="f_plane">
                <a:documentation>f-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f is constant</a:documentation>
                <attribute name="replaces">
                  <value>OPTOME = 0</value>
                </attribute>
                <element name="f">
                  <a:documentation>f-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f is constant</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </element>
              <element name="beta_plane">
                <a:documentation>Beta-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f=f_0+beta . (x,y,z)</a:documentation>
                <attribute name="replaces">
                  <value>OPTOME = 1</value>
                </attribute>
                <element name="f_0">
                  <a:documentation>Beta-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f=f_0+beta . (x,y,z)</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
                <element name="beta">
                  <a:documentation>Beta-plane approximation
This means the Coriolis force looks like:
  f k x u
where k is the z unit vector
   and u the velocity vector
   and f=f_0+beta . (x,y,z)
usually only the y-component of beta is non-zero</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA1 OMEGA2 OMEGA3</value>
                  </attribute>
                  <ref name="real_dim_vector"/>
                </element>
              </element>
              <element name="sine_of_latitude">
                <a:documentation>Full Coriolis parameter:
  f = 2 omega sin (latitude)
where latitude=y/R_earth+latitude_0

Specify omega and R_earth and latitude_0</a:documentation>
                <attribute name="replaces">
                  <value>OPTOME = 2</value>
                </attribute>
                <element name="omega">
                  <a:documentation>Full Coriolis parameter:
  f = 2 omega sin (latitude)
where latitude=y/R_earth+latitude_0</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
                <element name="R_earth">
                  <a:documentation>Full Coriolis parameter:
  f = 2 omega sin (latitude)
where latitude=y/R_earth+latitude_0

Suggested value for R_earth: 6.371e6</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="latitude_0">
                  <a:documentation>Full Coriolis parameter:
  f = 2 omega sin (latitude)
where 
  latitude=y/R_earth+latitude_0
latitude_0 is the latitude of y=0</a:documentation>
                  <ref name="real"/>
                </element>
              </element>
              <element name="on_sphere">
                <a:documentation>Full representation on sphere</a:documentation>
                <element name="omega">
                  <a:documentation>Earth rotation rate

Suggested value: 2 pi / 86400 = 7.27220522e-5</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </element>
              <element name="python_f_plane">
                <a:documentation>As f_plane, but with the value for f set using a python
function. Allows for time varying rotation rate.

Functions should be of the form:

 def val(t):
    # Function code
    return # Return value

where the return value is a float.</a:documentation>
                <ref name="python_code"/>
              </element>
            </choice>
          </element>
        </optional>
      </element>
      <oneOrMore>
        <element name="material_phase">
          <a:documentation>The material or phase options</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <element name="equation_of_state">
              <a:documentation>The equation of state</a:documentation>
              <choice>
                <element name="fluids">
                  <a:documentation>Equations of state for ocean (and simple fluid) applications</a:documentation>
                  <choice>
                    <element name="linear">
                      <a:documentation>Incompressible linear equation of state

(e.g. density=denini*(1.0-dengam*(temperature-temini)+dengam_sal*(salinity-S0)))</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA=0 or 1</value>
                      </attribute>
                      <element name="reference_density">
                        <a:documentation>The reference or background density</a:documentation>
                        <attribute name="replaces">
                          <value>DENINI</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <optional>
                        <element name="temperature_dependency">
                          <a:documentation>Enable to add temperature dependency
to the equation of state.</a:documentation>
                          <attribute name="replaces">
                            <value>BOUSIN, EQNSTA=0</value>
                          </attribute>
                          <element name="reference_temperature">
                            <a:documentation>The reference or background
temperature (actual temperature =
calculated temperature plus this
value).</a:documentation>
                            <attribute name="replaces">
                              <value>TEMINI</value>
                            </attribute>
                            <ref name="real"/>
                          </element>
                          <element name="thermal_expansion_coefficient">
                            <a:documentation>The thermal expansion coefficient</a:documentation>
                            <attribute name="replaces">
                              <value>DENGAM</value>
                            </attribute>
                            <ref name="real"/>
                          </element>
                        </element>
                      </optional>
                      <optional>
                        <element name="salinity_dependency">
                          <a:documentation>Enable to add salinity dependency to
the equation of state.</a:documentation>
                          <attribute name="replaces">
                            <value>BOUSIN, EQNSTA=1</value>
                          </attribute>
                          <element name="reference_salinity">
                            <a:documentation>The reference or background
salinity (actual salinity =
calculated salinity plus this
value).</a:documentation>
                            <attribute name="replaces">
                              <value>S0 if from .dat file?, GAMDE3(1) if from gem</value>
                            </attribute>
                            <ref name="real"/>
                          </element>
                          <element name="saline_contraction_coefficient">
                            <a:documentation>The haline contraction coefficient</a:documentation>
                            <attribute name="replaces">
                              <value>DENGAM_SAL if from .dat file?, GAMDE2(1) if from gem</value>
                            </attribute>
                            <ref name="real"/>
                          </element>
                        </element>
                      </optional>
                      <optional>
                        <element name="subtract_out_hydrostatic_level">
                          <a:documentation>Enable this option to subtract out
the hydrostatic level</a:documentation>
                          <attribute name="replaces">
                            <value>BHOUT</value>
                          </attribute>
                          <empty/>
                        </element>
                      </optional>
                    </element>
                    <element name="ocean_pade_approximation">
                      <a:documentation>2002 McDougall, Jackett, Wright and
Feistel equation of state using Pade
approximation</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 2 or 3</value>
                      </attribute>
                      <optional>
                        <element name="include_depth_below_surface">
                          <attribute name="replaces">
                            <value>EQNSTA = 2 if switched on</value>
                          </attribute>
                          <empty/>
                        </element>
                      </optional>
                    </element>
                  </choice>
                </element>
                <element name="compressible">
                  <a:documentation>Equations of state for compressible applications</a:documentation>
                  <element name="miegrunneisen">
                    <a:documentation>Mie-Grunneisen EoS

Used with compressible simulations</a:documentation>
                    <attribute name="replace">
                      <value>MKCOMP from solidity_inputs.inp</value>
                    </attribute>
                    <optional>
                      <element name="reference_density">
                        <a:documentation>reference uncompressed density

if activated then either Liquid EoS or
full Mie-Grunneisen EoS
 - replaces EOS TYPE = 1 or 3 from
 solidity_imputs.inp -&gt; MATEOS
if not activated then replaces EOS TYPE 2 from
solidity_inputs.inp -&gt; MATEOS</a:documentation>
                        <attribute name="replaces">
                          <value>DENINI for single materials, REFERENCE DENS. from solidity_inputs.inp -&gt; DENINIMAT for multimaterials</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </optional>
                    <optional>
                      <element name="ratio_specific_heats">
                        <a:documentation>Ratio of specific heats at constant
pressure to that at constant volume

Requires an energy field.
If activated then a full Mie-Grunneisen EoS 
 - replaces EOS TYPE = 3 from solidity_imputs.inp -&gt; MATEOS
if not activated then either EOS TYPE 1 or 3
from solidity_inputs.inp -&gt; MATEOS</a:documentation>
                        <attribute name="replaces">
                          <value>DENGAM for single materials, DEN GAM from solidity_inputs.inp -&gt; DENGAMMAT for multimaterials</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </optional>
                    <optional>
                      <element name="bulk_sound_speed_squared">
                        <a:documentation>bulk_sound_speed_squared = isothermal_bulk_modulus/reference_density

if activated then either full or partial Liquid EoS or full
Mie-Grunneisen EoS - replaces EOS TYPE = 1, 2 or 3
from solidity_imputs.inp -&gt; MATEOS</a:documentation>
                        <attribute name="replaces">
                          <value>GASCON for single materials, COMPRESS COEF. from solidity_inputs.inp -&gt; GASCONMAT for multimaterials</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </optional>
                  </element>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="subgridscale_parameterisations">
              <a:documentation>Subgridscale parameterisations</a:documentation>
              <optional>
                <element name="LANS">
                  <a:documentation>Lagrangian-averaged Navier-Stokes equations </a:documentation>
                  <choice>
                    <element name="alpha_isotropic_homogeneous">
                      <a:documentation>smoothing length specified as isotropic homogeneous</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="alpha_anisotropic_homogeneous_cartesian">
                      <ref name="real_dim_symmetric_tensor"/>
                    </element>
                  </choice>
                  <!--
                                  (
                                     element leray {
                                        empty
                                     }|
                                     element LANS_momentum_form {
                                        empty
                                     }|
                                     element LANS_stress_form {
                                        empty
                                     }
                                  )
                  -->
                </element>
              </optional>
              <optional>
                <element name="Gent_McWilliams">
                  <a:documentation>You MUST add the following additional fields for this:
 DistanceToTop
 DistanceToBottom
 DistanceToSideBoundaries
 PerturbationDensity</a:documentation>
                  <element name="isoneutral_diffusivity">
                    <a:documentation>This is the diffusivity along density
surfaces. At the moment the dianeutral
diffusivity is hardcoded to be 10^-7 x
isoneutral_diffusivity.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="GentMcWilliams_diffusivity">
                    <a:documentation>This is the diffusivity that parameterises the
effects of the baroclinic eddies.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="tapering">
                    <a:documentation>The vertical and off-diagonal components of the
Gent-McWilliams diffusivity tensor need to be
tapered to zero near the boundaries of the
domain. A taper should also be applied where the
density slope is large - define "large" by
setting maximum_density_slope below.</a:documentation>
                    <element name="maximum_density_slope">
                      <a:documentation>Where the slope of the density surface is
greater than or equal to the
maximum_density_slope, an exponential taper is
applied to the isoneutral diffusivity and a
linear taper is applied to the GentMcWilliams
diffusivity.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="width_of_exponential_taper_region">
                      <a:documentation>The exponential taper has the form
tanh((S_max-sqrt(S.S))/S_d) where S_mac is the
maximum_density_slope, S is the local slope of
the density surface and S_d is a parameter
that controls the width of the tapering
region.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="first_baroclinic_Rossby_radius">
                      <a:documentation>If the slope of the density surface is less
than the maximum_density_slope but we are
still near the surface, a sine taper is
applies to both the diffusivities - "near" is
defined as d &lt; R1 |S| where d is the distance
to the top, |S| is the slope of the density
surface and R1 is the
first_baroclinic_Rossby_radius.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="constant_for_linear_taper">
                      <a:documentation>Near the bottom and side boundaries the
Gent-McWlliams diffusivity is tapered to zero
by multiplying by c*DistanceToBoundary</a:documentation>
                      <ref name="real"/>
                    </element>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="GLS">
                  <a:documentation>This is the generic length scale (vertical turbulence mixed layer) model, 
based here on Warner et al 2005, Ocean Modelling 8:81-113,
which is itself based on the works of Umlauf and Burchard 2003.

The GLS model encodes four individual turbulence closure models which can be chosen via 'option' below.

You will need to make sure that DistanceToTop and DistanceToBottom fields (under geometry/ocean_boundaries) 
are switched on, as well as PerturbationDensity.</a:documentation>
                  <element name="option">
                    <a:documentation>The base GLS option:
1. k-kl which is a variant of Mellor-Yamada 2.5
2. k-epsilon
3. k-omega
4. 'gen' from Warner et al 2005

The k-epsilon has been extensively tested and is recommended.</a:documentation>
                    <element name="string_value">
                      <choice>
                        <value>k-kl</value>
                        <value>k-epsilon</value>
                        <value>k-omega</value>
                        <value>gen</value>
                      </choice>
                    </element>
                  </element>
                  <element name="stability_function">
                    <a:documentation>The stability function choice:
1. KanthaClayson-94 which corresponds to Kantha and Clayson 1994
2. Galperin-88 which corresponds to Galperin et al 1988
3. Canuto-01-A which corresponds to choice A from Canuto et al 2001
4. Canuto-01-B which corresponds to choice B from Canuto et al 2001

The Two Canuto functions are recommended.</a:documentation>
                    <element name="string_value">
                      <choice>
                        <value>KanthaClayson-94</value>
                        <value>GibsonLaunder-78</value>
                        <value>Canuto-01-A</value>
                        <value>Canuto-01-B</value>
                      </choice>
                    </element>
                  </element>
                  <optional>
                    <element name="calculate_boundaries">
                      <a:documentation>Do you want the boundary conditions to be set automatically?
Make sure the ocean geometry settings are enabled for this option</a:documentation>
                      <element name="string_value">
                        <choice>
                          <value>neumann</value>
                          <value>dirichlet</value>
                        </choice>
                      </element>
                      <optional>
                        <element name="fix_surface_values">
                          <a:documentation>Force the surface values of diffusivity/viscosity to be equal to that if
a Dirichlet condition is used on the two turbulent fields. The two turbulent
fields are not actually altered.
This forms an ill-posed problem, but appears to stabilise some simulations.
Manual suggests that this is OFF unless you're having difficulties.</a:documentation>
                          <empty/>
                        </element>
                      </optional>
                    </element>
                  </optional>
                  <element name="scalar_field">
                    <a:documentation>Turbulent kinetic energy. Make sure that the Diffusivity tensor field in here is set to diagnostic/internal.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSTurbulentKineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                        <element name="minimum_value">
                          <a:documentation>Minimum value of TKE in m2s2. A typical value will be around 1e-6</a:documentation>
                          <ref name="real"/>
                        </element>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Generic second equation used in GLS.  Make sure that the Diffusivity tensor field in here is set to diagnostic/internal.</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSGenericSecondQuantity</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Background viscosity</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSBackgroundViscosity</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="mesh_choice"/>
                      <ref name="prescribed_tensor_field"/>
                    </element>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Background diffusivity</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSBackgroundDiffusivity</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="mesh_choice"/>
                      <ref name="prescribed_tensor_field"/>
                    </element>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Eddy viscosity K_M</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSEddyViscosityKM</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_tensor_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Eddy diffusivity K_H</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>GLSEddyDiffusivityKH</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_tensor_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Length scale (a diagnostic with GLS)</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSLengthScale</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Buoyancy frequency</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSBuoyancyFrequency</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Velocity shear</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVelocityShear</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Shear production P</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSShearProduction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Buoyancy production B</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSBuoyancyProduction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Dissipation epsilon</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSDissipationEpsilon</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Stability function S_M</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSStabilityFunctionSM</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Stability function S_H</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSStabilityFunctionSH</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Source1 - TKE source term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSSource1</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Source2 - Second Quantity source term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSSource2</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Absorption1 - TKE absorption term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSAbsorption1</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Absorption2 - Second Quantity absorption term</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSAbsorption2</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>GLS Wall function</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSWallFunction</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical eddy viscosity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVerticalViscosity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical eddy diffusivity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>GLSVerticalDiffusivity</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="Mellor_Yamada">
                  <element name="scalar_field">
                    <a:documentation>Kinetic Energy</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>KineticEnergy</value>
                    </attribute>
                    <attribute name="replaces">
                      <value>IDENT = 101</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Turbulent Length Scale x Kinetic Energy</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentLengthScalexKineticEnergy</value>
                    </attribute>
                    <attribute name="replaces">
                      <value>IDENT = 102</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical Viscosity</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>VerticalViscosity</value>
                      </attribute>
                      <attribute name="replaces">
                        <value>IDENT = 103</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                  <optional>
                    <element name="scalar_field">
                      <a:documentation>Vertical Diffusivity of Temperature</a:documentation>
                      <attribute name="rank">
                        <value>0</value>
                      </attribute>
                      <attribute name="name">
                        <value>VerticalDiffusivity</value>
                      </attribute>
                      <attribute name="replaces">
                        <value>IDENT = 104</value>
                      </attribute>
                      <choice>
                        <element name="diagnostic">
                          <ref name="internal_algorithm"/>
                          <ref name="velocity_mesh_choice"/>
                          <ref name="diagnostic_scalar_field"/>
                        </element>
                        <element name="aliased">
                          <ref name="generic_aliased_field"/>
                        </element>
                      </choice>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <element name="prescribed_diffusivity">
                  <a:documentation>Trivial case in which the user supplies the diffusivity.</a:documentation>
                  <element name="tensor_field">
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>PrescribedDiffusivity</value>
                    </attribute>
                    <element name="prescribed">
                      <ref name="mesh_choice"/>
                      <ref name="prescribed_tensor_field_no_adapt"/>
                    </element>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="k-epsilon">
                  <a:documentation>[UNDER DEVELOPMENT] Standard k-epsilon model (see Ferziger and Peric(2002) p.295).
Solves 2 additional equations for diffusivity epsilon and turbulent kinetic energy k, in order to close momentum equations.</a:documentation>
                  <element name="scalar_field">
                    <a:documentation>Turbulent kinetic energy (k)</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentKineticEnergy</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Turbulent diffusivity (epsilon)</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>TurbulentDiffusivity</value>
                    </attribute>
                    <choice>
                      <element name="prognostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prognostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="scalar_field">
                    <a:documentation>Length scale (a diagnostic with k-epsilon)</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>LengthScale</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_scalar_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <element name="tensor_field">
                    <a:documentation>Eddy viscosity</a:documentation>
                    <attribute name="rank">
                      <value>2</value>
                    </attribute>
                    <attribute name="name">
                      <value>EddyViscosity</value>
                    </attribute>
                    <choice>
                      <element name="diagnostic">
                        <ref name="internal_algorithm"/>
                        <ref name="velocity_mesh_choice"/>
                        <ref name="diagnostic_tensor_field"/>
                      </element>
                      <element name="aliased">
                        <ref name="generic_aliased_field"/>
                      </element>
                    </choice>
                  </element>
                  <optional>
                    <element name="calculate_boundaries">
                      <a:documentation>Enable this option to use recommended boundary conditions:
k = 0, and eps = nu * (delta^2 k/delta n^2) on walls, where n = wall normal.</a:documentation>
                      <element name="string_value">
                        <choice>
                          <value>neumann</value>
                          <value>dirichlet</value>
                        </choice>
                      </element>
                    </element>
                  </optional>
                  <element name="C_mu">
                    <a:documentation>Eddy-viscosity coefficient: nu_T = density * C_mu * k**2 / epsilon.
Recommended value: 0.09.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="C_eps_1">
                    <a:documentation>Diffusivity production coefficient.
Recommended value: 1.44.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="C_eps_2">
                    <a:documentation>Diffusivity destruction coefficient.
Recommended value: 1.92.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="sigma_k">
                    <a:documentation>Turbulent Schmidt number (eddy viscosity coefficient from k equation).
Recommended value: 1.0.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="sigma_eps">
                    <a:documentation>Turbulent Schmidt number (eddy-viscosity coefficient from epsilon equation).
Recommended value: 1.3.</a:documentation>
                    <ref name="real"/>
                  </element>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Pressure</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="prognostic">
                  <!-- in the future this can be any mesh_choice: -->
                  <element name="mesh">
                    <attribute name="name">
                      <value>PressureMesh</value>
                    </attribute>
                  </element>
                  <ref name="prognostic_pressure_field"/>
                </element>
                <element name="prescribed">
                  <!-- in the future this can be any mesh_choice: -->
                  <element name="mesh">
                    <attribute name="name">
                      <value>PressureMesh</value>
                    </attribute>
                  </element>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Pressure</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Density</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Density</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="diagnostic">
                  <ref name="internal_algorithm"/>
                  <ref name="velocity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="prescribed">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="prognostic">
                  <ref name="pressure_mesh_choice"/>
                  <ref name="prognostic_density_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Density</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <element name="vector_field">
            <a:documentation>Velocity vector and momentum options</a:documentation>
            <attribute name="rank">
              <value>1</value>
            </attribute>
            <attribute name="name">
              <value>Velocity</value>
            </attribute>
            <choice>
              <a:documentation>Field type</a:documentation>
              <element name="prognostic">
                <element name="mesh">
                  <attribute name="name">
                    <value>VelocityMesh</value>
                  </attribute>
                </element>
                <ref name="prognostic_velocity_field"/>
              </element>
              <element name="prescribed">
                <element name="mesh">
                  <attribute name="name">
                    <value>VelocityMesh</value>
                  </attribute>
                </element>
                <ref name="prescribed_vector_field"/>
              </element>
              <element name="aliased">
                <attribute name="material_phase_name">
                  <data type="string"/>
                </attribute>
                <attribute name="field_name">
                  <value>Velocity</value>
                </attribute>
              </element>
            </choice>
          </element>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="tensor_field_choice"/>
          </zeroOrMore>
          <optional>
            <element name="electrical_properties">
              <a:documentation>Parameters required to model spontaneous electrical potentials in porous media.</a:documentation>
              <choice>
                <element name="conductivity">
                  <a:documentation>Specify electrical conductivity of fluid (S/m).
This assumes that salinity and temperature are not used.</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="conductivity_from_salinity">
                  <a:documentation>Calculate conductivity from fluid salinity</a:documentation>
                  <empty/>
                </element>
                <element name="conductivity_from_salinity_and_temperature">
                  <a:documentation>Calculate conductivity from fluid salinity and temperature</a:documentation>
                  <empty/>
                </element>
              </choice>
              <element name="coupling_coefficients">
                <a:documentation>Various coupling coefficients associated with spontaneous potentials.</a:documentation>
                <optional>
                  <element name="scalar_field">
                    <a:documentation>Electrokinetic coupling coefficient (V/Pa).</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>Electrokinetic</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field_no_adapt"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="scalar_python_diagnostic_algorithm"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </choice>
                  </element>
                </optional>
                <optional>
                  <element name="scalar_field">
                    <a:documentation>Thermoelectric coupling coefficient (V/K).</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>Thermoelectric</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field_no_adapt"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="scalar_python_diagnostic_algorithm"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </choice>
                  </element>
                </optional>
                <optional>
                  <element name="scalar_field">
                    <a:documentation>Electrochemical coupling coefficient (V.L/mol).</a:documentation>
                    <attribute name="rank">
                      <value>0</value>
                    </attribute>
                    <attribute name="name">
                      <value>Electrochemical</value>
                    </attribute>
                    <choice>
                      <element name="prescribed">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="prescribed_scalar_field_no_adapt"/>
                      </element>
                      <element name="diagnostic">
                        <ref name="velocity_mesh_choice"/>
                        <ref name="scalar_python_diagnostic_algorithm"/>
                        <ref name="diagnostic_scalar_field_no_adapt"/>
                      </element>
                    </choice>
                  </element>
                </optional>
              </element>
            </element>
          </optional>
          <optional>
            <element name="multiphase_properties">
              <a:documentation>Parameters required to model multiphase flow in porous media</a:documentation>
              <element name="relperm_max">
                <a:documentation>Relative permeability end point relperm_max
in eq: relperm_max*(saturation/porosity)**(-relperm_exponent)
Value between 0 and 1</a:documentation>
                <ref name="real"/>
              </element>
              <element name="relperm_exponent">
                <a:documentation>Relative permeability exponent relperm_exponent
in eq: relperm_max*(saturation/porosity)**(-relperm_exponent)</a:documentation>
                <ref name="real"/>
              </element>
              <optional>
                <element name="immobile_fraction">
                  <a:documentation>Immobile volume of fluid phase</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <ref name="sediment"/>
          </optional>
        </element>
      </oneOrMore>
      <optional>
        <element name="mesh_adaptivity">
          <a:documentation>Mesh adaptivity options</a:documentation>
          <optional>
            <element name="mesh_movement">
              <a:documentation>Options involving mesh movement (Lagrangian, ALE methods)
 Allow a moving mesh.
 Assigns memory for grid velocities
 Amends previous timestep`s mass matrix</a:documentation>
              <attribute name="replaces">
                <value>MVMESH = TRUE, ZERQG, CMCHAN = TRUE</value>
              </attribute>
              <choice>
                <element name="free_surface">
                  <a:documentation>enable movement of mesh with the free surface</a:documentation>
                  <choice>
                    <element name="move_surface_nodes">
                      <a:documentation>Only move the nodes on the free surface using
the surface height calculated at it.</a:documentation>
                      <empty/>
                    </element>
                    <element name="move_whole_mesh">
                      <a:documentation>Move the whole mesh according to the free surface
height, scaled linearly by the depth from the surface.

Requires the specification of ocean_boundaries under
geometry.</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                </element>
                <element name="imposed_grid_velocity">
                  <a:documentation>Enable movement of mesh by an imposed Grid Velocity.
Requires a prescribed GridVelocity field (see below).</a:documentation>
                  <empty/>
                </element>
                <element name="explicit_ale">
                  <a:documentation>enable full ale movement of mesh</a:documentation>
                  <element name="number_of_linesearch_pts">
                    <ref name="integer"/>
                  </element>
                  <element name="maximum_iterations">
                    <ref name="integer"/>
                  </element>
                  <element name="max_elements_second_level">
                    <ref name="integer"/>
                  </element>
                  <element name="functional1_weight">
                    <ref name="real"/>
                  </element>
                  <element name="functional2_weight">
                    <ref name="real"/>
                  </element>
                  <element name="functional3_weight">
                    <ref name="real"/>
                  </element>
                  <element name="functional4_weight">
                    <ref name="real"/>
                  </element>
                  <element name="functional5_weight">
                    <ref name="real"/>
                  </element>
                  <element name="minimum_val_functional_change">
                    <ref name="real"/>
                  </element>
                  <element name="minimum_val_functional">
                    <ref name="real"/>
                  </element>
                  <element name="coarse_tolerance">
                    <ref name="real"/>
                  </element>
                  <element name="fine_tolerance">
                    <ref name="real"/>
                  </element>
                  <element name="gradient_dx">
                    <ref name="real"/>
                  </element>
                  <element name="gradient_dy">
                    <ref name="real"/>
                  </element>
                  <element name="gradient_dz">
                    <ref name="real"/>
                  </element>
                  <optional>
                    <element name="move_nodes_in_x">
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="move_nodes_in_y">
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="move_nodes_in_z">
                      <empty/>
                    </element>
                  </optional>
                </element>
                <element name="vertical_ale">
                  <a:documentation>enable vertical movement of mesh (TBD)</a:documentation>
                  <attribute name="replaces">
                    <value>NCOLOP &lt; 0 </value>
                  </attribute>
                  <group>
                    <element name="physical_functionals">
                      <a:documentation>Functionals</a:documentation>
                      <choice>
                        <element name="minimise_relative_velocity_dot_grad_density">
                          <a:documentation>move the nodes along an isosurface
Please specify a scalar field</a:documentation>
                          <attribute name="replaces">
                            <value>NCOLOP = -1</value>
                          </attribute>
                          <attribute name="name">
                            <data type="string"/>
                          </attribute>
                        </element>
                        <element name="use_hessian_density">
                          <a:documentation>Lock a node to a high curvature region, 
Please specify a scalar field</a:documentation>
                          <attribute name="replaces">
                            <value>NCOLOP = -2</value>
                          </attribute>
                          <attribute name="name">
                            <data type="string"/>
                          </attribute>
                        </element>
                      </choice>
                    </element>
                    <optional>
                      <element name="mesh_quality_terms">
                        <a:documentation>Mesh Quality terms</a:documentation>
                        <optional>
                          <element name="spring_term">
                            <a:documentation>Spring term, default value is 1.0</a:documentation>
                            <ref name="real"/>
                          </element>
                        </optional>
                        <optional>
                          <element name="exponential_term">
                            <a:documentation>Exponential term, default value is 1.0</a:documentation>
                            <ref name="real"/>
                          </element>
                        </optional>
                      </element>
                    </optional>
                    <optional>
                      <element name="block_nodes_in_x">
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="block_nodes_in_y">
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="block_nodes_in_z">
                        <empty/>
                      </element>
                    </optional>
                  </group>
                </element>
              </choice>
              <element name="vector_field">
                <a:documentation>The velocity of the mesh.</a:documentation>
                <attribute name="name">
                  <value>GridVelocity</value>
                </attribute>
                <attribute name="rank">
                  <value>1</value>
                </attribute>
                <choice>
                  <element name="diagnostic">
                    <ref name="internal_algorithm"/>
                    <element name="mesh">
                      <attribute name="name">
                        <value>CoordinateMesh</value>
                      </attribute>
                    </element>
                    <ref name="diagnostic_vector_field"/>
                  </element>
                  <element name="prescribed">
                    <element name="mesh">
                      <attribute name="name">
                        <value>CoordinateMesh</value>
                      </attribute>
                    </element>
                    <ref name="prescribed_vector_field_no_adapt"/>
                  </element>
                </choice>
              </element>
            </element>
          </optional>
          <optional>
            <choice>
              <ref name="hr_adaptivity"/>
              <ref name="prescribed_adaptivity"/>
            </choice>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="imported_solids">
          <a:documentation>Information needed are a set of coordinates and 
radius for each particle.</a:documentation>
          <choice>
            <element name="solid_type">
              <attribute name="name">
                <value>cylinders</value>
              </attribute>
              <element name="cylinder_width">
                <ref name="real"/>
              </element>
            </element>
            <element name="solid_type">
              <attribute name="name">
                <value>spheres</value>
              </attribute>
            </element>
            <element name="solid_type">
              <attribute name="name">
                <value>small_spheres</value>
              </attribute>
            </element>
            <element name="solid_type">
              <attribute name="name">
                <value>external_2D_mesh</value>
              </attribute>
              <choice>
                <element name="mapping_type">
                  <attribute name="name">
                    <value>brute_force</value>
                  </attribute>
                  <empty/>
                </element>
                <element name="mapping_type">
                  <attribute name="name">
                    <value>fastest_n_to_n</value>
                  </attribute>
                  <element name="max_number_of_bins_x">
                    <a:documentation>As a rule of thumb, (Xmax-Xmin)/(number of bins_x) should be
greater than (at least twice) the maximum element size
of the fluid mesh (in the region where the particle is).
Same thing applies in Y and Z
directions. Note that in some cases,
choosing the maximum element size for the
whole fluid mesh
might prove to slow down the mapping a
bit.(bins might not have the
optimal size)</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <element name="max_number_of_bins_y">
                    <ref name="integer"/>
                  </element>
                  <element name="max_number_of_bins_z">
                    <ref name="integer"/>
                  </element>
                  <element name="ntry">
                    <ref name="integer"/>
                  </element>
                </element>
              </choice>
              <element name="volume_checking_tol">
                <ref name="real"/>
              </element>
            </element>
            <element name="solid_type">
              <attribute name="name">
                <value>external_3D_mesh</value>
              </attribute>
              <choice>
                <element name="mapping_type">
                  <attribute name="name">
                    <value>brute_force</value>
                  </attribute>
                  <empty/>
                </element>
                <element name="mapping_type">
                  <attribute name="name">
                    <value>fastest_n_to_n</value>
                  </attribute>
                  <element name="max_number_of_bins_x">
                    <a:documentation>As a rule of thumb, (Xmax-Xmin)/(number of bins_x) should be
greater than (at least twice) the maximum element size
of the fluid mesh (in the region where the particle is).
Same thing applies in Y and Z
directions. Note that in some cases,
choosing the maximum element size for the whole fluid mesh 
might prove to slow down the mapping a
bit.(bins might not have the
optimal size)</a:documentation>
                    <ref name="integer"/>
                  </element>
                  <element name="max_number_of_bins_y">
                    <ref name="integer"/>
                  </element>
                  <element name="max_number_of_bins_z">
                    <ref name="integer"/>
                  </element>
                  <element name="ntry">
                    <ref name="integer"/>
                  </element>
                </element>
              </choice>
              <element name="volume_checking_tol">
                <ref name="real"/>
              </element>
            </element>
          </choice>
          <ref name="input_solid_dynamics_choice"/>
          <element name="number_of_particles">
            <ref name="integer"/>
          </element>
          <optional>
            <element name="position_script">
              <ref name="python_code"/>
            </element>
          </optional>
          <optional>
            <element name="radius_script">
              <ref name="python_code"/>
            </element>
          </optional>
          <optional>
            <element name="translation_velocity_script">
              <ref name="python_code"/>
            </element>
          </optional>
          <optional>
            <element name="angular_velocity_script">
              <ref name="python_code"/>
            </element>
          </optional>
          <optional>
            <element name="buoyancy">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="oneway">
              <empty/>
            </element>
          </optional>
          <element name="solid_concentration_max">
            <ref name="real"/>
          </element>
          <element name="solid_absorption_factor">
            <ref name="real"/>
          </element>
          <element name="solid_density">
            <ref name="real"/>
          </element>
          <optional>
            <element name="use_multimaterials">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="calculate_total_volume">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="create_buffer">
              <element name="buffer">
                <ref name="real"/>
              </element>
              <element name="solid_concentration_min">
                <ref name="real"/>
              </element>
              <optional>
                <element name="include_in_drag">
                  <empty/>
                </element>
              </optional>
              <element name="profile1">
                <ref name="real"/>
              </element>
              <element name="profile2">
                <ref name="real"/>
              </element>
              <element name="profile3">
                <ref name="real"/>
                <element name="constant_profile">
                  <ref name="real"/>
                </element>
              </element>
            </element>
          </optional>
          <optional>
            <element name="visualize_solidfluid">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="use_particle_cfl">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="calculate_drag">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="output_drag">
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="output_particle_vtus">
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="traffic_model">
          <a:documentation>traffic model</a:documentation>
          <element name="number_of_vehicles">
            <a:documentation>number of vehicles to be modelled</a:documentation>
            <ref name="integer"/>
          </element>
          <element name="vehicle_activity_file">
            <a:documentation>specify the traffic model input file</a:documentation>
            <attribute name="file_name">
              <data type="string"/>
            </attribute>
          </element>
          <element name="traffic_model_time_lag">
            <a:documentation>traffic_model_time_lag

traffic_time=traffic_time+lag</a:documentation>
            <ref name="real"/>
          </element>
          <element name="scale">
            <a:documentation>scaling factors between fluidity, traffic and wind tunnel models</a:documentation>
            <element name="model_scale">
              <a:documentation>between fluidity and field
usually between 1:150 and 1:200</a:documentation>
              <ref name="real"/>
            </element>
            <element name="reference_velocity_field">
              <a:documentation>usually  2.5 - 3.0 m/s</a:documentation>
              <ref name="real"/>
            </element>
            <element name="reference_velocity_model">
              <a:documentation>normalized should be 1. m/s 
otherwise use the maximum inflow velocity</a:documentation>
              <ref name="real"/>
            </element>
            <element name="road_network_scale">
              <a:documentation>usually in field scale
check specific road network</a:documentation>
              <ref name="real"/>
            </element>
            <element name="vehicle_scale">
              <a:documentation>between fluidity and field
usually between 1:150 and 1:200</a:documentation>
              <ref name="real"/>
            </element>
            <element name="exhaust_diameter">
              <a:documentation>in metres</a:documentation>
              <ref name="real"/>
            </element>
          </element>
          <optional>
            <element name="bounding_box">
              <a:documentation>bounding box for traffic network

ignore vehicles outside this box </a:documentation>
              <element name="x_min">
                <ref name="real"/>
              </element>
              <element name="x_max">
                <ref name="real"/>
              </element>
              <element name="y_min">
                <ref name="real"/>
              </element>
              <element name="y_max">
                <ref name="real"/>
              </element>
            </element>
          </optional>
          <optional>
            <element name="sloping_floor">
              <a:documentation>if the bottom of the domain is not flat
this makes sure the vehicles will follow the 
road gradient
you need to specify the boundary id of the road</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
          <optional>
            <element name="emissions_factors">
              <a:documentation>tailpipe emissions</a:documentation>
              <choice>
                <element name="type">
                  <a:documentation>use a constant emissions factor</a:documentation>
                  <attribute name="name">
                    <value>constant_emissions_factors</value>
                  </attribute>
                  <element name="emissions_factor">
                    <ref name="real"/>
                  </element>
                </element>
                <element name="type">
                  <a:documentation>use the TRL instantaneous emissions model (IEDB)
this is not open source and therefore the database
needs to be read in</a:documentation>
                  <attribute name="name">
                    <value>modelled_emissions_factors</value>
                  </attribute>
                  <optional>
                    <element name="passenger_vehicle_petrol">
                      <data type="string"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="passenger_vehicle_diesel">
                      <data type="string"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="large_vehicle">
                      <data type="string"/>
                    </element>
                  </optional>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>options for the solution of the tailpipe tracer releases
if the emissions factors are not specified
it will use a constant emissions factor</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>TrafficTracerTemplate</value>
              </attribute>
              <element name="prognostic">
                <a:documentation>Field type</a:documentation>
                <ref name="velocity_mesh_choice"/>
                <ref name="prognostic_scalar_field"/>
              </element>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <ref name="biology"/>
      </optional>
      <optional>
        <ref name="forcing"/>
      </optional>
      <optional>
        <ref name="reduced_model"/>
      </optional>
      <optional>
        <element name="porous_media">
          <a:documentation>Porous Media</a:documentation>
          <element name="scalar_field">
            <a:documentation>Specify scalar field Porosity</a:documentation>
            <attribute name="name">
              <value>Porosity</value>
            </attribute>
            <element name="prescribed">
              <ref name="velocity_mesh_choice"/>
              <ref name="prescribed_scalar_field"/>
            </element>
          </element>
          <choice>
            <a:documentation>Specify field Permeability</a:documentation>
            <element name="scalar_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
            </element>
            <element name="vector_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_vector_field"/>
              </element>
            </element>
            <element name="tensor_field">
              <attribute name="name">
                <value>Permeability</value>
              </attribute>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_tensor_field"/>
              </element>
            </element>
          </choice>
          <optional>
            <element name="scalar_field">
              <a:documentation>Specify scalar field Electrical Conductivity</a:documentation>
              <attribute name="name">
                <value>ElectricalConductivity</value>
              </attribute>
              <element name="diagnostic">
                <ref name="velocity_mesh_choice"/>
                <choice>
                  <ref name="internal_algorithm"/>
                  <ref name="scalar_python_diagnostic_algorithm"/>
                </choice>
                <ref name="diagnostic_scalar_field_no_adapt"/>
              </element>
            </element>
          </optional>
          <optional>
            <element name="multiphase_parameters">
              <optional>
                <element name="cp_A">
                  <a:documentation>Capillary pressure multiplier cp_A
in eq: cp_A*((Phase1_saturation+0.00001)**(-cp_expo))</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="cp_expo">
                  <a:documentation>Capillary pressure exponent cp_expo
in eq: cp_A*((Phase1_saturation+0.00001)**(-cp_expo))</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </start>
  <define name="sediment">
    <element name="sediment">
      <a:documentation>A simple sediment model in which different classes of sediment fall 
and diffuse at different rates.</a:documentation>
      <element name="scalar_field">
        <a:documentation>This field is the basis for all sediment fields. Each
sediment class has a sediment field with name
SedimentClassName where ClassName is the name of the
class.

By default, all sediment classes have exactly the same
characteristics, however each class can be given its own
settling velocity, diffusivity and initial condition under
the sediment_class element and this will override the
default specified here.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SedimentTemplate</value>
        </attribute>
        <element name="prognostic">
          <a:documentation>Field type</a:documentation>
          <ref name="velocity_mesh_choice"/>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>This field is the template for the sediment flux
diagnostic which records the flux of sediment through the
domain boundary.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SedimentFluxTemplate</value>
        </attribute>
        <element name="diagnostic">
          <a:documentation>Field type</a:documentation>
          <element name="surface_ids">
            <a:documentation>Surface ids over which to calculate the flux:</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <oneOrMore>
        <element name="sediment_class">
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <zeroOrMore>
            <ref name="initial_condition_scalar"/>
          </zeroOrMore>
          <optional>
            <element name="tensor_field">
              <a:documentation>Diffusivity for sediment class</a:documentation>
              <attribute name="name">
                <value>Diffusivity</value>
              </attribute>
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="replaces">
                <value>TMUXX TMUYY TMUZZ TMUYZ TMUXZ TMUXY TALLMU TCONMU</value>
              </attribute>
              <choice>
                <element name="prescribed">
                  <optional>
                    <ref name="mesh_choice"/>
                  </optional>
                  <ref name="prescribed_tensor_field_no_adapt"/>
                </element>
                <element name="diagnostic">
                  <ref name="tensor_python_diagnostic_algorithm"/>
                  <ref name="diagnostic_tensor_field"/>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Velocity at which this sediment sinks through the water column.

This velocity is in the direction of gravity so if the substance
floats upwards, this field should be negative.</a:documentation>
              <attribute name="name">
                <value>SinkingVelocity</value>
              </attribute>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_scalar_field_no_adapt"/>
              </element>
            </element>
          </optional>
          <element name="density">
            <a:documentation>This is the density of this sediment. It will be used
with the sediment concentration in the equation of state.</a:documentation>
            <ref name="real"/>
          </element>
        </element>
      </oneOrMore>
    </element>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real">
    <ref name="input_choice_real_contents"/>
  </define>
  <define name="input_choice_real_plus_boundary_forcing">
    <choice>
      <ref name="input_choice_real_contents"/>
      <element name="from_file">
        <oneOrMore>
          <element name="tidal">
            <attribute name="file_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="variable_name_amplitude">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="variable_name_phase">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="name">
              <a:documentation>See E.W. Schwiderski - Rev. Geophys. Space
Phys. Vol. 18 No. 1 pp. 243--268, 1980
for details of these constituent.</a:documentation>
              <choice>
                <value>M2</value>
                <value>S2</value>
                <value>N2</value>
                <value>K2</value>
                <value>K1</value>
                <value>O1</value>
                <value>P1</value>
                <value>Q1</value>
                <value>Mf</value>
                <value>Mm</value>
                <value>Ssa</value>
              </choice>
            </attribute>
          </element>
        </oneOrMore>
      </element>
      <element name="NEMO_data">
        <a:documentation>Set the boundary free-surface height from NEMO data.
A prescribed NEMO pressure scalar field must be set to use this option.
Set the name of the prescribed NEMO pressure scalar field below.</a:documentation>
        <attribute name="field_name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_plus_file">
    <choice>
      <ref name="input_choice_real_contents"/>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).

THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
      <element name="NEMO_data">
        <a:documentation>Initialize the field from NEMO data. Note that a file path
under '/ocean_forcing/external_data_boundary_conditions' must
be set to use this option.</a:documentation>
        <element name="format">
          <element name="string_value">
            <choice>
              <value>Temperature</value>
              <value>Salinity</value>
              <value>Free-surface height</value>
            </choice>
          </element>
        </element>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_contents">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="generic_function">
        <a:documentation>Generic function prescribing real input</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="initial_condition_scalar">
    <choice>
      <element name="initial_condition">
        <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
        <attribute name="name">
          <value>WholeMesh</value>
        </attribute>
        <ref name="input_choice_initial_condition_real"/>
      </element>
      <element name="initial_condition">
        <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <ref name="region_ids"/>
        <ref name="input_choice_initial_condition_real"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_real">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="generic_function">
        <a:documentation>Generic function prescribing real input</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended
primarily for use in checkpointing). The file mesh must match
the mesh of this field  (except for piecewise constant fields 
which will be remapped back from the discontinuous nodal values). 
In parallel the process number is
appended to the filename, e.g. if the file_name attribute is
set to "input.vtu", process 0 reads from "input-0.vtu".</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <choice>
          <ref name="vtu_input_format"/>
          <ref name="netcdf_input_format"/>
        </choice>
        <ref name="comment"/>
      </element>
      <element name="NEMO_data">
        <a:documentation>Initialize the field from NEMO data. Note that a file path
under '/ocean_forcing/external_data_boundary_conditions' must
be set to use this option.</a:documentation>
        <element name="format">
          <element name="string_value">
            <choice>
              <value>Temperature</value>
              <value>Salinity</value>
              <value>Free-surface height</value>
            </choice>
          </element>
        </element>
      </element>
    </choice>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real_dim_vector">
    <ref name="input_choice_real_dim_vector_contents"/>
  </define>
  <!-- Choice of input method, e.g. for prescribed fields -->
  <define name="input_choice_real_dim_vector_plus_file">
    <choice>
      <ref name="input_choice_real_dim_vector_contents"/>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).

THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
      <element name="NEMO_data">
        <a:documentation>Initialize the field from NEMO data. Note that a file path
under '/ocean_forcing/external_data_boundary_conditions' must
be set to use this option.</a:documentation>
        <element name="format">
          <a:documentation>Currently, only the velocity vector field may be initialised in this manner.</a:documentation>
          <element name="string_value">
            <value>Velocity</value>
          </element>
        </element>
      </element>
    </choice>
  </define>
  <define name="input_choice_real_dim_vector_contents">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method, e.g. for boundary conditions
    this one specifies a vector field of dim minus one
  -->
  <define name="input_choice_real_dim_minus_one_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_minus_one_vector"/>
      </element>
      <!--
        ## Generic function prescribing dimensional vector input
        element generic_function {
           anystring
        }|
      -->
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="input_choice_netcdf">
    <a:documentation>Import data from NetCDF CF-1.x file.</a:documentation>
    <element name="from_file">
      <attribute name="file_name">
        <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
        <data type="string"/>
      </attribute>
      <ref name="comment"/>
    </element>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <!--
        ## Generic function prescribing dimensional vector input
        element generic_function {
           anystring
        }|
      -->
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

 def val(X, t):
    # Function code
    return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="vtu_input_format"/>
        <ref name="comment"/>
      </element>
      <element name="NEMO_data">
        <a:documentation>Initialize the field from NEMO data. Note that a file path
under '/ocean_forcing/external_data_boundary_conditions' must
be set to use this option.</a:documentation>
        <element name="format">
          <a:documentation>Currently, only the velocity vector field may be initialised in this manner.</a:documentation>
          <element name="string_value">
            <value>Velocity</value>
          </element>
        </element>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real symmetric tensor
  -->
  <define name="input_choice_real_dim_symmetric_tensor">
    <choice>
      <element name="constant">
        <a:documentation>Constant symmetric tensor</a:documentation>
        <ref name="real_dim_symmetric_tensor"/>
      </element>
      <!--
             ## Generic function prescribing symmetric tensor input
             element generic_function {
                anystring
             }|
      -->
      <element name="python">
        <a:documentation>Python command prescribing symmetric tensor input.

Note that it is for the python function to determine 
that the results it produces are, in fact, symmetric.

An example that returns the three-dimensional identity:

 def val(X, t):
   return [[1, 0, 0],
               [0, 1, 0],
               [0, 0, 1]]</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real tensor
  -->
  <define name="input_choice_real_dim_tensor">
    <choice>
      <element name="constant">
        <a:documentation>Constant tensor</a:documentation>
        <ref name="real_dim_tensor"/>
      </element>
      <!--
             }|
             ## Generic function prescribing tensor input
             element generic_function {
                anystring
             }|
      -->
      <element name="python">
        <a:documentation>Python command prescribing tensor input.

An example that returns the three-dimensional identity:

 def val(X, t):
   return [[1, 0, 0],
               [0, 1, 0],
               [0, 0, 1]]</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <define name="prognostic_velocity_field">
    <ref name="velocity_equation_choice"/>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>A new version of continuous galerkin assembly.</a:documentation>
          <ref name="advection_stabilisation_options"/>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix - currently required if solving for pressure
and not using the schur complement scheme under Pressure</a:documentation>
                <optional>
                  <element name="use_submesh">
                    <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <optional>
              <element name="exclude_mass_terms">
                <a:documentation>Remove the mass terms from the equation.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms in the velocity equation.</a:documentation>
            <optional>
              <element name="integrate_advection_by_parts">
                <a:documentation>Integrate the advection terms of the momentum equation by parts.
This allows for the imposition of weak boundary conditions.
If activated the element advection matrix takes the form:
   /                                            /
 - | (grad N_A dot nu) N_B rho dV - (1. - beta) | N_A ( div nu ) N_B rho dV
   /                                            /
otherwise it takes the standard form:
   /                                     /
   | N_A (nu dot grad N_B) rho dV + beta | N_A ( div nu ) N_B rho dV
   /                                     /
where beta is set in conservative_advection, N is
a shape function and nu is the relative nonlinear
velocity.</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="exclude_advection_terms">
                <a:documentation>Remove the advection terms (u.grad u rho + beta
div u rho u) from the equation.
This overrides any other advection term options
(including conservative_advection below).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="stress_terms">
            <a:documentation>Discretisation options for the stress terms in the velocity equation.</a:documentation>
            <choice>
              <element name="tensor_form">
                <a:documentation>Use tensor form of the stress terms:

mu u_{i,jj}

This is only valid for incompressible
simulations as it is basically a simplication
of full stress form when divergent elements can
be cancelled out.

Only diaonal components of viscosity
(i.e. either isotropic or
diagonal) are physical for isotropic materials.

If components differ from each other
this must be for numerical reasons (i.e. not
physical variations in viscosity otherwise
simplification is not valid).

If activated, the dim x dim (in this example
3d) discrete stress matrix takes the form:

 /  mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z
 |   0                                             ...
 \   0

     0
 ... mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z   ...
     0

     0                                                           \
 ... 0                                                           |
    mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z   /

which is derived from b_a^T c b_b, where:

 b_a = / N_a,x  \   c = /  mu_xx    0      0    \
       | N_a,y  |       |    0    mu_yy    0    |
       \ N_a,z  /       \    0      0    mu_zz  /

where N_a and N_b are shape functions of the
ath and bth node respectively and mu are the
components of the viscosity tensor.</a:documentation>
                <empty/>
              </element>
              <element name="stress_form">
                <a:documentation>Use full stress form of the stress tensor:

2*mu (u_{(i,j)} - 1/3*\delta_{ij}u_{k,k})

This couples the velocity components together.
It is required if performing a compressible simulation.

If using a viscosity ALL COMPONENTS OF
VISCOSITY MUST BE SET (i.e. either
anisotropic_symmetric or
anisotropic_asymmetric tensors).

If components differ form each other this must
be for numerical reasons (i.e. not physical
variations in viscosity as the material is isotropic).

If activated, the dim x dim (in this example
3d) discrete stress matrix takes the form:

 /   4/3*N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_xy + N_a,z*N_b,z*mu_xz
 |   N_a,x*N_b,y*mu_xy - 2/3*N_a,y*N_b,x*mu_yx                       ...
 \   N_a,x*N_b,z*mu_xz - 2/3*N_a,z*N_b,x*mu_zx

     N_a,y*N_b,x*mu_xy - 2/3*N_a,x*N_b,y*mu_xy
 ... N_a,x*N_b,x*mu_xy + 4/3*N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_yz   ...
     N_a,y*N_b,z*mu_yz - 2/3*N_a,z*N_b,y*mu_zy

     N_a,z*N_b,x*mu_xz - 2/3*N_a,x*N_b,z*mu_xz                       \
 ... N_a,z*N_b,y*mu_yz - 2/3*N_a,y*N_b,z*mu_yz                       |
     N_a,x*N_b,x*mu_xz + N_a,y*N_b,y*mu_yz + 4/3*N_a,z*N_b,z*mu_zz   /

which is derived from b_a^T c b_b, where:

 b_a = / N_a,x   0     0   \   c = /  4/3*mu_xx  -2/3*mu_xy -2/3*mu_xz  0    0    0   \
       |  0    N_a,y   0   |       | -2/3*mu_yx   4/3*mu_yy -2/3*mu_yz  0    0    0   |
       |   0     0   N_a,z |       | -2/3*mu_zx  -2/3*mu_zy  4/3*mu_zz  0    0    0   |
       | N_a,y N_a,x   0   |       |     0           0          0     mu_xy  0    0   |
       | N_a,z   0   N_a,x |       |     0           0          0       0  mu_xz  0   |
       \   0   N_a,z N_a,y /       \     0           0          0       0    0  mu_yz /

where N_a and N_b are shape functions of the ath and bth node respectively and mu are the components of the viscosity tensor.</a:documentation>
                <optional>
                  <element name="legacy_stress_form">
                    <a:documentation>Use the legacy form of the stress tensor.

This differs from the standard method in how the components 
of the viscosity tensor are distributed.

If activated, the dim x dim (in this case
3d) stress matrix takes the form:

 /   4/3*N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_zz
 |   N_a,x*N_b,y*mu_yx - 2/3*N_a,y*N_b,x*mu_yy                     ...
 \   N_a,x*N_b,z*mu_zx - 2/3*N_a,z*N_b,x*mu_zz

     N_a,y*N_b,x*mu_xy - 2/3*N_a,x*N_b,y*mu_xx
 ... N_a,x*N_b,x*mu_xx + 4/3*N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_zz ...
     N_a,y*N_b,z*mu_zy - 2/3*N_a,z*N_b,y*mu_zz

     N_a,z*N_b,x*mu_xz - 2/3*N_a,x*N_b,z*mu_xx                     \
 ... N_a,z*N_b,y*mu_yz - 2/3*N_a,y*N_b,z*mu_yy                     |
     N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_yy + 4/3*N_a,z*N_b,z*mu_zz /

where N_a and N_b are shape functions of
the ath and bth node respectively and mu
are the components of the viscosity tensor.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </choice>
          </element>
          <optional>
            <element name="les_model">
              <a:documentation>large-eddy simulation</a:documentation>
              <element name="smagorinsky_coefficient">
                <a:documentation>literature sybol: Cs

suggested value 0.1</a:documentation>
                <ref name="real"/>
              </element>
              <element name="order">
                <a:documentation>les options</a:documentation>
                <choice>
                  <element name="second_order">
                    <a:documentation>similar to the original Smag model</a:documentation>
                    <empty/>
                  </element>
                  <element name="fourth_order">
                    <a:documentation>this adds a fourth order operator to tackle the
dissipation issues of the original Smag model

use this if your turbulence dissipates faster than it should

requires a fine mesh to perform well</a:documentation>
                    <empty/>
                  </element>
                </choice>
              </element>
            </element>
          </optional>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation. Confusingly it is not necessary to provide
a discontinuous velocity field for this to work!</a:documentation>
          <attribute name="replaces">
            <value>DISOPT</value>
          </attribute>
          <optional>
            <element name="mass_terms">
              <a:documentation>Discretisation options for the mass terms in the velocity equation.</a:documentation>
              <optional>
                <element name="lump_mass_matrix">
                  <a:documentation>Lump the mass matrix</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="exclude_mass_terms">
                  <a:documentation>Remove the mass terms from the equation.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <element name="viscosity_scheme">
            <choice>
              <element name="bassi_rebay">
                <a:documentation>Classical scheme from Bassi and Rebay 
(JCP 131 267-179 1997)</a:documentation>
                <empty/>
              </element>
              <element name="arbitrary_upwind">
                <a:documentation>Scheme in which upwinding is applied in
alternating directions. Devised by C.Pain.</a:documentation>
                <empty/>
              </element>
              <element name="interior_penalty">
                <a:documentation>Classical interior penalty scheme
see, e.g., SIAM Journal on Numerical Analysis
Vol. 39, No. 5 (2002), pp. 1749-1779 </a:documentation>
                <element name="penalty_parameter">
                  <a:documentation>Penalty_parameter
The penalty term Int [u][v] dS on element boundaries
is scaled by C = C_0 h**p
This option specifies the C_0
There is a theoretical lower bound for 
stability and hence convergence</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="edge_length_power">
                  <a:documentation>Penalty_parameter
The penalty term Int [u][v] dS on element boundaries
is scaled by C = C_0 h**p
This option specifies p
Theoretically p=-1 is required for linear elements</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="edge_length_option">
                  <a:documentation>Option for how to compute the edge length h</a:documentation>
                  <choice>
                    <element name="use_face_integral">
                      <a:documentation>Use face integral (take sqrt in 3D)</a:documentation>
                      <empty/>
                    </element>
                    <element name="use_element_centres">
                      <a:documentation>Use difference between element centre 
and neighbour centre
Use 2x distance to face centre on boundaries</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                </element>
                <optional>
                  <element name="debug">
                    <a:documentation>Switch on debugging output</a:documentation>
                    <element name="gradient_test_bound">
                      <a:documentation>Bound for testing element gradient matrix</a:documentation>
                      <ref name="real"/>
                    </element>
                    <optional>
                      <element name="remove_element_integral">
                        <a:documentation>Remove the elemental integral:
Int grad u.kappa.grad v dV</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_primal_fluxes">
                        <a:documentation>Remove the primal fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_penalty_fluxes">
                        <a:documentation>Remove the penalty fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </choice>
          </element>
          <element name="advection_scheme">
            <choice>
              <element name="upwind">
                <a:documentation>Straightforward upwinding of the nonlinear velocity.</a:documentation>
                <empty/>
              </element>
              <element name="none">
                <a:documentation>Disable advection</a:documentation>
                <empty/>
              </element>
            </choice>
            <element name="integrate_advection_by_parts">
              <a:documentation>Integrate the advection terms of the momentum equation by parts.

Integrating the advection term by parts is
necessary for a discontinuous
galerkin discretisation however it is possible to
select how many times the
integration by parts is performed.
Twice is the norm.</a:documentation>
              <choice>
                <element name="twice">
                  <a:documentation>If activated the element advection matrix takes the form:
   /                                 /
   | N_A (nu dot grad N_B) dV + beta | N_A ( div nu ) N_B dV
   /                                 /
     /                                         /
 + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - 1] | N_A_i (nu dot n) N_B_i ds
     /                                         /
where beta is set in conservative_advection,
N is a shape function (uppercase
subscripts indicate nodes A or B while
lowercase subscripts indicate inner or outer
faces i and o respectively), nu is the
nonlinear velocity and n is the outward
pointing normal from the element.</a:documentation>
                  <empty/>
                </element>
                <element name="once">
                  <a:documentation>If activated the element advection matrix takes the form:
   /                                        /
 - | (grad N_A dot nu) N_B dV - (1. - beta) | N_A ( div nu ) N_B dV
   /                                        /
     /                                   /
 + I | N_A_i (nu dot n) N_B_o ds + (1-I) | N_A_i (nu dot n) N_B_i ds
     /                                   /
where beta is set in conservative_advection,
N is a shape function (uppercase
subscripts indicate nodes A or B while
lowercase subscripts indicate inner or outer
faces i and o respectively), nu is the
nonlinear velocity and n is the outward
pointing normal from the element.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
            <optional>
              <element name="integrate_conservation_term_by_parts">
                <a:documentation>If activated the conservation term:
 /
 | N_A ( div nu ) N_B dV
 /
is integrated_by_parts such that the element
advection matrix becomes:
        /                                        /
 - beta | (grad N_A dot nu) N_B dV + (1. - beta) | N_A (nu dot grad N_B) dV
        /                                        /
     /                                                /
 + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - (1-beta)] | N_A_i (nu dot n) N_B_i ds
     /                                                /                  
where beta is set in conservative_advection, N is
a shape function (uppercase
subscripts indicate nodes A or B while lowercase
subscripts indicate inner or outer
faces i and o respectively), nu is the nonlinear
velocity and n is the outward pointing normal
from the element.
This is invariant regardless of whether the main
advection term is integrated by parts once or
twice.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of momentum equations
 BETA=1. -- conservative (divergence form)
 BETA=0. -- non-conservative
 0. &lt; BETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>BETA</value>
        </attribute>
        <ref name="real"/>
      </element>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <element name="theta">
        <a:documentation>Implicit/explicit control (THETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>THETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <element name="relaxation">
        <a:documentation>Non-linear relaxation term
 =0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
 =1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
 0. &lt; ITHETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>ITHETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <element name="discontinuous_galerkin">
          <optional>
            <element name="advection_cycling">
              <a:documentation>Use timestep subcycling to solve this equation.</a:documentation>
              <element name="number_advection_subcycles">
                <a:documentation>Specify the number of subcycles.</a:documentation>
                <ref name="integer"/>
              </element>
              <optional>
                <element name="coriolis_in_subcycles">
                  <a:documentation>Specify whether coriolis should be included in the 
subcycling.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TMPER1 TMPER2 TMPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="velocity_boundary_conditions"/>
      </element>
    </zeroOrMore>
    <optional>
      <element name="tensor_field">
        <a:documentation>For a Newtonian fluid this is the shear viscosity.

For continuous_galerkin see stress_terms to see how the
viscosity tensor is dealt with in the momentum equation.</a:documentation>
        <attribute name="replaces">
          <value>MUPTXX MUPTYY MUPTZZ MUPTYZ MUPTXZ MUPTXY RMUPXX RMUPYY RMUPZZ RMUPYZ RMUPXZ RMUPXY CONMU ALLMU TWOMU ONEMU</value>
        </attribute>
        <attribute name="name">
          <value>Viscosity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_tensor_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <choice>
              <ref name="internal_algorithm"/>
              <ref name="bulk_viscosity_algorithm"/>
              <ref name="tensor_python_diagnostic_algorithm"/>
            </choice>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Source</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>CONSOX CONSOY CONSOZ RONSOX RONSOY RONSOZ ZSOX ZSOY ZSOZ</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <choice>
              <ref name="vector_python_diagnostic_algorithm"/>
              <ref name="imposed_material_velocity_source_algorithm"/>
              <ref name="internal_velocity_source_algorithm"/>
            </choice>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <optional>
          <element name="lump_source">
            <attribute name="replaces">
              <value>SLUMP</value>
            </attribute>
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Absorption</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>XABSZE YABSZE ZABSZE XABS YABS ZABS XABSOR YABSOR ZABSOR XABSCO YABSCO ZABSCO</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <choice>
              <ref name="vector_python_diagnostic_algorithm"/>
              <ref name="imposed_material_velocity_absorption_algorithm"/>
              <ref name="internal_velocity_absorption_algorithm"/>
            </choice>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <choice>
          <element name="default_absorption">
            <a:documentation>Default absorption: no lumping, is fully evaluated before the
the pressure correction.</a:documentation>
            <attribute name="replaces">
              <value>ABSLUM</value>
            </attribute>
            <empty/>
          </element>
          <element name="lump_absorption">
            <a:documentation>Lump the inclusion of absorbtion terms.</a:documentation>
            <attribute name="replaces">
              <value>ABSLUM</value>
            </attribute>
            <optional>
              <element name="use_submesh">
                <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="include_pressure_correction">
            <a:documentation>Includes the pressure correction to the velocity in the
absorption term (for theta&gt;0). This makes the absorption
term more implicit. The absorption term is lumped if and
only if the mass matrix is lumped (lump_mass_matrix).</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="tensor_field">
        <a:documentation>SurfaceTension</a:documentation>
        <attribute name="name">
          <value>SurfaceTension</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <attribute name="field_name">
            <value>MaterialVolumeFraction</value>
          </attribute>
          <optional>
            <element name="lump_mass_matrix">
              <a:documentation>Choose whether the mass matrix is lumped or not for the calculation of the gradient</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="solver">
              <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
          </optional>
          <optional>
            <element name="integrate_by_parts">
              <a:documentation>Choose whether the surface tension term in the momentum equation is integrated by parts or not</a:documentation>
              <empty/>
            </element>
          </optional>
          <ref name="diagnostic_tensor_field"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_vector_output_options"/>
    <ref name="prognostic_velocity_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_vector_field"/>
    <ref name="interpolation_algorithm_vector"/>
    <optional>
      <ref name="discrete_properties_algorithm_vector"/>
    </optional>
  </define>
  <define name="prognostic_scalar_field">
    <ref name="scalar_equation_choice"/>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Continuous Galerkin formulation</a:documentation>
          <ref name="advection_stabilisation_options"/>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms.</a:documentation>
            <optional>
              <element name="integrate_advection_by_parts">
                <a:documentation>Integrate the advection terms of the advection equation by
parts.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="exclude_advection_terms">
                <a:documentation>Remove the advection terms from the equation.
This overrides any other advection term options (including
conservative_advection below).</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass terms.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix</a:documentation>
                <attribute name="replaces">
                  <value>TLUMP</value>
                </attribute>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="exclude_mass_terms">
                <a:documentation>Remove the mass terms from the equation. This requires an
implicitness factor theta = 1.0 (under
temporal_discretisation).</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <ref name="comment"/>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation. You can also use this
formulation with a continuous field in which case a simple
galerkin formulation will result. </a:documentation>
          <attribute name="replace">
            <value>70 &lt;= DISOTT &lt;= 90</value>
          </attribute>
          <element name="advection_scheme">
            <choice>
              <element name="upwind">
                <a:documentation>Straightforward upwinding of the nonlinear velocity.
This uses SU stabilisation with optimal choice for the
stabilisation parameter, and stabilisation parameter
scale factor 0.5.</a:documentation>
                <empty/>
              </element>
              <element name="none">
                <a:documentation>Disable advection</a:documentation>
                <empty/>
              </element>
            </choice>
            <element name="integrate_advection_by_parts">
              <a:documentation>Integrate the advection terms of the
advection-diffusion equation by parts.
Integrating the advection term by parts is
necessary for a discontinuous
galerkin discretisation however it is possible to
select how many times the
integration by parts is performed.
Twice is the norm.</a:documentation>
              <choice>
                <element name="twice">
                  <a:documentation>If activated the element advection matrix takes the form:
   /                                 /
   | N_A (nu dot grad N_B) dV + beta | N_A ( div nu ) N_B dV
   /                                 /
     /                                         /
 + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - 1] | N_A_i (nu dot n) N_B_i ds
     /                                         /
where beta is set in conservative_advection,
N is a shape function (uppercase
subscripts indicate nodes A or B while
lowercase subscripts indicate inner or outer
faces i and o respectively), nu is the
nonlinear velocity and n is the outward
pointing normal from the element.</a:documentation>
                  <empty/>
                </element>
                <element name="once">
                  <a:documentation>If activated the element advection matrix takes the form:
   /                                        /
 - | (grad N_A dot nu) N_B dV - (1. - beta) | N_A ( div nu ) N_B dV
   /                                        /
     /                                   /
 + I | N_A_i (nu dot n) N_B_o ds + (1-I) | N_A_i (nu dot n) N_B_i ds
     /                                   /
where beta is set in conservative_advection,
N is a shape function (uppercase
subscripts indicate nodes A or B while
lowercase subscripts indicate inner or outer
faces i and o respectively), nu is the
nonlinear velocity and n is the outward
pointing normal from the element.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
            <optional>
              <element name="integrate_conservation_term_by_parts">
                <a:documentation>If activated the conservation term:
 /
 | N_A ( div nu ) N_B dV
 /
is integrated_by_parts such that the element
advection matrix becomes:
        /                                        /
 - beta | (grad N_A dot nu) N_B dV + (1. - beta) | N_A (nu dot grad N_B) dV
        /                                        /
     /                                                /
 + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - (1-beta)] | N_A_i (nu dot n) N_B_i ds
     /                                                /                  
where beta is set in conservative_advection, N is
a shape function (uppercase
subscripts indicate nodes A or B while lowercase
subscripts indicate inner or outer
faces i and o respectively), nu is the nonlinear
velocity and n is the outward pointing normal
from the element.
This is invariant regardless of whether the main
advection term is integrated by parts once or
twice.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="diffusion_scheme">
            <choice>
              <element name="bassi_rebay">
                <a:documentation>Classical scheme from Bassi and Rebay 
(JCP 131 267-179 1997)</a:documentation>
                <empty/>
              </element>
              <element name="compact_discontinuous_galerkin">
                <a:documentation>Compact discontinuous Galerkin scheme.
(Peraire and Persson SIAM J. Sci. Comput. 30, p1806)</a:documentation>
                <optional>
                  <element name="penalty_parameter">
                    <a:documentation>Penalty_parameter
Add penalty term Int [u][v] dS on element boundaries
scaled by C_0</a:documentation>
                    <ref name="real"/>
                  </element>
                </optional>
                <optional>
                  <element name="debug">
                    <a:documentation>Switch on debugging output</a:documentation>
                    <element name="gradient_test_bound">
                      <a:documentation>Bound for testing element gradient matrix</a:documentation>
                      <ref name="real"/>
                    </element>
                    <optional>
                      <element name="remove_element_integral">
                        <a:documentation>Remove the elemental integral:
Int grad u.kappa.grad v dV</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_primal_fluxes">
                        <a:documentation>Remove the primal fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_cdg_fluxes">
                        <a:documentation>Remove the CDG fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="edge_length_power">
                        <a:documentation>When present, the penalty term
Int [u][v] dS on element boundaries is
scaled by C = C_0 h**p This option
specifies p.</a:documentation>
                        <ref name="real"/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
              <element name="arbitrary_upwind">
                <a:documentation>Scheme in which upwinding is applied in
alternating directions. Devised by C.Pain.</a:documentation>
                <empty/>
              </element>
              <element name="interior_penalty">
                <a:documentation>Classical interior penalty scheme
see, e.g., SIAM Journal on Numerical Analysis
Vol. 39, No. 5 (2002), pp. 1749-1779 </a:documentation>
                <element name="penalty_parameter">
                  <a:documentation>Penalty_parameter
The penalty term Int [u][v] dS on element boundaries
is scaled by C = C_0 h**p
This option specifies the C_0
There is a theoretical lower bound for 
stability and hence convergence</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="edge_length_power">
                  <a:documentation>Penalty_parameter
The penalty term Int [u][v] dS on element boundaries
is scaled by C = C_0 h**p
This option specifies p
Theoretically p=-1 is required for linear elements</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="edge_length_option">
                  <a:documentation>Option for how to compute the edge length h</a:documentation>
                  <choice>
                    <element name="use_face_integral">
                      <a:documentation>Use face integral (take sqrt in 3D)</a:documentation>
                      <empty/>
                    </element>
                    <element name="use_element_centres">
                      <a:documentation>Use difference between element centre 
and neighbour centre
Use 2x distance to face centre on boundaries</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                </element>
                <optional>
                  <element name="debug">
                    <a:documentation>Switch on debugging output</a:documentation>
                    <element name="gradient_test_bound">
                      <a:documentation>Bound for testing element gradient matrix</a:documentation>
                      <ref name="real"/>
                    </element>
                    <optional>
                      <element name="remove_element_integral">
                        <a:documentation>Remove the elemental integral:
Int grad u.kappa.grad v dV</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_primal_fluxes">
                        <a:documentation>Remove the primal fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="remove_penalty_fluxes">
                        <a:documentation>Remove the penalty fluxes</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </choice>
          </element>
          <optional>
            <element name="upwind_stabilisation">
              <a:documentation>This introduces a simple upwind diffusion based on eqn 2.52 in 
Donea and Huerta (2003) "Finite elements for flow problems".</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <choice>
              <element name="slope_limiter">
                <attribute name="name">
                  <value>Cockburn_Shu</value>
                </attribute>
                <element name="TVB_factor">
                  <a:documentation>TVB tolerance parameter, below this value (scaled by
dx**2) no limiting is done.
Reduce to do more limiting, increase to do less
Minimum value 0.0
Suggested value 5.0</a:documentation>
                  <ref name="real"/>
                </element>
                <optional>
                  <element name="tolerate_negative_weights">
                    <a:documentation>Tolerate negative weights in the reconstruction
Algorithm finds the "least bad" coordinates to use.
May lead to overshoots on funky meshes.</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <element name="limit_factor">
                  <a:documentation>Limit factor
This value is used to scale the reconstructed slope
Minimum value 1.0
Suggested value 1.1</a:documentation>
                  <ref name="real"/>
                </element>
              </element>
              <element name="slope_limiter">
                <a:documentation>Hermite-WENO limiter</a:documentation>
                <attribute name="name">
                  <value>Hermite_Weno</value>
                </attribute>
                <element name="power_coefficient">
                  <a:documentation>Power coefficient in weights.
This must be a positive number, possibly
an integer. Larger power coefficient leads
to greater penalisation of oscillations, on 
the other hand causes numerical problems if it
gets too big.
Suggested value = 4.</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="tolerance_threshold_oscillations">
                  <a:documentation>Relative/absolute tolerance threshold for 
oscillation indicator. Values below this emphasise
absolute rather than relative magnitudes of 
tracer gradients. 
Suggested value = 0.001*T
where T is a typical value of the tracer which
you might use in a scaling analysis.</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="tolerance_threshold_weights">
                  <a:documentation>Relative/absolute tolerance threshold for 
weights. Values below this emphasise
absolute rather than relative magnitudes of 
oscillations indicator. 
Suggested value = 1.0e-3</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="discontinuity_tolerance">
                  <a:documentation>Tolerance for discontinuity detector.
Uses method of 
http://www.gce.ucl.ac.be/~remacle/pdf/detect.pdf
Detector values greater than this indicate
discontinuities at the inflow boundary
Suggested value = L^(-p-1)/2)
where L is the horizontal lengthscale
and p is the polynomial order</a:documentation>
                  <ref name="real"/>
                </element>
                <element name="limit_tolerance">
                  <a:documentation>Tolerance for limiter
Doesn't apply limiter if max abs value of tracer
over the element is below this tolerance
Recommended value is something very small
but not zero</a:documentation>
                  <ref name="real"/>
                </element>
                <choice>
                  <element name="boundary_treatment">
                    <a:documentation>At boundaries there are less polynomials to
construct. With this option, the missing
polynomials are simply ignored.</a:documentation>
                    <attribute name="name">
                      <value>ignore_missing_polys</value>
                    </attribute>
                  </element>
                  <element name="boundary_treatment">
                    <a:documentation>At boundaries there are less polynomials to
construct. With this option, the missing
polynomials are replaced with the polynomial
in the current element.</a:documentation>
                    <attribute name="name">
                      <value>replace_missing_polys</value>
                    </attribute>
                  </element>
                  <element name="boundary_treatment">
                    <a:documentation>At boundaries there are less polynomials to
construct. With this option, the reconstruction
is applied at one order down.
Since HWENO currently only works for P1,
this amounts to L_2 projection to P0.</a:documentation>
                    <attribute name="name">
                      <value>lower_order</value>
                    </attribute>
                  </element>
                </choice>
                <optional>
                  <element name="debugging">
                    <a:documentation>Switch to chuck out lots of debugging output.
Not for production runs.</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <optional>
                  <element name="leave_out_hermite_polynomials">
                    <a:documentation>Don't include Hermite polynomials.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
              <element name="slope_limiter">
                <attribute name="name">
                  <value>minimal</value>
                </attribute>
              </element>
            </choice>
          </optional>
          <optional>
            <element name="mass_terms">
              <a:documentation>Discretisation options for the mass terms.</a:documentation>
              <optional>
                <element name="exclude_mass_terms">
                  <a:documentation>Remove the mass terms from the equation.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
        </element>
        <ref name="pure_cv_options"/>
        <ref name="coupled_cv_options"/>
        <element name="finite_volume">
          <a:documentation>**DO NOT USE!**
This is a temporary discretisation option to help Cian
implement P0 advection-diffusion.</a:documentation>
          <element name="diffusion_scheme">
            <choice>
              <element name="bassi_rebay">
                <optional>
                  <element name="penalty">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
              <element name="ldg">
                <empty/>
              </element>
            </choice>
          </element>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of field advection equation
 TBETA=1. -- conservative (divergence form)
 TBETA=0. -- non-conservative
 0. &lt; TBETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>TBETA, DEFALT (TBETA = 0.0)</value>
        </attribute>
        <ref name="real"/>
      </element>
    </element>
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicit control (TTHETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>TTHETA, DEFALT (TTHETA = 0.5)</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="temporal_control_volume_options"/>
      </optional>
      <optional>
        <ref name="temporal_discontinuous_galerkin_options"/>
      </optional>
    </element>
    <choice>
      <element name="solver">
        <a:documentation>Solver</a:documentation>
        <ref name="linear_solver_options_asym"/>
      </element>
      <element name="explicit">
        <a:documentation>Assume this field is being solved explicitly and skip the solver.

ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.

Assumes lhs matrix only has diagonal lumped mass (times
density if appropriate for equation)
and divides the rhs by this.</a:documentation>
        <empty/>
      </element>
    </choice>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <optional>
              <element name="apply_weakly">
                <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin and
control_volume
spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
                <optional>
                  <element name="boundary_overwrites_initial_condition">
                    <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>robin</value>
            </attribute>
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
          <element name="type">
            <a:documentation>Prevent the field from fluxing out of the boundary.
Only applicable to control volume spatial discretisations.</a:documentation>
            <attribute name="name">
              <value>zero_flux</value>
            </attribute>
            <empty/>
          </element>
        </choice>
      </element>
    </zeroOrMore>
    <optional>
      <choice>
        <a:documentation>Choice of subgridscale model to apply to this field. 
Note that the selected parameterisation must be switched 
on for this material phase.

At this time, do not switch on this option if you are using Mellor-Yamada.</a:documentation>
        <element name="subgridscale_parameterisation">
          <attribute name="name">
            <value>Gent_McWilliams</value>
          </attribute>
        </element>
        <element name="subgridscale_parameterisation">
          <attribute name="name">
            <value>GLS</value>
          </attribute>
        </element>
        <element name="subgridscale_parameterisation">
          <attribute name="name">
            <value>prescribed_diffusivity</value>
          </attribute>
        </element>
      </choice>
    </optional>
    <optional>
      <element name="tensor_field">
        <a:documentation>Diffusivity for field</a:documentation>
        <attribute name="name">
          <value>Diffusivity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="replaces">
          <value>TMUXX TMUYY TMUZZ TMUYZ TMUXZ TMUXY TALLMU TCONMU</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <optional>
              <ref name="mesh_choice"/>
            </optional>
            <ref name="prescribed_tensor_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <a:documentation>Switch to this is the model is required to set the diffusivity throughout the run.

For electrical modelling - holds electrical conductivity.

For GLS, this needs to be set for the two turbulent fields so that their diffusivity
can be altered during the run.</a:documentation>
            <choice>
              <ref name="internal_algorithm"/>
              <ref name="tensor_python_diagnostic_algorithm"/>
            </choice>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>source term</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>ZSOT</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <a:documentation>This only works for traffic modelling</a:documentation>
            <choice>
              <ref name="scalar_python_diagnostic_algorithm"/>
              <ref name="internal_algorithm"/>
            </choice>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Absorption term</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>TABSZE TABS TABSCO TABSOR</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <choice>
              <ref name="scalar_python_diagnostic_algorithm"/>
              <ref name="internal_algorithm"/>
            </choice>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Velocity at which this substance sinks through the water column.

This velocity is in the direction of gravity so if the substance
floats or swims upwards, this field should be negative.</a:documentation>
        <attribute name="name">
          <value>SinkingVelocity</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <choice>
              <ref name="scalar_python_diagnostic_algorithm"/>
              <ref name="internal_algorithm"/>
            </choice>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_density_field">
    <optional>
      <ref name="scalar_equation_choice"/>
    </optional>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Continuous Galerkin formulation.</a:documentation>
          <ref name="advection_stabilisation_options"/>
          <element name="advection_terms">
            <a:documentation>Discretisation options for the advection terms.</a:documentation>
            <optional>
              <element name="integrate_advection_by_parts">
                <a:documentation>Integrate the advection terms of the momentum equation by
parts.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
          <element name="mass_terms">
            <a:documentation>Discretisation options for the mass terms.</a:documentation>
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <ref name="comment"/>
        </element>
        <element name="control_volumes">
          <a:documentation>Use a control volume discretisation.</a:documentation>
          <ref name="spatial_control_volume_options"/>
        </element>
      </choice>
    </element>
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicit control (TTHETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicholson
 =1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>TTHETA, DEFALT (TTHETA = 0.5)</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="temporal_control_volume_options"/>
      </optional>
    </element>
    <optional>
      <choice>
        <element name="solver">
          <a:documentation>Solver</a:documentation>
          <ref name="linear_solver_options_asym"/>
        </element>
        <element name="explicit">
          <a:documentation>Assume this field is being solved explicitly and skip the solver.

ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.

Assumes lhs matrix only has diagonal lumped mass (times
density if appropriate for equation)
and divides the rhs by this.</a:documentation>
          <empty/>
        </element>
      </choice>
    </optional>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <group>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <optional>
              <element name="apply_weakly">
                <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin,
and control_volume spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
                <optional>
                  <element name="boundary_overwrites_initial_condition">
                    <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                    <empty/>
                  </element>
                </optional>
              </element>
            </optional>
            <ref name="input_choice_real"/>
          </element>
        </group>
      </element>
    </zeroOrMore>
    <optional>
      <element name="scalar_field">
        <a:documentation>source term</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>ZSOT</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
            <optional>
              <ref name="recalculation_options"/>
            </optional>
          </element>
          <element name="diagnostic">
            <a:documentation>This only works for traffic modelling</a:documentation>
            <ref name="internal_algorithm"/>
            <ref name="diagnostic_scalar_field_no_adapt"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Absorption term</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>TABSZE TABS TABSCO TABSOR</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_scalar_field_no_adapt"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="geometry">
    <element name="geometry">
      <a:documentation>Options dealing with the specification of geometry</a:documentation>
      <element name="dimension">
        <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
        <attribute name="replaces">
          <value>NDIM</value>
        </attribute>
        <element name="integer_value">
          <attribute name="rank">
            <value>0</value>
          </attribute>
          <choice>
            <value>3</value>
            <value>2</value>
            <value>1</value>
          </choice>
        </element>
      </element>
      <element name="mesh">
        <a:documentation>The position mesh</a:documentation>
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
        <ref name="mesh_info"/>
      </element>
      <element name="mesh">
        <a:documentation>The velocity mesh</a:documentation>
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
        <ref name="mesh_info"/>
      </element>
      <element name="mesh">
        <a:documentation>The pressure mesh</a:documentation>
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
        <ref name="mesh_info"/>
      </element>
      <zeroOrMore>
        <element name="mesh">
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <ref name="mesh_info"/>
          <optional>
            <element name="exclude_from_mesh_adaptivity">
              <empty/>
            </element>
          </optional>
        </element>
      </zeroOrMore>
      <element name="quadrature">
        <a:documentation>Quadrature</a:documentation>
        <element name="degree">
          <a:documentation>Quadrature degree

note: this specifies the degree of quadrature,
not the number of gauss points</a:documentation>
          <attribute name="replaces">
            <value>NGI</value>
          </attribute>
          <ref name="integer"/>
        </element>
        <optional>
          <element name="surface_degree">
            <a:documentation>Surface quadrature degree

note: this specifies the degree of surface
quadrature not the number of surface gauss points</a:documentation>
            <attribute name="replaces">
              <value>SNGI</value>
            </attribute>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="controlvolume_surface_degree">
            <a:documentation>Sets the degree of quadrature on each quadrilateral
face of the control volume. 

Defaults to 1 if
unselected which is the same as pre-new options
behaviour.</a:documentation>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="quadrature_family">
            <a:documentation>Select which family of quadrature rules to use.
The default is family_cools.
family_wandzura allows for degree up to 30
on triangular meshes.
family_grundmann_moeller allows for degree up to
29 on simplicial meshes in arbitrary dimension.</a:documentation>
            <element name="string_value">
              <choice>
                <value>family_cools</value>
                <value>family_grundmann_moeller</value>
                <value>family_wandzura</value>
              </choice>
            </element>
          </element>
        </optional>
      </element>
      <optional>
        <element name="disable_geometric_data_cache">
          <a:documentation>This causes the change of variables associated with each element in 
the mesh to be stored rather than calculated every time it is used. 
This should speed up computations at a cost of some memory. 

The cache is automatically regenerated after mesh movement or 
adaptivity and is automatically disabled for non-linear positions fields.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="spherical_earth">
          <a:documentation>Options specifying that the problem is on the surface of the sphere.</a:documentation>
          <attribute name="replaces">
            <value>ISPHERE</value>
          </attribute>
          <choice>
            <element name="linear_mapping">
              <attribute name="replaces">
                <value>ISPHERE=1</value>
              </attribute>
              <empty/>
            </element>
            <element name="superparametric_mapping">
              <a:documentation>Enabling this option approximates the curvature of the Earth as an
nth degree polynomial, where n is the polynomial degree of the coordinate mesh.</a:documentation>
              <attribute name="replaces">
                <value>ISPHERE=2</value>
              </attribute>
              <empty/>
            </element>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="ocean_boundaries">
          <a:documentation>Options specifying the top surface and bottom of the domain
used in various ocean calculations.</a:documentation>
          <element name="top_surface_ids">
            <a:documentation>Specify the surface ids that make up the top of the domain,
i.e. the free surface or rigid lid.</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <element name="bottom_surface_ids">
            <a:documentation>Specify the surface ids that make up the bottom.</a:documentation>
            <ref name="integer_vector"/>
          </element>
          <element name="scalar_field">
            <a:documentation>Diagnostic field giving the distance to the top surface.</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>DistanceToTop</value>
            </attribute>
            <element name="diagnostic">
              <ref name="internal_algorithm"/>
              <element name="mesh">
                <attribute name="name">
                  <value>CoordinateMesh</value>
                </attribute>
              </element>
              <ref name="diagnostic_scalar_field"/>
            </element>
          </element>
          <element name="scalar_field">
            <a:documentation>Diagnostic field giving the distance to ocean bottom.</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>DistanceToBottom</value>
            </attribute>
            <element name="diagnostic">
              <ref name="internal_algorithm"/>
              <element name="mesh">
                <attribute name="name">
                  <value>CoordinateMesh</value>
                </attribute>
              </element>
              <ref name="diagnostic_scalar_field"/>
            </element>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!-- Default child of diagnostic scalar field without adaptivity options -->
  <define name="diagnostic_scalar_field_no_adapt">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
  </define>
  <!-- Default child of diagnostic scalar field -->
  <define name="diagnostic_scalar_field_tidal_range">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <element name="spin_up_time">
      <ref name="real"/>
    </element>
  </define>
  <!--
    Default child of prescribed scalar field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field">
    <ref name="prescribed_scalar_field_no_adapt"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="interpolation_algorithm_scalar"/>
    </optional>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of prescribed scalar field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field_no_adapt">
    <ref name="prescribed_values_scalar_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_scalar_stat_options"/>
    <ref name="prescribed_detector_options"/>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_vector_field_bed_shear_stress">
    <element name="density">
      <ref name="real"/>
    </element>
    <element name="drag_coefficient">
      <ref name="real"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field">
    <ref name="prescribed_vector_field_no_adapt"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="interpolation_algorithm_vector"/>
    </optional>
    <optional>
      <ref name="discrete_properties_algorithm_vector"/>
    </optional>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!--
    Default child of prescribed vector field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field_no_adapt">
    <ref name="prescribed_values_vector_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_vector_stat_options"/>
    <ref name="prescribed_detector_options"/>
  </define>
  <define name="prescribed_values_vector_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh

Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real_dim_vector_plus_file"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real_dim_vector_plus_file"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_output_options"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <define name="prognostic_pressure_field">
    <element name="spatial_discretisation">
      <choice>
        <element name="continuous_galerkin">
          <optional>
            <element name="remove_stabilisation_term">
              <a:documentation>remove the  fourth order pressure stabilisation term KCMC
must be removed for multimaterial and free surface calculations</a:documentation>
              <attribute name="replaces">
                <value>NOFILT</value>
              </attribute>
            </element>
          </optional>
          <optional>
            <element name="integrate_continuity_by_parts">
              <a:documentation>Integrate the continuity equation by parts.

This allows for the imposition of weak velocity boundary conditions with continuous_galerkin.
If activated this means that the pressure gradient operator is not integrated by parts.</a:documentation>
              <attribute name="replaces">
                <value>PREOPT</value>
              </attribute>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <attribute name="replaces">
            <value>NCOLOP = X1XXXXX -&gt; INTERF, NOFILT</value>
          </attribute>
        </element>
      </choice>
    </element>
    <optional>
      <element name="reference_node">
        <a:documentation>Reference node (Node at which pressure = 0.)

Must be less than the total number of nodes.
If parallel must be less than the total number of nodes of the first processor.

Note - it is also an option to remove the null-space of the residual vector. This
option is available under solvers.</a:documentation>
        <attribute name="replaces">
          <value>NDPSET</value>
        </attribute>
        <ref name="integer"/>
      </element>
    </optional>
    <optional>
      <element name="repair_stiff_nodes">
        <a:documentation>**UNDER DEVELOPMENT**
This searches the CMC matrix diagonal looking for nodes that are less than the maximum value time epsilon(0.0) (i.e. nodes that are effectively zero).
It then zeros that row and column and places a one on the diagonal and a zero on the rhs.
At a debug level of 2 it also prints out the value and the sum of the row values.
This is useful as a debugging tool if PETSc complains about zeros on the diagonal (i.e. if you have a stiff node in your mesh) but doesn't necessary produce nice answers at the end.</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="atmospheric_pressure">
        <a:documentation>Atmospheric pressure

Manual suggests 1.01325E+6</a:documentation>
        <attribute name="replaces">
          <value>PATMOS</value>
        </attribute>
        <ref name="real"/>
      </element>
    </optional>
    <element name="scheme">
      <a:documentation>scheme</a:documentation>
      <element name="poisson_pressure_solution">
        <a:documentation>Use a poisson pressure equation to calculate a first guess at pressure.
This does not necessarily satisfy continuity.
  = 1 -- use a poisson guess at every timestep
  = 0 -- never use a poisson guess
  =-1 -- use a poisson guess at the first timestep only
Manual suggests -1</a:documentation>
        <attribute name="replaces">
          <value>POISON</value>
        </attribute>
        <group>
          <element name="string_value">
            <!--
              Lines is a hint to the gui about the size of the text box.
              It is not an enforced limit on string length.
            -->
            <attribute name="lines">
              <value>1</value>
            </attribute>
            <choice>
              <value>never</value>
              <value>every timestep</value>
              <value>only first timestep</value>
            </choice>
          </element>
          <ref name="comment"/>
        </group>
      </element>
      <choice>
        <element name="use_projection_method">
          <a:documentation>Use the incompressible projection method to determine
the pressure and satisfy continuity</a:documentation>
          <attribute name="replaces">
            <value>PROJEC</value>
          </attribute>
          <optional>
            <element name="full_schur_complement">
              <a:documentation>Assemble and use the full schur complement.
This allows you to not lump the mass matrix if you're using
cg and to use the full momentum matrix in the projection if
you so desire.</a:documentation>
              <choice>
                <element name="inner_matrix">
                  <a:documentation>Specify the inner matrix (IM) to form the projection schur complement (C^T*IM^{-1}*C). 
Use the full mass matrix.

Make sure you've not lumped your mass in the velocity spatial_discretisation if you want to be consistent!</a:documentation>
                  <attribute name="name">
                    <value>FullMassMatrix</value>
                  </attribute>
                  <element name="solver">
                    <ref name="linear_solver_options_sym"/>
                  </element>
                </element>
                <element name="inner_matrix">
                  <a:documentation>Specify the inner matrix (IM) to form the projection schur complement (C^T*IM^{-1}*C). 
Use the full momentum matrix.

Doesn't really matter if you've lumped your mass or not but why would you if you're doing a full inner solve anyway?</a:documentation>
                  <attribute name="name">
                    <value>FullMomentumMatrix</value>
                  </attribute>
                  <element name="solver">
                    <ref name="linear_solver_options_asym"/>
                  </element>
                </element>
              </choice>
              <choice>
                <element name="preconditioner_matrix">
                  <a:documentation>Specify the preconditioner matrix to use on the schur complement.

For DG, the LumpedSchurComplement is our best approximation to CMC.</a:documentation>
                  <attribute name="name">
                    <value>LumpedSchurComplement</value>
                  </attribute>
                  <optional>
                    <element name="lump_on_submesh">
                      <empty/>
                    </element>
                  </optional>
                </element>
                <element name="preconditioner_matrix">
                  <a:documentation>Specify the preconditioner matrix to use on the schur complement.

DiagonalSchurComplement = C_P^T * [(Big_m)_diagonal]^-1 * C</a:documentation>
                  <attribute name="name">
                    <value>DiagonalSchurComplement</value>
                  </attribute>
                  <empty/>
                </element>
                <element name="preconditioner_matrix">
                  <a:documentation>Specify the preconditioner matrix to use on the schur complement.</a:documentation>
                  <attribute name="name">
                    <value>NoPreconditionerMatrix</value>
                  </attribute>
                  <empty/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
        <element name="use_compressible_projection_method">
          <a:documentation>Use the compressible projection method to determine the
pressure and satisfy continuity and the eos.
This is only currently compatible with control volume
pressure spatial discretisations and requires a
multimaterial eos.</a:documentation>
          <attribute name="replaces">
            <value>MKCOMP from solidity_options.inp</value>
          </attribute>
          <optional>
            <choice>
              <element name="normalisation">
                <a:documentation>Variable (normally a density) used to normalise
each materials contribution
to the C_P^T matrix.  Leave unselected for no normalisation.
Selects the MaterialDensity field.</a:documentation>
                <attribute name="name">
                  <value>MaterialDensity</value>
                </attribute>
                <empty/>
              </element>
              <element name="normalisation">
                <a:documentation>Variable (normally a density) used to normalise
each materials contribution
to the C_P^T matrix.  Leave unselected for no normalisation.
Selects the bulk Density field.</a:documentation>
                <attribute name="name">
                  <value>Density</value>
                </attribute>
                <empty/>
              </element>
              <element name="normalisation">
                <a:documentation>Variable (normally a density) used to normalise
each materials contribution
to the C_P^T matrix.  Leave unselected for no normalisation.
Allows the selection of an arbitrary field.</a:documentation>
                <attribute name="name">
                  <data type="string" datatypeLibrary=""/>
                </attribute>
                <empty/>
              </element>
            </choice>
          </optional>
        </element>
      </choice>
      <optional>
        <element name="update_discretised_equation">
          <a:documentation>rediscretise the equations at every timestep and iteration
(this is useful as a debugging tool but shouldn't be necessary for any application runs)</a:documentation>
          <attribute name="replaces">
            <value>CMCHAN</value>
          </attribute>
          <empty/>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <zeroOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </zeroOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <element name="type">
          <a:documentation>Type</a:documentation>
          <attribute name="name">
            <value>dirichlet</value>
          </attribute>
          <optional>
            <element name="apply_weakly">
              <a:documentation>Apply the dirichlet bc weakly.  Available
automatically with discontinuous_galerkin and
control_volume spatial_discretisations.
If not selected boundary conditions are applied strongly.</a:documentation>
              <optional>
                <element name="boundary_overwrites_initial_condition">
                  <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <ref name="input_choice_real_plus_boundary_forcing"/>
        </element>
      </element>
    </zeroOrMore>
    <ref name="pressure_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="detector_options_disabled_default"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <define name="prognostic_geostrophic_pressure_field">
    <element name="spatial_discretisation">
      <element name="geostrophic_pressure_option">
        <a:documentation>Enables / disables RHS terms in the geopressure solver:

  include_buoyancy - Include both the buoyancy and Coriolis terms on the RHS
  exclude_buoyancy - Include only the Coriolis term on the RHS
  exclude_coriolis - Include only the buoyancy term on the RHS</a:documentation>
        <attribute name="replaces">
          <value>GEOBAL</value>
        </attribute>
        <element name="string_value">
          <choice>
            <value>include_buoyancy</value>
            <value>exclude_buoyancy</value>
            <value>exclude_coriolis</value>
          </choice>
        </element>
      </element>
    </element>
    <optional>
      <choice>
        <element name="reference_node">
          <a:documentation>Sets node 1 in the mesh as a reference node</a:documentation>
          <attribute name="name">
            <value>node_1</value>
          </attribute>
          <element name="integer_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="shape">
              <value>1</value>
            </attribute>
            <value>1</value>
          </element>
          <ref name="comment"/>
        </element>
        <element name="reference_node">
          <a:documentation>Sets a custom node in the mesh as a reference node</a:documentation>
          <attribute name="name">
            <value>custom</value>
          </attribute>
          <ref name="integer"/>
        </element>
        <element name="zero_coord">
          <a:documentation>Sets the value of the field to zero at a supplied coordinate.
This is a post-processing step after the solve, and hence should
be used with the solver/remove_null_space option.</a:documentation>
          <ref name="real_dim_vector"/>
        </element>
      </choice>
    </optional>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <zeroOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </zeroOrMore>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    Balance pressure field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_balance_pressure_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <!--
        note I removed disott here as it
        will switch on free-surface options in geoeli1p
        should be hard-coded to 0 in comsca therefore
        tlump is irrelevant
        suftem should be hard-coded to .false. if nlevel is set
      -->
      <element name="geostrophic_pressure_option">
        <a:documentation>Geostrophic pressure option</a:documentation>
        <attribute name="replaces">
          <value>GEOBAL</value>
        </attribute>
        <element name="string_value">
          <choice>
            <value>include_buoyancy</value>
            <value>exclude_buoyancy</value>
          </choice>
        </element>
      </element>
      <!--
        unfortunately tbeta doesn`t make sense here
        so we have to code an exception for not having it in comsca
      -->
    </element>
    <!--
      Temporal_discretisation doesn`t apply to balance pressure
      (there`s no time derivative). Exception again
      Solver block is the same as prognostic_scalar_field
    -->
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <!-- Alas, no initial_condition either, so we'd better not checkpointing it... -->
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <!--
      There are boundary conditions, but nothing you can set
      (all derived from velocity b.c.s)
      no Diffusivity tensor_field
      no Source scalar_field
      no Absorption scalar_field
      no adaptive time-stepping
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar_full"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    Vertical balance pressure field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_vertical_balance_pressure_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <!-- we don't have any yet -->
      <empty/>
    </element>
    <!--
      Temporal_discretisation doesn`t apply to balance pressure
      (there`s no time derivative). Exception again
      no solver block as we don't do a PETSc solve
      Alas, no initial_condition either...
      boundary conditions are fixed (p=0 on top)
      no Diffusivity tensor_field
      no Source scalar_field
      no Absorption scalar_field
      no adaptive time-stepping
    -->
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    free surface field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_free_surface_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <optional>
        <element name="free_surface_3D">
          <a:documentation>Form a full 3D system for the free surface</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^0 (frees3d)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="fourth_order_dissipation">
          <attribute name="replaces">
            <value>DISOTT=2^2 (fourthfrees_diss)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="low_order_free_surface">
          <a:documentation>low order (linear) free surface</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^3 (geo_short)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <choice>
        <element name="default_free_surface_filter">
          <a:documentation>Select free surface filter

With PN-PN we need some filter to supress spurious modes.</a:documentation>
          <empty/>
        </element>
        <element name="user_specified_free_surface_filter">
          <a:documentation>Select free surface filter

With PN-PN we need some filter to supress spurious modes.</a:documentation>
          <element name="non_linear_filter_coefficient">
            <a:documentation>Default is to apply 0.01 and for wetting and drying cases 1.0</a:documentation>
            <ref name="real"/>
          </element>
        </element>
        <element name="switch_off_free_surface_filter">
          <a:documentation>Switch off free surface filter, this is more efficient than setting the coefficient to 0.</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^8 (nofsta)</value>
          </attribute>
          <empty/>
        </element>
      </choice>
      <optional>
        <element name="wetting_drying">
          <a:documentation>Apply wetting and drying routines</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^10 (wetdry)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="tidal_forcing">
          <a:documentation>Tidal forcing options </a:documentation>
          <optional>
            <element name="M2">
              <a:documentation>M2</a:documentation>
              <attribute name="replaces">
                <value>DISOTT=2^11</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="S2">
              <a:documentation>S2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="N2">
              <a:documentation>N2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="K2">
              <a:documentation>K2</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="K1">
              <a:documentation>K1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="O1">
              <a:documentation>O1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="P1">
              <a:documentation>P1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="Q1">
              <a:documentation>Q1</a:documentation>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="all_tidal_components">
              <a:documentation>Switch on all tidal components</a:documentation>
              <attribute name="replaces">
                <value>DISOTT=2^5 (tidallcom)</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="love_number">
              <a:documentation>Switches on a Love number of 0.3</a:documentation>
              <attribute name="replaces">
                <value>DISOTT=2^6 (tlove)</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="static_tidal_force">
              <a:documentation>Use static tidal force for testing</a:documentation>
              <attribute name="replaces">
                <value>DISOTT=2^7 (statid)</value>
              </attribute>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
    </element>
    <!--
      atheta, ctheta and fstheta (absorption, coriolis and free surface)
      need to go in temporal discretisation
      they are currently hard-coded however
    -->
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicitness for the free surface.

Suggested value 1.0 (should be at least bigger than 0.5).
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>THETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <!-- Maybe this should go under a proper absorption field under free surface? -->
        <element name="absorption_theta">
          <a:documentation>Implicit/explicitness for absorption
=0.  -- explicit (default)
=0.5 -- Crank-Nicolson
=1.  -- implicit</a:documentation>
          <attribute name="replaces">
            <value>disott=2^4 (IMPABS)</value>
          </attribute>
          <ref name="real"/>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh

Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying
different values in different
regions of the mesh (defined by region_ids).  In this case
each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <choice>
              <ref name="input_choice_real_contents"/>
              <element name="from_file">
                <oneOrMore>
                  <element name="tidal">
                    <attribute name="file_name">
                      <data type="string" datatypeLibrary=""/>
                    </attribute>
                    <attribute name="variable_name_amplitude">
                      <data type="string" datatypeLibrary=""/>
                    </attribute>
                    <attribute name="variable_name_phase">
                      <data type="string" datatypeLibrary=""/>
                    </attribute>
                    <attribute name="name">
                      <a:documentation>See E.W. Schwiderski - Rev. Geophys. Space
Phys. Vol. 18 No. 1 pp. 243--268, 1980
for details of these constituent.</a:documentation>
                      <choice>
                        <value>M2</value>
                        <value>S2</value>
                        <value>N2</value>
                        <value>K2</value>
                        <value>K1</value>
                        <value>O1</value>
                        <value>P1</value>
                        <value>Q1</value>
                        <value>Mf</value>
                        <value>Mm</value>
                        <value>Ssa</value>
                      </choice>
                    </attribute>
                  </element>
                </oneOrMore>
              </element>
              <element name="NEMO_data">
                <a:documentation>Set the boundary free-surface height from NEMO data.
A prescribed NEMO pressure scalar field must be set to use this option.
Set the name of the prescribed NEMO pressure scalar field below.</a:documentation>
                <attribute name="field_name">
                  <data type="string" datatypeLibrary=""/>
                </attribute>
              </element>
            </choice>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>robin</value>
            </attribute>
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </choice>
      </element>
    </zeroOrMore>
    <!--
      no Diffusivity for field
      no source term
      no Absorption term
      no Adaptive timestepping option
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    stream function, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_stream_function_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <!--
      no Diffusivity for field
      no source term
      no Absorption term
      no Adaptive timestepping option
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="adaptivity_options_prognostic_scalar_field"/>
    <ref name="interpolation_algorithm_scalar"/>
    <optional>
      <ref name="discrete_properties_algorithm_scalar"/>
    </optional>
  </define>
  <!--
    Richardson number field. This is a normal diagnostic scalar field, but with
    Richardson number metric options added
  -->
  <define name="adaptivity_options_richardson_number_field.adaptivity_options">
    <element name="no_interpolation_measure">
      <a:documentation>Do not use an interpolation error driven metric for this field</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="adaptivity_options_richardson_number_field.adaptivity_options" combine="choice">
    <ref name="adaptivity_options_scalar_field.adaptivity_options"/>
  </define>
  <define name="adaptivity_options_richardson_number_field">
    <optional>
      <element name="adaptivity_options">
        <ref name="adaptivity_options_richardson_number_field.adaptivity_options"/>
        <optional>
          <element name="richardson_number_metric">
            <a:documentation>An isotropic metric formulation based on the Richardson number. Uses
the logic that wherever the Richardson number is small, we expect
to need resolution. Generates edge lengths using:

  Edge length = min_edge_length if Ri &lt;= min_ri
                max_edge_length if Ri &gt;= max_ri
                a linear fit between min_edge_length and max_edge_length otherwise</a:documentation>
            <optional>
              <element name="min_ri">
                <a:documentation>Richardson number at which we have minimum edge length (default 0.0)</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <element name="max_ri">
              <a:documentation>Richardson number at which we have maximum edge length</a:documentation>
              <ref name="real"/>
            </element>
            <element name="min_edge_length">
              <a:documentation>Minimum edge length that can be requested by the Richardson number
metric</a:documentation>
              <ref name="real"/>
            </element>
            <element name="max_edge_length">
              <a:documentation>Maximum edge length that can be requested by the Richardson number
metric</a:documentation>
              <ref name="real"/>
            </element>
            <optional>
              <element name="anisotropy_preserving_merge">
                <a:documentation>Enable to preserve anisotropy when merging with other metric
formulations</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="adaptivity_preprocessing"/>
      </element>
    </optional>
  </define>
  <define name="diagnostic_richardson_number_field">
    <ref name="diagnostic_scalar_field_no_adapt"/>
  </define>
  <define name="diagnostic_richardson_number_field" combine="interleave">
    <ref name="adaptivity_options_richardson_number_field"/>
  </define>
  <define name="diagnostic_cv_gradient_vector_field">
    <optional>
      <element name="lump_mass_matrix">
        <a:documentation>Choose whether the mass matrix is lumped or not</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="solver">
        <a:documentation>Solver options are necessary if you're not lumping your mass or if you're field isn't dg</a:documentation>
        <ref name="linear_solver_options_sym"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Normalise the gradient by its magnitude</a:documentation>
        <empty/>
      </element>
    </optional>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_gradient_vector_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="vector_steady_state_options"/>
    <ref name="adaptivity_options_vector_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_cv_divergence_scalar_field">
    <!-- No solver options because it can be solved directly! -->
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <define name="diagnostic_fe_divergence_scalar_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_sym"/>
    </element>
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="diagnostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <ref name="recalculation_options"/>
    </optional>
  </define>
  <!-- three optional input vectors for user-specified rotation matrix -->
  <define name="rotation_matrix_components">
    <optional>
      <element name="normal_direction">
        <a:documentation>Select if you want to specify the normal direction
of the rotation matrix.
If off then fluidity computes the normal (replaces GETTAN = .TRUE.)
If on the tangents vectors must also be specified.</a:documentation>
        <attribute name="replaces">
          <value>GETTAN=.FALSE.</value>
        </attribute>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_1">
        <a:documentation>specify first unit tangent vector to boundary</a:documentation>
        <attribute name="replaces">
          <value>GETTAN=.FALSE.</value>
        </attribute>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_2">
        <a:documentation>specify second (if exists, i.e. if 3d) unit tangent vector to boundary</a:documentation>
        <attribute name="replaces">
          <value>GETTAN=.FALSE.</value>
        </attribute>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
  </define>
  <define name="velocity_components_choice">
    <choice>
      <element name="align_bc_with_surface">
        <optional>
          <element name="normal_component">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_1">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_2">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <ref name="rotation_matrix_components"/>
        <optional>
          <element name="debugging_mode">
            <a:documentation>this will calculate the determinant of the
rotation matrix for every boundary node
and dump a vtu with the node 
normals and tangenials 1/2</a:documentation>
            <empty/>
          </element>
        </optional>
      </element>
      <element name="align_bc_with_cartesian">
        <optional>
          <element name="x_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="y_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
        <optional>
          <element name="z_component">
            <ref name="input_choice_real_bc_component"/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <!-- and again for robin b.c.s -->
  <define name="robin_velocity_components_choice">
    <!--
              element align_bc_with_surface {
                 element normal_component {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_1 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 element tangent_component_2 {
                    element order_zero_coefficient {
                       input_choice_real
                    },
                    element order_one_coefficient {
                       input_choice_real
                    }
                 }?,
                 rotation_matrix_components
              }|
    -->
    <element name="align_bc_with_cartesian">
      <optional>
        <element name="x_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="y_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
      <optional>
        <element name="z_component">
          <element name="order_zero_coefficient">
            <ref name="input_choice_real"/>
          </element>
          <element name="order_one_coefficient">
            <ref name="input_choice_real"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <optional>
          <element name="apply_weakly">
            <a:documentation>Apply the dirichlet bc weakly.  Available automatically
with a discontinuous_galerkin Velocity
spatial_discretisation.  Available if you
integrate_continuity_by_parts with a
continuous_galerkin Pressure or use a control_volume
Pressure spatial_discretisation and/or
integrate_advection_by_parts under Velocity
spatial_discretisation with continuous_galerkin.

If not selected boundary conditions are applied strongly.</a:documentation>
            <optional>
              <element name="boundary_overwrites_initial_condition">
                <a:documentation>If the initial condition and boundary conditions
differ, setting this option will cause the initial
condition on the boundary to be overwritten with
the boundary condition. Since you are applying the
boundary condition weakly, you probably do *not*
want this.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>robin</value>
        </attribute>
        <ref name="robin_velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>free_surface</value>
        </attribute>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient. If you
want to exactly replicate results from using the OCEDRA
option, set this to 0.003 and remember to apply to both
bottom and sides.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
        <choice>
          <element name="quadratic_drag">
            <a:documentation>Use a quadratic drag.

This means that the drag coefficient is nondimensional.</a:documentation>
            <empty/>
          </element>
          <element name="linear_drag">
            <a:documentation>Use a linear drag (basically just a surface absorption term).

This means that the drag coefficient has units of momentum.</a:documentation>
            <empty/>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <a:documentation>Wind forcing with user specified wind stress

&lt;b&gt; Note that the stress needs to be specified
using the same density units as the reference_density 
under equation of state.&lt;/b&gt;So if you use the recommended
non-dimensional value of 1.0 for reference_density and
your calculated stress is in kg m^-1s^-2 and the dimensional
reference_density is 1000.0 kg m^-3, you need to divide
the calculated stress in SI units by 1000.0.</a:documentation>
            <choice>
              <ref name="input_choice_real_dim_minus_one_vector"/>
              <element name="from_netcdf">
                <attribute name="file_name">
                  <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/).</a:documentation>
                  <data type="string"/>
                </attribute>
                <attribute name="east_west">
                  <data type="string"/>
                </attribute>
                <attribute name="north_south">
                  <data type="string"/>
                </attribute>
                <ref name="comment"/>
              </element>
            </choice>
          </element>
          <element name="wind_velocity">
            <a:documentation>Wind forcing with user specified 10m wind velocity</a:documentation>
            <element name="wind_drag_coefficient">
              <a:documentation>Specify wind drag coefficient (dimensionless)
Suggested value: 4.0e-4</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="density_air">
              <a:documentation>Density of air. 

&lt;b&gt;Note that you have to specify
this density in the same units as the 
reference_density under equation of state.&lt;/b&gt;
So with a typicial value of rho_air=1.3 kgm^-3
and rho_water=1000 kgm^-3, if you fill in the 
recommended (non-dimensional) value of 1.0 for 
reference_density, this field needs to be 1.3e-3.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="wind_velocity">
              <a:documentation>Specify wind velocity</a:documentation>
              <choice>
                <ref name="input_choice_real_dim_minus_one_vector"/>
                <element name="from_netcdf">
                  <attribute name="file_name">
                    <a:documentation>The format of this file should conform to NetCDF CF 1.x
(http://cf-pcmdi.llnl.gov/)</a:documentation>
                    <data type="string"/>
                  </attribute>
                  <attribute name="east_west">
                    <data type="string"/>
                  </attribute>
                  <attribute name="north_south">
                    <data type="string"/>
                  </attribute>
                  <ref name="comment"/>
                </element>
              </choice>
            </element>
          </element>
        </choice>
      </element>
      <element name="type">
        <a:documentation>When using control_volumes under Pressure
spatial_discretisation or when using
integrate_continuity_by_parts with continuous_galerkin
Pressure and continuous_galerkin Velocity this
boundary condition type imposes a weak no normal flow
boundary condition on the surface_ids specified.</a:documentation>
        <attribute name="name">
          <value>no_normal_flow</value>
        </attribute>
        <empty/>
      </element>
      <element name="type">
        <a:documentation>Implements a penalty function for the near wall region.
Using this option coarse meshes can
be used in the near wall region.

Should be used in combination with a no_normal_flow condition. 

See Bazilevs et al. 2007</a:documentation>
        <attribute name="name">
          <value>near_wall_treatment</value>
        </attribute>
        <element name="tolerance">
          <ref name="real"/>
        </element>
        <optional>
          <element name="Cb">
            <a:documentation>if not set then Cb=2*h, where h is the element size</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="type">
        <a:documentation>Log law of the wall

Should be used in combination with a no_normal_flow condition. </a:documentation>
        <attribute name="name">
          <value>log_law_of_wall</value>
        </attribute>
        <element name="surface_roughness">
          <ref name="real"/>
        </element>
      </element>
      <element name="type">
        <a:documentation>Dummy BC

Should be used in combination with the near_wall_treatment condition.
When activated wall treatment is not applied on the wall-outflow edge.</a:documentation>
        <attribute name="name">
          <value>outflow</value>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_scalar_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="convergence_file">
          <a:documentation>Output a file details the convergence (or otherwise) of
this field with every advective nonlinear
iteration.
ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for pressure (can't have a convergence file) -->
  <define name="pressure_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="debugging_vtus">
          <a:documentation>Write out some extra debugging vtu files that can be used
to analyse what goes on in the pressure projection steps.
WARNING: this may create a huge amount of vtu files, as 
multiple files are written per nonlinear iteration.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_vector_output_options">
    <element name="output">
      <a:documentation>Specify what is written to dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field
on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field
used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Field output options for all other fields -->
  <define name="field_output_options">
    <element name="output">
      <a:documentation>Specify what is written to dump files.</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="field_output_options_disabled">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files.</a:documentation>
      <choice>
        <element name="exclude_from_vtu">
          <a:documentation>Exclude this field from dump files.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_vtu">
          <a:documentation>Include this field in dump files.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <define name="diagnostic_output_options">
    <ref name="field_output_options"/>
  </define>
  <define name="prescribed_output_options">
    <ref name="field_output_options"/>
  </define>
  <!--
    Options for inclusion/exclusion of standard field statistics from the .stat
    file
  -->
  <define name="include_stat">
    <element name="include_in_stat">
      <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_components_from_stat">
    <element name="exclude_components_from_stat">
      <a:documentation>Include just the magnitude of this field in the .stat file
(excluding the components)</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for scalar fields -->
  <define name="prognostic_scalar_stat_options.stat">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_scalar_stat_options.stat" combine="interleave">
    <optional>
      <element name="include_previous_time_step">
        <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
    <optional>
      <element name="include_nonlinear_field">
        <a:documentation>Enable to include the values of this field in the nonlinear
iteration in the .stat file.</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options.stat">
    <optional>
      <ref name="exclude_stat"/>
    </optional>
    <optional>
      <ref name="cv_stats"/>
    </optional>
    <zeroOrMore>
      <ref name="surface_integral_stats_scalar"/>
    </zeroOrMore>
    <zeroOrMore>
      <ref name="mixing_stats"/>
    </zeroOrMore>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <ref name="include_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_enabled_default" combine="choice">
    <ref name="exclude_stat"/>
  </define>
  <!-- Diagnostic statistics options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <ref name="exclude_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="exclude_components_from_stat"/>
  </define>
  <define name="vector_field_stat_options_disabled_default" combine="choice">
    <ref name="include_stat"/>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_velocity_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_velocity_stat_options.stat"/>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- Combining of stat elements for vector fields -->
  <define name="prognostic_velocity_stat_options.stat">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options.stat"/>
  </define>
  <define name="prognostic_velocity_stat_options.stat" combine="interleave">
    <element name="previous_time_step">
      <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <element name="nonlinear_field">
      <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
      <ref name="vector_field_stat_options_disabled_default"/>
    </element>
    <optional>
      <element name="compute_body_forces_on_surfaces">
        <a:documentation>What surface IDs do you want to do the calculation over?</a:documentation>
        <optional>
          <element name="output_terms">
            <a:documentation>Enable to output the pressure and viscous terms separately (as well
as the total force)</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="calculate_momentum_conservation_error">
        <a:documentation>Calculate the error in the conservation of momentum
IN PROGRESS - Does not include all terms!</a:documentation>
        <empty/>
      </element>
    </optional>
  </define>
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options.stat">
    <ref name="vector_field_stat_options_enabled_default"/>
    <zeroOrMore>
      <ref name="surface_integral_stats_vector"/>
    </zeroOrMore>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field 
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state options for prognostic scalar fields -->
  <define name="scalar_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field in steady state testing
(if /timestepping/steady_state is
enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field from steady state testing</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Steady state statistics options for prognostic vector fields (velocity) -->
  <define name="vector_steady_state_options">
    <element name="steady_state">
      <a:documentation>Decide whether this field is tested for a steady state
between timesteps
(if /timestepping/steady_state is
enabled).</a:documentation>
      <choice>
        <element name="include_in_steady_state">
          <a:documentation>Include this field (magnitude and components)
in steady state testing
(if /timestepping/steady_state is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_steady_state">
          <a:documentation>Include just the magnitude of this field 
in steady state testing
(if /timestepping/steady_state is
enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_steady_state">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_enabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Options for whether a field is to be included in detector output. -->
  <define name="detector_options_disabled_default">
    <element name="detectors">
      <a:documentation>Specify what is added to detector files</a:documentation>
      <choice>
        <element name="exclude_from_detectors">
          <a:documentation>This field is not output at detector locations.</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="include_in_detectors">
          <a:documentation>This field is output at each detector location.</a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!--
    Detector output defaults on for prognostic and diagnostic fields, 
    off for prescribed.
  -->
  <define name="prognostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="diagnostic_detector_options">
    <ref name="detector_options_enabled_default"/>
  </define>
  <define name="prescribed_detector_options">
    <ref name="detector_options_disabled_default"/>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <!-- Most common mesh choices -->
  <define name="mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
    </choice>
  </define>
  <!--
    Not really a choice, for fields that have to be on the velocity mesh
    currently that's all scalar fields, except pressure
    and of course velocity itself
    If you want to implement scalar fields on other meshes, feel free to do so
    but bare in mind you need to make sure the field stays outside RMEM.
    Currently all scalar fields are packed in RMEM with length nonods
  -->
  <define name="velocity_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <define name="pressure_mesh_choice">
    <choice>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="scalar_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to prescribed, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Salinity</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Salinity</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 42</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Temperature</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -1</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundTemperature</value>
        </attribute>
        <element name="prescribed">
          <ref name="velocity_mesh_choice"/>
          <ref name="prescribed_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 666</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Free Surface
NOTE: if you are using the free_surface boundary condition
applied to the Velocity field (recommended), you should not 
use the prognostic FreeSurface field. In this case you may 
(optionally) add a diagnostic FreeSurface field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FreeSurface</value>
        </attribute>
        <element name="diagnostic">
          <a:documentation>Free Surface
NOTE: the diagnostic FreeSurface field only works in combination
with the free_surface boundary condition applied to the Velocity
field. It gives you a 3D field (constant over the vertical)
of the free surface elevation.</a:documentation>
          <ref name="internal_algorithm"/>
          <!--
            this is hard-coded on the PressureMesh as long as the Pressure is
            if this is no longer true, it should be option-checked to be on the
            same mesh as Pressure
          -->
          <element name="mesh">
            <a:documentation>Must be on the same mesh as Pressure</a:documentation>
            <attribute name="name">
              <value>PressureMesh</value>
            </attribute>
          </element>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Second Fluid</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SecondFluid</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 56</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffuse Interface</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffuseInterface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 57</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BalancePressure</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -2003</value>
        </attribute>
        <element name="prognostic">
          <!--
            Note the assumptions about quadratic/linear below and hard-coding
            of the mesh, this is because of restrictions of the
            current code, will change in the near future.
          -->
          <element name="mesh">
            <a:documentation>Note that this is not the quadratic mesh balance pressure is
actually calculated on, but the linear mesh it is projected back
on for output purposes.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <ref name="prognostic_balance_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>If enabled, decomposes Pressure by solving for the balanced part of 
Pressure using a "geopressure" solver:

  f = - grad p_gp + g

By choosing an appropriate mesh (typically velocity mesh order + 1)
for the balanced part of pressure, physical balance can be
represented to a higher degree of accuracy.

Expanded BalancePressure field. As BalancePressure, but with
additional options, including the ability to choose a general
mesh for the geopressure solver.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GeostrophicPressure</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -2003</value>
        </attribute>
        <element name="prognostic">
          <element name="mesh">
            <a:documentation>The GeostrophicPressure mesh. Must be continuous.

&lt;b&gt;WARNING: It is usual for this to be a higher degree
mesh than the velocity mesh&lt;/b&gt;</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
          <ref name="prognostic_geostrophic_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HydrostaticPressure</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice">
            <a:documentation>This needs to be a DG mesh</a:documentation>
          </ref>
          <ref name="prognostic_vertical_balance_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialVolumeFraction field:

Volume fraction of this material.
Required in multimaterial simulations.
 - if prognostic solves for the volume fraction
 - if prescribed uses a specified volume fraction
 - if diagnostic solves for the final material volume fraction
Only 1 diagnostic MaterialVolumeFraction field allowed per
simulation or solves for all the volume fractions based on
the SumMaterialVolumeFractions field.

A diagnostic MaterialVolumeFraction field is currently required for
compressible multimaterial simulations (even if only 1 material).
Generally also requires a MaterialDensity field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
            <optional>
              <ref name="surface_tension_option"/>
            </optional>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
            <optional>
              <ref name="cap_option"/>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialDensity field:

Field for the density of this material.
Required in multimaterial simulations.
 - prescribed if an incompressible simulation
 - diagnostic if using a linear equation of state
 - prognostic if a compressible simulation
(note that if you set a multimaterial
equation of state and this field is
prognostic then its initial condition
will be overwritten by the density that
satisfies the initial pressure and
the equation of state)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialDensity</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialInternalEnergy field:

Field for the internal energy of this material.
Required in multimaterial compressible simulations
with full miegrunneisen (perfect gas) eos.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialInternalEnergy</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>InternalEnergy field:

Field for the internal energy of a single material.
Required in compressible simulations
with full miegrunneisen (perfect gas) eos.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>InternalEnergy</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>SumMaterialVolumeFractions field:

Sums the prognostic MaterialVolumeFraction fields.
- diagnostic: sums all the volume fractions in the other
  material phases</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SumMaterialVolumeFractions</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CopiedField - This field copies the previous timesteps
values from another (specified) field at every iteration
and then solves the field using different (again, specified)
scheme and solution options.
For instance, this field can be used to create a diffused
field to adapt to.
Unless someone requests otherwise this is only currently possible
for fields within the same material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopiedField</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <attribute name="copy_from_field">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the stream function of 2D incompressible flow. Note 
that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
Requires a continuous mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>StreamFunction</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_stream_function_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Phytoplankton</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Phytoplankton</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Zooplankton</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Zooplankton</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Nutrient</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Nutrient</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Detritus</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Detritus</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>PhaseVolumeFraction:
Required in porous_media problem type</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhaseVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Electrical Potential:
Required in electrokinetic, electrothermal
and electrochemical problems
(sub-option of porous_media problem type)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ElectricalPotential</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DistanceToSideBoundaries</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -144</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PerturbationDensity</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -143</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the control volume C^T matrix.
This assumes that the test space is discontinuous
control volumes.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>FiniteElementDivergence:

div field

Divergence of the velocity field where
the divergence operator is defined using
the finite element C^T matrix.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_fe_divergence_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffusive dissipation</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffusiveDissipation</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Viscous dissipation</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ViscousDissipation</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Richardson Number:

 Ri = \frac{N^2}{(\frac{\partial u}{\partial z})^2 + (\frac{\partial u}{\partial z})^2}
with 
 N^2 = -\frac{g}{\rho_0}\frac{\partial \rho}{\partial z}

Limitations:
 - Gravity must be constant.
 - Assumes gravity is in -ve final coordinate direction.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>RichardsonNumber</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_richardson_number_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -601</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>DG_CourantNumber

Courant Number as defined on a DG mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DG_CourantNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Discontinuity detector

takes value 1 where detector is triggered

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiscontinuityDetector</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CVMaterialDensityCFLNumber

Courant Number as defined on a control volume mesh and
incorporating the MaterialDensity.
Requires a MaterialDensity field!

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidConcentration</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>This scalar field is meant to replace DENTRAF.
Basically, if you use new options, DENTRAF is no longer needed
No repointing is done from this field to DENTRAF.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopyofDensity</value>
        </attribute>
        <attribute name="replaces">
          <value>DENTRAF</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
Visualize the solids and MaterialVolumeFraction together</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeSolidFluid</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
Visualize the solid_Concentration</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeSolid</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
map  the solid_Concentration from particle mesh to 
the fluid mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ParticleScalar</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Explicit_ALE to 
visualize functional values before iterations start.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalBegin</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Explicit_ALE to 
visualize functional values at each iteration.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalIter</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialVolume scalar_field to calculate the spatially varying 
volume of a material (requires a MaterialVolumeFraction)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolume</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialMass scalar_field to calculate the spatially varying 
mass of a material (requires a MaterialVolumeFraction and a MaterialDensity)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialMass</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the MaterialDensity based on the bulk Pressure
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialEOSDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the MaterialPressure based on the MaterialDensity
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the BulkMaterialPressure based on the MaterialDensity
and MaterialVolumeFraction (and MaterialInternalEnergy if appropriate) 
for the equation of state of all materials.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BulkMaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grid Reynolds number</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridReynoldsNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>GridPecletNumber

Peclet Number Pe = U*dx/2*diffusivity

Also see the test case 'grid_peclet_number'
if you wish to see the effect of changing the 
diffusivity on a 1D, cg-discretised tracer-field

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GridPecletNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice">
              <a:documentation>Mesh on which to calculate dx</a:documentation>
            </ref>
            <element name="field_name">
              <a:documentation>This is the name of the scalar field
to calculate the Peclet number for
Note this field needs to have a diffusivity</a:documentation>
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Horizontal velocity divergence:

div_H velocity

Uses the gravity field direction to determine the horizontal plane.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalVelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Velocity divergence:

div velocity
</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Vorticity for a 2D field:

 du   dv
 -- - --
 dy   dx</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity2D</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Kinetic energy density:

 1/2 rho_0*|u|^2

where rho_0 is the (reference) density 

Limitations:
 - The Density, PerturbationDensity, KineticEnergyDensity and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>KineticEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Gravitational potential energy density:

rho_0*(1.0 + rho')*(g dot (r - r_0))

where rho_0 is the (reference) density, rho' is the perturbation density and r_0 is the potential energy zero point.

Limitations:
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GravitationalPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <element name="zero_point">
              <a:documentation>Coordinate of a point with a potential energy of zero.</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Isopycnal coordinate

 z_star(x,t) = 1/A int_V' H(rho(x',t)-rho(x,t)) dV'

where rho is the density, A is the width/area of the domain

Limitations:
 - You need to specify a (fine) mesh to redistribute the PerturbationDensity onto
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>IsopycnalCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="fine_mesh">
              <a:documentation>This is the mesh onto which we redistribute the PerturbationDensity</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Background potential energy density:

PE_b = rho*z_star

where rho is the density, z_star is the isopycnal coordinate

Limitations:
 - Requires a constant gravity direction.
 - The Density, PerturbationDensity and
 GravitationalPotentialEnergyDensity fields must be on the
 same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BackgroundPotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Ertel potential vorticity:

 (f + curl u) dot grad rho'

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PotentialVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Relative potential vorticity:

  curl u dot grad rho'</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>RelativePotentialVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity,PerturbationDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Local average mesh edge lengths</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeshEdgeLengths</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="scalar_edge_lengths_algorithm"/>
            <element name="mesh">
              <attribute name="name">
                <value>CoordinateMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the horizontal stream function psi where:
  \partial_x \psi = -v
  \partial_y \psi = u
where u and v are perpendicular to the gravity direction. Applies a
strong Dirichlet boundary condition of 0 on all boundaries.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalStreamFunction</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="solver">
              <a:documentation>Solver</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Speed:

 |u|

Limitations:
 - The Speed and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Speed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Volume of the vehicles

used in Traffic Modelling</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidPhase</value>
        </attribute>
        <attribute name="raplaces">
          <value>IDENT = -42</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Absolute Difference between two scalar fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ScalarAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <optional>
              <element name="relative_to_average">
                <a:documentation>Evaluate the absolute difference once the average difference has been removed?</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="ignore_boundaries">
                <a:documentation>Ignore boundary nodes (i.e. zero them when calculating the difference)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Primary production of Phytoplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PrimaryProduction</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Grazing of Phytoplankton by Zooplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PhytoplanktonGrazing</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalRange</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -32</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field_tidal_range"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxFreeSurface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -33</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MinFreeSurface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -34</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeM2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseM2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeS2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseS2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeN2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseN2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeK2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseK2</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeK1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseK1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeO1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseO1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeP1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseP1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeQ1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseQ1</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeMf</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseMf</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeMm</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseMm</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicAmplitudeSSa</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the universal numbering of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>UniversalNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the nodes of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodeOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Output the processors which own the elements of the mesh on which this field is based.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ElementOwner</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Primary production of Phytoplankton. This is calculated by
the ocean biology module and will not be calculated unless
ocean biology is being simulated.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicPhaseSSa</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic vector fields are not possible (other than velocity and those known fields below).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="vector_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - List of fields that are primarily prognostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prognostic_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        
        - - List of fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>MaterialVelocity field.  Used to impose a velocity on a material
in combination with the imposed_material_velocity_absorption_algorithm
for VelocityAbsorption and imposed_material_velocity_source_algorithm 
for VelocitySource.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVelocity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Temperature gradient</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>TemperatureGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Gradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the C gradient
matrix constructed using finite elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_gradient_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T divergence matrix constructed using finite
elements.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FiniteElementDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <optional>
              <element name="integrate_divergence_by_parts">
                <empty/>
              </element>
            </optional>
            <ref name="diagnostic_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Relative vorticity field - curl of the velocity field</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <!--
              element algorithm {
                attribute name { "curl" },
                attribute material_phase_support { "single" },
                attribute source_field_name { "Velocity" }
              },
            -->
            <element name="mesh">
              <a:documentation>Relative vorticity</a:documentation>
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Planetary vorticity

Limitations:
 - Requires geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>PlanetaryVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute vorticity:

  f + curl u

Limitations:
 - Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteVorticity</value>
        </attribute>
        <attribute name="depends">
          <value>Velocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Gradient of a scalar field evaluated using the transpose
of the C^T matrix constructed using control volumes.
Field must be in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeDivergenceTransposed</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_cv_gradient_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Solid Velocity field.  Used to generate the momentum source </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>UTRAF,VTRAF,WTRAF</value>
        </attribute>
        <attribute name="name">
          <value>SolidVelocity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ParticleVector</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ParticleForce</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>SolidForce</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VelocityPlotForSolids</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Same as Solid Velocity field but it is on the Particle mesh.
It is used to map the velocities coming from an external program like
FEMDEM or DEM to the fluid mesh. </a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>FunctionalGradient</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>LinearMomentum field.
 p = \rho*u 
(where p is the linear momentum, \rho the density and u the velocity)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>LinearMomentum</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the control volume auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeAuxiliaryGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <attribute name="gradient_of_field">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Calculate the dg (Bassi Rebay) auxiliary gradient for a particular field.
The related field must be a scalar field in this material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DGAuxiliaryGradient</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <attribute name="gradient_of_field">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Experimental geostrophic source field to be used in combination with
a free surface. Does not solve a vertical balance yet.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GeostrophicSource</value>
        </attribute>
        <element name="diagnostic">
          <ref name="internal_algorithm"/>
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute Difference between two vector fields.

Both fields must be in this material_phase.
Assumes both fields are on the same mesh as the AbsoluteDifference field.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>VectorAbsoluteDifference</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <attribute name="field_name_a">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <attribute name="field_name_b">
              <data type="string" datatypeLibrary=""/>
            </attribute>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Bed Shear Stress = density*drag_coeff*|u|*u

at the moment this assumes the density and drag coefficients are constants.
This diagnostic vector field is only calculated over surface elements/nodes, 
interior nodes will have zero value.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>BedShearStress</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field_bed_shear_stress"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Max Bed Shear Stress.

Note that you need BedShearStress turned on for this to work.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>MaxBedShearStress</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <group>
              <ref name="internal_algorithm"/>
              <ref name="velocity_mesh_choice"/>
            </group>
            <!-- diagnostic_vector_field_max_bed_shear_stress -->
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
        <element name="spin_up_time">
          <a:documentation>This is the time after which the max operator is
applied to the bed shear stress.</a:documentation>
          <ref name="real"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Coordinate field remapped to the mesh of your choice.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>DiagnosticCoordinate</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Displacement</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Displacement</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Galerkin projection of one field onto another mesh.

The field must be in this material_phase.

NOTE: you need the solver options if the mesh
of this field is continuous.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>GalerkinProjection</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <element name="source_field_name">
              <data type="string" datatypeLibrary=""/>
            </element>
            <ref name="mesh_choice"/>
            <optional>
              <element name="lump_mass">
                <a:documentation>Lump the mass matrix of the galerkin projection
less accurate but faster and might give smoother result.                  </a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="solver">
                <ref name="linear_solver_options_sym"/>
              </element>
            </optional>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Computes the buoyancy term</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Buoyancy</value>
        </attribute>
        <element name="diagnostic">
          <ref name="buoyancy_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Projects the Coriolis term onto the mesh of this diagnostic field.
Note that multiple projection methods are available (under the
algorithm option).</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Coriolis</value>
        </attribute>
        <element name="diagnostic">
          <ref name="coriolis_algorithm"/>
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
      <element name="vector_field">
        <a:documentation>Compute the imbalanced component of velocity,
that is,
u - u_bal
where u_bal is the velocity that puts the state in geostrophic
balance.
Note: if your VelocityMesh is continuous, then the solver option
is necessary.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>ImbalancedVelocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <element name="solver">
              <ref name="linear_solver_options_sym"/>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Compute the balanced component of velocity,
that is, the velocity that puts the state in geostrophic
balance.
This diagnostic depends on ImbalancedVelocity.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>BalancedVelocity</value>
        </attribute>
        <attribute name="depends">
          <value>ImbalancedVelocity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="internal_algorithm"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, which may be used for any user-defined field
      that FLUIDITY knows nothing about, or a generic diagnostic
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
          <element name="diagnostic">
            <ref name="tensor_diagnostic_algorithms"/>
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="tensor_field">
        <a:documentation>MaterialViscosity field:

Field for the viscosity of this material.
Required if using a diagnostic bulk viscosity
in a multimaterial simulation.</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>MaterialViscosity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       internal_algorithm,
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <define name="mesh_info">
    <choice>
      <element name="from_file">
        <a:documentation>Read mesh from file.</a:documentation>
        <choice>
          <element name="format">
            <a:documentation>Triangle mesh format.

Enter the base name without the .edge .ele, .face or
.node extensions, and without process numbers.</a:documentation>
            <attribute name="name">
              <value>triangle</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="format">
            <a:documentation>Read the mesh from a vtu. Note that the mesh will have no surface
or region IDs.</a:documentation>
            <attribute name="name">
              <value>vtu</value>
            </attribute>
            <ref name="comment"/>
          </element>
          <element name="format">
            <a:documentation>CGNS mesh format (not yet implemented)</a:documentation>
            <attribute name="name">
              <value>cgns</value>
            </attribute>
            <ref name="comment"/>
          </element>
        </choice>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <ref name="from_file_mesh_stat_options"/>
        <ref name="comment"/>
      </element>
      <element name="from_mesh">
        <a:documentation>Make mesh from existing mesh. </a:documentation>
        <ref name="mesh_choice"/>
        <optional>
          <element name="mesh_shape">
            <element name="polynomial_degree">
              <ref name="integer"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="mesh_continuity">
            <element name="string_value">
              <choice>
                <value>continuous</value>
                <value>discontinuous</value>
              </choice>
            </element>
          </element>
        </optional>
        <zeroOrMore>
          <element name="periodic_boundary_conditions">
            <a:documentation>Make mesh periodic</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <element name="physical_boundary_ids">
              <a:documentation>List of boundary ids that are aliased to</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="aliased_boundary_ids">
              <a:documentation>List of boundary ids that are aliased</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="coordinate_map">
              <a:documentation>Python code which takes coordinate of an aliased
boundary node and returns the coordinate of a physical
boundary node</a:documentation>
              <ref name="python_code"/>
            </element>
            <optional>
              <element name="remove_periodicity">
                <a:documentation>&lt;b&gt;Don't turn this on by hand!&lt;/b&gt;
This option gets set by the periodise tool, to indicate
that this mesh should have the periodic boundary conditions
&lt;b&gt;removed&lt;/b&gt;. See the discussion on the wiki about 
parallel periodic boundary conditions.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </zeroOrMore>
        <optional>
          <element name="extrude">
            <a:documentation>Extrude a horizontal (1D or 2D) mesh in the vertical</a:documentation>
            <element name="bottom_depth">
              <a:documentation>Depth over which to extrude
top will be at z=0
bottom will be at z=-bottom_depth</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <element name="sizing_function">
              <a:documentation>Constant or function to specify the depth of the
layers. The function is a function of all coordinates
(so in 2+1D: x,y and z) to specify a layer depth that
varies both in the horizontal as in the vertical.</a:documentation>
              <ref name="input_choice_real"/>
            </element>
            <optional>
              <element name="top_surface_id">
                <a:documentation>surface_id to assign to the top of the extruded mesh</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="bottom_surface_id">
                <a:documentation>surface_id to assign to the bottom of the extruded mesh</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
        </optional>
        <ref name="derived_mesh_stat_options"/>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- Options for inclusion/exclusion of mesh statistics from the .stat file -->
  <define name="include_mesh_in_stat">
    <element name="include_in_stat">
      <a:documentation>Include this mesh in the .stat file</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="exclude_mesh_from_stat">
    <element name="exclude_from_stat">
      <a:documentation>Exclude this mesh from the .stat file</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for meshed, with enabled by default -->
  <define name="mesh_stat_options_enabled_default">
    <ref name="include_mesh_in_stat"/>
  </define>
  <define name="mesh_stat_options_enabled_default" combine="choice">
    <ref name="exclude_mesh_from_stat"/>
  </define>
  <!-- Diagnostic statistics options for meshed, with disabled by default -->
  <define name="mesh_stat_options_disabled_default">
    <ref name="exclude_mesh_from_stat"/>
  </define>
  <define name="mesh_stat_options_disabled_default" combine="choice">
    <ref name="include_mesh_in_stat"/>
  </define>
  <define name="from_file_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_enabled_default"/>
    </element>
  </define>
  <define name="derived_mesh_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="mesh_stat_options_disabled_default"/>
    </element>
  </define>
  <define name="input_choice_tensor_field">
    <choice>
      <element name="isotropic">
        <a:documentation>An isotropic tensor, i.e.
one with no directional variation.
Can be represented as a scalar real.</a:documentation>
        <ref name="input_choice_real"/>
      </element>
      <element name="diagonal">
        <a:documentation>A diagonal tensor, i.e.
one with only diagonal nonzero entries.
Can be represented as a vector real.</a:documentation>
        <ref name="input_choice_real_dim_vector"/>
      </element>
      <element name="anisotropic_symmetric">
        <a:documentation>A symmetric tensor, i.e.
A^T = A</a:documentation>
        <ref name="input_choice_real_dim_symmetric_tensor"/>
      </element>
      <element name="anisotropic_asymmetric">
        <a:documentation>A general asymmetric tensor.</a:documentation>
        <ref name="input_choice_real_dim_tensor"/>
      </element>
    </choice>
  </define>
  <define name="region_ids">
    <optional>
      <element name="region_ids">
        <a:documentation>Optional region ids to associate different values
to different regions of the mesh.
Leave unselected if you`re not using multiple regions or
region_ids.
Currently only works with triangle files created by gmsh2triangle.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="temporal_control_volume_options">
    <element name="control_volumes">
      <a:documentation>Temporal discretisation options that are only relevant if a control volume or coupled_cv spatial discretisation is selected for this field.</a:documentation>
      <optional>
        <element name="number_advection_iterations">
          <a:documentation>Number of iterations within an advection solve.
This increases the accuracy of the face values and ensures that
the pivoted solution is cancelled out.
Defaults to 1 if unselected.</a:documentation>
          <attribute name="replaces">
            <value>INT(ABS(NDISOT)/10)</value>
          </attribute>
          <ref name="integer"/>
          <optional>
            <element name="tolerance">
              <a:documentation>Cut short advection_iterations if the specified tolerance
is reached.
This only works for pure control volume discretisations.</a:documentation>
              <ref name="real"/>
              <choice>
                <element name="infinity_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The infinity norm.</a:documentation>
                  <empty/>
                </element>
                <element name="l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm.</a:documentation>
                  <empty/>
                </element>
                <element name="cv_l2_norm">
                  <a:documentation>Select the norm with which you want the tolerance to be tested.

The l2 norm evaluated on a control volume mesh.</a:documentation>
                  <empty/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <choice>
          <element name="maximum_courant_number_per_subcycle">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.
This only works for pure control volume discretisations.</a:documentation>
            <ref name="real"/>
            <ref name="field_based_cfl_number_options"/>
          </element>
          <element name="number_advection_subcycles">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.
This only works for pure control volume discretisations.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
      </optional>
      <optional>
        <element name="limit_theta">
          <a:documentation>Only works if a control volume or coupled_cv spatial discretisation is selected.
If not active then the theta specified above will be used.
Otherwise use variable limited theta on individual faces.</a:documentation>
          <attribute name="replaces">
            <value>MOD(INT(ABS(NDISOT)/1),10) = 1,3,5,7,9 (odd)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="pivot_theta">
          <a:documentation>Only works if a control volume or coupled_cv spatial discretisation is selected.
Time discretisation of upwind discretisation off which the
higher order solution is pivotted.
 - pivot_theta = 1 - implicit pivot (default if not set and 
                     best choice if not intentionally modifying
                     scheme to be explicit)
 - pivot_theta = 0 - explicit pivot</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="temporal_discontinuous_galerkin_options">
    <element name="discontinuous_galerkin">
      <a:documentation>This enables DG-specific timestepping options, such as
explicit advection subcycling. </a:documentation>
      <optional>
        <choice>
          <element name="maximum_courant_number_per_subcycle">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.</a:documentation>
            <ref name="real"/>
          </element>
          <element name="number_advection_subcycles">
            <a:documentation>Use timestep subcycling to solve this equation.
Specify the number of subcycles.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
      </optional>
    </element>
  </define>
  <define name="pure_cv_options">
    <element name="control_volumes">
      <a:documentation>Use a pure control volume discretisations.
Follows a new control volume code path.</a:documentation>
      <ref name="spatial_control_volume_options"/>
      <choice>
        <element name="diffusion_scheme">
          <a:documentation>Use the gradient of the field constructed using the
basis functions of the parent finite element mesh to
form the divergence.

DOES NOT CURRENTLY WORK WITH ROBIN OR WEAK DIRICHLET BOUNDARY CONDITIONS!

Based on schemes in Handbook of Numerical Analysis,
P.G. Ciarlet, J.L. Lions eds, vol 7, pp 713-1020</a:documentation>
          <attribute name="name">
            <value>ElementGradient</value>
          </attribute>
        </element>
        <element name="diffusion_scheme">
          <a:documentation>Use an auxiliary gradient equation to find the gradient of the field.

DOES NOT CURRENTLY WORK WITH ROBIN BOUNDARY CONDITIONS!

Based on scheme proposed in Bassi, F. &amp; Rebay, S., A
high-order accurate discontinuous finite element method
for the numerical solution of the compressible
Navier-Stokes equations, Journal Of Computational
Physics, 1997, 131, 267-279</a:documentation>
          <attribute name="name">
            <value>BassiRebay</value>
          </attribute>
        </element>
      </choice>
    </element>
  </define>
  <define name="coupled_cv_options">
    <element name="coupled_cv">
      <a:documentation>Use a pure control volume discretisations with face value
restrictions between different fields in different material_phases.

THIS DOES NOT WORK WITH DIFFUSION!

Follows a new control volume code path.</a:documentation>
      <ref name="coupled_spatial_control_volume_options"/>
      <element name="parent_sum">
        <a:documentation>Set the maximum and minimum bounds for the sum up to and including this field.
This defines the limiter used to enforce boundedness on this field.</a:documentation>
        <element name="target_maximum">
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <ref name="real"/>
        </element>
      </element>
    </element>
  </define>
  <define name="spatial_control_volume_options">
    <ref name="standard_control_volume_options"/>
  </define>
  <define name="spatial_control_volume_options" combine="choice">
    <ref name="compressive_control_volume_options"/>
  </define>
  <define name="standard_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>First Order Upwind face value discretisation
 face_value = donor_value, 
where
 donor_value = income*val_1 + (1.-income)*val_2, 
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
        <attribute name="name">
          <value>FirstOrderUpwind</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 0,1</value>
        </attribute>
        <empty/>
      </element>
      <element name="face_value">
        <a:documentation>Trapezoidal face value discretisation
 face_value = 0.5*(val_1 + val_2), 
where
 val_i is the value on the ith node neighbouring the face

Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
        <attribute name="name">
          <value>Trapezoidal</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 2,3</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Finite Element face value discretisation
 face_value = finite element interpolation from surrounding nodes

Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
        <attribute name="name">
          <value>FiniteElement</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 4,5,6,7</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>First Order Downwind face value discretisation
 face_value = downwind_value, 
where
 donor_value = (1.-income)*val_1 + income*val_2, 
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order downwinding is unconditionally unstable</a:documentation>
        <attribute name="name">
          <value>FirstOrderDownwind</value>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="coupled_spatial_control_volume_options">
    <ref name="coupled_control_volume_options"/>
  </define>
  <define name="coupled_spatial_control_volume_options" combine="choice">
    <ref name="compressive_control_volume_options"/>
  </define>
  <!--
    coupled control volume options are the same as the standard ones (annoyingly copied and pasted)
    except that firstorderupwind gets limiter options
  -->
  <define name="coupled_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>First Order Upwind face value discretisation
 face_value = donor_value, 
where
 donor_value = income*val_1 + (1.-income)*val_2, 
where val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
        <attribute name="name">
          <value>FirstOrderUpwind</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 0,1</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Trapezoidal face value discretisation
 face_value = 0.5*(val_1 + val_2), 
where
 val_i is the value on the ith node neighbouring the face

Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
        <attribute name="name">
          <value>Trapezoidal</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 2,3</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
      <element name="face_value">
        <a:documentation>Finite Element face value discretisation
 face_value = finite element interpolation from surrounding nodes

Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
        <attribute name="name">
          <value>FiniteElement</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 4,5,6,7</value>
        </attribute>
        <ref name="limiter_options"/>
      </element>
    </choice>
  </define>
  <define name="compressive_control_volume_options">
    <choice>
      <element name="face_value">
        <a:documentation>HyperC face value discretisation

face_value calculated from upper bound of explicit TVD zone of NVD diagram
Normally used for MaterialVolumeFraction fields</a:documentation>
        <attribute name="name">
          <value>HyperC</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 8,9</value>
        </attribute>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
      <element name="face_value">
        <a:documentation>UltraC face value discretisation

face_value calculated from extended upper bound of
explicit TVD zone of NVD diagram assuming
values bounded by target_maximum and target_minimum.</a:documentation>
        <attribute name="name">
          <value>UltraC</value>
        </attribute>
        <attribute name="replaces">
          <value>MOD(INT(ABS(NDISOT)/1),10) = 8,9, with ULTRAC = TRUE from solidity_options.inp</value>
        </attribute>
        <element name="target_maximum">
          <a:documentation>Specifiy the upper bound which UltraC will use to
calculate the maximum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <a:documentation>Specifiy the lower bound which UltraC will use to
calculate the minimum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
      <element name="face_value">
        <a:documentation>**UNDER TESTING**

PotentialUltraC face value discretisation

face_value calculated from extended upper bound of
explicit TVD zone of NVD diagram if potential
value of field is sufficient (as specified by
target_maximum) to ensure the correct front advection
velocity.

If not then either switch to HyperC or use a modified flux
based on the potential function.</a:documentation>
        <attribute name="name">
          <value>PotentialUltraC</value>
        </attribute>
        <element name="target_maximum">
          <a:documentation>Specifiy the upper bound which PotentialUltraC will use
to calculate the maximum flux if the potential function
value is sufficient to maintain the correct front
advection velocity.</a:documentation>
          <ref name="real"/>
        </element>
        <element name="target_minimum">
          <a:documentation>Specifiy the lower bound which PotentialUltraC will use to calculate the minimum flux.</a:documentation>
          <ref name="real"/>
        </element>
        <choice>
          <element name="switch_to_hyperc">
            <a:documentation>Select what PotentialUltraC should do if the
potential function value does not reach the required
value specified by the target_maximum.

Switch to using HyperC face values.  This ensures
that the advection velocity is correct however may
create isolated regions beneath the target_maximum.</a:documentation>
            <empty/>
          </element>
          <element name="use_potential_flux">
            <a:documentation>Select what PotentialUltraC should do if the
potential function value does not reach the required
value specified by the target_maximum.

Modify the maximum nodal values (both downwind and
upwind) so that the fluxes are at their maximum
possible without affecting the front advection
velocity.</a:documentation>
            <empty/>
          </element>
        </choice>
        <optional>
          <ref name="upwind_value_options"/>
        </optional>
        <ref name="cv_face_cfl_number_options"/>
      </element>
    </choice>
  </define>
  <!--
    Select the type of dynamic control to be used
    Note: DEM and FEMDEM require the respective libraries
    to be compiled.
  -->
  <define name="input_solid_dynamics_choice">
    <choice>
      <element name="dynamic_type">
        <a:documentation>Obtain values from point and radius file.

First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments. 
Following lines include 10 columns, corresponding to 
the particle's x, y, and z positions, followed by the radius, then
velocities in x, y, and z directions, followed by angular velocities
in the x, y, and z directions.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is tuple of position coords)
Third script is for particle translational velocity.
Fourth script is for particle angular velocity. (Note: particles 
have a no slip boundary condition at the surface, so this angular velocity
WILL matter to the flow.)
Python functions should be of the form:
 def val(X, t):
   Function code
   return # Return value
where X is a tuple of length geometry dimension.
   X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
      </element>
      <element name="dynamic_type">
        <attribute name="name">
          <value>use_simple_dynamics</value>
        </attribute>
        <element name="set_bottom">
          <ref name="real"/>
        </element>
        <element name="set_xmin">
          <ref name="real"/>
        </element>
        <element name="set_ymin">
          <ref name="real"/>
        </element>
        <element name="set_zmin">
          <ref name="real"/>
        </element>
        <element name="set_xmax">
          <ref name="real"/>
        </element>
        <element name="set_ymax">
          <ref name="real"/>
        </element>
        <element name="set_zmax">
          <ref name="real"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using y3D to model dynamics. Filename of input file for y3D must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_y3D</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 2D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_2Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 3D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_3Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="quad2lin">
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
        </element>
      </element>
    </choice>
  </define>
  <define name="cap_option">
    <element name="cap_values">
      <a:documentation>Cap the min and max values of this field when using
it as a volume fraction to work out bulk material
properties.
No capping used if not selected.</a:documentation>
      <optional>
        <element name="upper_cap">
          <a:documentation>Set the upper bound on the field.
Defaults to huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="lower_cap">
          <a:documentation>Set the lower bound on the field.
Defaults to -huge(0.0)*epsilon(0.0) if not set.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="surface_tension_option">
    <element name="surface_tension">
      <element name="surface_tension_coefficient">
        <a:documentation>Surface tension coefficient</a:documentation>
        <ref name="real"/>
      </element>
      <optional>
        <element name="equilibrium_contact_angle">
          <a:documentation>The equilibrium contact angle (in radians) with the boundaries identified by the surface ids</a:documentation>
          <ref name="real"/>
          <element name="surface_ids">
            <a:documentation>Surface ids:</a:documentation>
            <ref name="integer_vector"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
  <define name="limiter_options">
    <choice>
      <element name="limit_face_value">
        <a:documentation>Limit the face value to satisfy a boundedness criterion.</a:documentation>
        <choice>
          <ref name="sweby_limiter"/>
          <ref name="ultimate_limiter"/>
        </choice>
      </element>
      <element name="do_not_limit_face_value">
        <a:documentation>Do not limit the face value</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="sweby_limiter">
    <element name="limiter">
      <a:documentation>See "High-Resolution Schemes Using Flux Limiters for
Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
Journal on Numerical Analysis, 21, 995-1011</a:documentation>
      <attribute name="replaces">
        <value>MOD(INT(ABS(NDISOT)/1),10) = 2,3,4,5</value>
      </attribute>
      <attribute name="name">
        <value>Sweby</value>
      </attribute>
      <optional>
        <ref name="slope_options"/>
      </optional>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="ultimate_limiter">
    <element name="limiter">
      <a:documentation>See "The Ultimate Conservative Difference Scheme Applied
to Unsteady One-Dimensional Advection", B. P. Leonard,
1991, Computer Methods in Applied Mechanics and
Engineering, 88, 17-74</a:documentation>
      <attribute name="name">
        <value>Ultimate</value>
      </attribute>
      <ref name="field_based_cfl_number_options"/>
      <optional>
        <ref name="upwind_value_options"/>
      </optional>
    </element>
  </define>
  <define name="slope_options">
    <element name="slopes">
      <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
      <optional>
        <element name="lower">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="upper">
          <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="upwind_value_options">
    <choice>
      <element name="project_upwind_value_from_point">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

This method projects the upwind value from a point in the element just
upwind of the node pair straddling the face.  It is otherwise known as 
anisotropic limiting.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
        <attribute name="replaces">
          <value>NDISOT &gt; 0 on simplex meshes</value>
        </attribute>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="store_upwind_elements">
            <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
            <attribute name="replaces">
              <value>ABS(NDISOT) &gt;= 1000</value>
            </attribute>
            <optional>
              <element name="store_upwind_quadrature">
                <a:documentation>Store the quadrature locations within the elements
where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and
only saves a comparitively
marginal amount of time (as actually searching the
neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                <attribute name="replaces">
                  <value>ABS(NDISOT) &gt;= 1000</value>
                </attribute>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="project_upwind_value_from_gradient">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Projects the value of the advected variable from the downwind or donor node
using the interpolated gradient at the donor node in the
direction of the vector
connecting the node pair straddling the face.
This is available on all meshes (except if bounding the values).</a:documentation>
        <choice>
          <element name="project_from_downwind_value">
            <a:documentation>Select which node to project from:
Project from the downwind node (Jasak et al., 1999) so that:
upwind_value = downwind_value - 2*gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
          <element name="project_from_donor_value">
            <a:documentation>Select which node to project from:
Project from the donor node so that:
upwind_value = donor_value - gradient.vector</a:documentation>
            <ref name="comment"/>
          </element>
        </choice>
        <optional>
          <element name="reflect_off_domain_boundaries">
            <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="bound_projected_value_locally">
            <a:documentation>Constrain the projected value to be between the min and max of the
element values which surround it.
This is only available on simplex meshes as it involes a search around
the donor node to find the upwind element.</a:documentation>
            <optional>
              <element name="store_upwind_elements">
                <a:documentation>Store the locations of the elements closest to the project value.
This inserts an integer csr matrix into state so is
memory expensive but
saves a significant amount of time (searching around
the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
      </element>
      <element name="locally_bound_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.
Otherwise known as isotropic limiting.
This is available on all meshes.</a:documentation>
        <attribute name="replaces">
          <value>all cube elements, NDISOT &lt; 0 on simplex elements</value>
        </attribute>
        <empty/>
      </element>
      <element name="pseudo_structured_upwind_value">
        <a:documentation>Select the method to be used for calculating the upwind value.
If not selected will default to project_upwind_value_from_point for
simplex element meshes and to a locally_bound_upwind_value for cube
element meshes.

Chooses an upwind value by selecting the value at the node most directy
upwind from the vector connecting the donor and downwind nodes.
This is available on all meshes.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="field_based_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used.

This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.

This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="cv_face_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses a control volume definition of the CFL Number
that incorporates the MaterialDensity.
Requires a MaterialDensity field in this material_phase!</a:documentation>
        <attribute name="name">
          <value>CVMaterialDensityCFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <empty/>
      </element>
      <element name="courant_number">
        <a:documentation>***UNDER TESTING***

Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="timestep_cfl_number_options">
    <choice>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the finite element approximation of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the CFLNumber.</a:documentation>
        </ref>
      </element>
      <element name="courant_number">
        <a:documentation>Select the Courant Number definition to be used for adaptive timestepping.
This uses the control volume definition of the CFL Number.</a:documentation>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <ref name="velocity_mesh_choice">
          <a:documentation>Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.</a:documentation>
        </ref>
      </element>
    </choice>
  </define>
  <define name="mixing_stats">
    <element name="include_mixing_stats">
      <a:documentation>Enable to include in the .stat file the fractions of the
scalar field contained in
bins specified by the user. This allows mixing of the field to be quantified.
Replaces and expands upon the old heaviside.dat file</a:documentation>
      <attribute name="name">
        <data type="string"/>
      </attribute>
      <attribute name="replaces">
        <value>heaviside.dat file</value>
      </attribute>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).

NOTE: continuous_galerkin only works with linear tets

NOTE: continuous_galerkin is not fully validated yet</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be
divided by the total volume of the domain</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <a:documentation>Select whether to evaluate the volume fraction over the finite element
(continuous galerkin) or within the control volume (control_volumes).</a:documentation>
          <optional>
            <element name="normalise">
              <a:documentation>if select normalise the volume fractions will be divided by the total volume of the domain  </a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="mixing_bin_bounds">
        <a:documentation>The values of the bounds of the bins 
e.g. the values 0 1 2 3 will return 4 bins 
and the fraction of the field in each bin with,
0&lt;=field&lt;1, 1&lt;=field&lt;2, 2&lt;=field&lt;3, 3&lt;=field, 
will be calculated. </a:documentation>
        <ref name="real_vector"/>
      </element>
      <optional>
        <element name="tolerance">
          <a:documentation>Define the tolerance beneath the specified bins that should be included.
Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="cv_stats">
    <element name="include_cv_stats">
      <a:documentation>Include statistics evaluated on the control volume mesh.</a:documentation>
      <empty/>
    </element>
  </define>
  <!-- Options for inclusion of calculations of surface integrals in the .stat file   -->
  <define name="surface_integral_stats_base.surface_integral">
    <attribute name="name">
      <data type="string"/>
    </attribute>
    <optional>
      <element name="surface_ids">
        <a:documentation>Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
    <optional>
      <element name="normalise">
        <a:documentation>Enable to normalise the integral by dividing by the surface area</a:documentation>
        <ref name="comment"/>
      </element>
    </optional>
  </define>
  <define name="surface_integral_stats_scalar">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 value: Integrates the field
 gradient_normal: Integrates the normal component of the gradient of the field</a:documentation>
      <ref name="surface_integral_stats_scalar.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_scalar.surface_integral" combine="interleave">
    <attribute name="type">
      <choice>
        <value>value</value>
        <value>gradient_normal</value>
      </choice>
    </attribute>
  </define>
  <define name="surface_integral_stats_vector">
    <element name="surface_integral">
      <a:documentation>Surface integral calculations. The following integral types are available:
 normal: Integrates the normal component of the field</a:documentation>
      <ref name="surface_integral_stats_vector.surface_integral"/>
    </element>
  </define>
  <define name="surface_integral_stats_vector.surface_integral">
    <ref name="surface_integral_stats_base.surface_integral"/>
  </define>
  <define name="surface_integral_stats_vector.surface_integral" combine="interleave">
    <attribute name="type">
      <value>normal</value>
    </attribute>
  </define>
  <define name="forcing">
    <element name="ocean_forcing">
      <a:documentation>Add forcing from ocean data
If you enable this you MUST enable the /geometry/ocean_boundaries option too</a:documentation>
      <element name="input_file">
        <a:documentation>The netCDF data file downloaded from ERA-40 reanalysis</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh_choice">
        <ref name="velocity_mesh_choice"/>
      </element>
      <optional>
        <element name="surface_stress">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="temperature_flux">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="salinity_flux">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="solar_radiation">
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="position">
          <a:documentation>Adding a latitude and longitude here (specified as two real numbers)
will obtain data from the forcing file at that location. The
mesh is not translated nor is the mesh put on the sphere, instead the
specified lat/long is translated into cartesian coordinates and this is simply
added to the surface mesh node coordinates when fluxes are calculated.</a:documentation>
          <ref name="real_vector"/>
          <optional>
            <element name="single_location">
              <a:documentation>Turning on this option will cause all nodes on the surface mesh to
experience the same forcing, regardless of position. Only really
useful for psuedo-1D simulations.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="external_data_boundary_conditions">
          <a:documentation>Check this option to use an external data set for the t(0)
and in/out boundary conditions</a:documentation>
          <element name="input_file">
            <a:documentation>Path of the file containing the external data set</a:documentation>
            <attribute name="file_name">
              <data type="string"/>
            </attribute>
          </element>
        </element>
      </optional>
      <optional>
        <element name="output_fluxes_diagnostics">
          <a:documentation>Ouput some extra diagnostic fields for the momentum, temperature and salinity fluxes</a:documentation>
          <optional>
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>MomentumFlux</value>
              </attribute>
              <choice>
                <element name="diagnostic">
                  <ref name="internal_algorithm"/>
                  <ref name="velocity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="aliased">
                  <ref name="generic_aliased_field"/>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>HeatFlux</value>
              </attribute>
              <choice>
                <element name="diagnostic">
                  <ref name="internal_algorithm"/>
                  <ref name="velocity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="aliased">
                  <ref name="generic_aliased_field"/>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>SalinityFlux</value>
              </attribute>
              <choice>
                <element name="diagnostic">
                  <ref name="internal_algorithm"/>
                  <ref name="velocity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="aliased">
                  <ref name="generic_aliased_field"/>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>PhotosyntheticRadiationDownward</value>
              </attribute>
              <choice>
                <element name="diagnostic">
                  <ref name="internal_algorithm"/>
                  <ref name="velocity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="aliased">
                  <ref name="generic_aliased_field"/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
      </optional>
    </element>
  </define>
  <define name="biology">
    <element name="ocean_biology">
      <a:documentation>Model of biological processes in the ocean.</a:documentation>
      <choice>
        <element name="pznd">
          <a:documentation>A simple model of phytoplankton, zooplankton, general nutrient and detritus. </a:documentation>
          <choice>
            <element name="source_and_sink_algorithm">
              <a:documentation>Python code specifying the source and sink relationships 
between the biological tracers. This is usually achieved by 
importing fluidity.ocean_biology and calling a scheme from there. </a:documentation>
              <ref name="python_code"/>
            </element>
            <element name="disable_sources_and_sinks">
              <a:documentation>Do not calculate sources and sinks. 
This option is generally only useful for testing. </a:documentation>
              <empty/>
            </element>
          </choice>
          <element name="scalar_field">
            <a:documentation>Photosynthetically Active Radiation (PAR)</a:documentation>
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <attribute name="name">
              <value>PhotosyntheticRadiation</value>
            </attribute>
            <choice>
              <element name="prognostic">
                <ref name="velocity_mesh_choice"/>
                <ref name="prognostic_photosynthetic_radiation"/>
              </element>
              <element name="prescribed">
                <ref name="velocity_mesh_choice"/>
                <ref name="prescribed_scalar_field"/>
              </element>
            </choice>
          </element>
        </element>
        <element name="lagrangian_ensemble">
          <a:documentation>Lagrangian particle biology from the VEW project.</a:documentation>
          <choice>
            <element name="biology_algorithm">
              <a:documentation>Python code specifying the biology model. This takes
in velocity and light and outputs Phytoplankton, if
those fields exist.</a:documentation>
              <ref name="python_code"/>
            </element>
            <element name="disable_biology">
              <a:documentation>Do not calculate biology
This option is generally only useful for testing. </a:documentation>
              <empty/>
            </element>
          </choice>
          <optional>
            <element name="scalar_field">
              <a:documentation>Photosynthetically Active Radiation (PAR)</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>PhotosyntheticRadiation</value>
              </attribute>
              <choice>
                <element name="prognostic">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prognostic_photosynthetic_radiation"/>
                </element>
                <element name="prescribed">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
              </choice>
            </element>
          </optional>
        </element>
      </choice>
    </element>
  </define>
  <define name="prognostic_photosynthetic_radiation">
    <element name="equation">
      <a:documentation>PAR equation.</a:documentation>
      <attribute name="name">
        <value>PhotosyntheticRadiation</value>
      </attribute>
    </element>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <element name="discontinuous_galerkin">
        <a:documentation>Discontinuous galerkin formulation. You can also use this
formulation with a continuous field in which case a simple
galerkin formulation will result. </a:documentation>
        <empty/>
      </element>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options_asym"/>
    </element>
    <!-- Alas, no initial_condition either, so we'd better not checkpoint it... -->
    <element name="exclude_from_checkpointing">
      <a:documentation>Disables checkpointing of this field</a:documentation>
      <ref name="comment"/>
    </element>
    <element name="absorption_coefficients">
      <a:documentation>Coefficients of absorption of photosynthetically active
radiation for water and phytoplankton.</a:documentation>
      <element name="water">
        <a:documentation>Photosynthetically active radiation absorption coefficient for water.</a:documentation>
        <ref name="real"/>
      </element>
      <element name="phytoplankton">
        <a:documentation>Photosynthetically active radiation absorption coefficient for water.</a:documentation>
        <ref name="real"/>
      </element>
    </element>
    <optional>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <element name="apply_weakly">
              <a:documentation>Apply the dirichlet bc weakly.  Only available with
discontinuous_galerkin and control_volume
spatial_discretisations.

If not selected boundary conditions are applied strongly.</a:documentation>
              <empty/>
            </element>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>robin</value>
            </attribute>
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </choice>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="prognostic_detector_options"/>
    <ref name="scalar_steady_state_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <define name="recalculation_options">
    <element name="do_not_recalculate">
      <a:documentation>Prevent this field from being recalculated at every timestep.
This is cheaper especially if you are enforcing discrete properties on the field.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="discrete_properties_algorithm_scalar">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <element name="solenoidal_lagrange_update">
          <a:documentation>Update this field using the lagrangian multiplier
calculated in the solenoidal projection of a
scalar field.

Note this field must be specified as the update field
underneath that vector field too.

Note also this only really makes sense for coupled
fields like velocity and pressure.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="discrete_properties_algorithm_vector">
    <element name="enforce_discrete_properties">
      <a:documentation>Select discrete properties to enforce on the field
either after being prescribed or interpolated</a:documentation>
      <optional>
        <ref name="solenoidal_options"/>
      </optional>
    </element>
  </define>
  <define name="solenoidal_options">
    <element name="solenoidal">
      <a:documentation>Constrained divergence-free projection.
This adds an additional constraint that ensures that the field
is solenoidal, i.e. divergence-free.
This is equivalent in cost to a pressure solve.
This is expensive, and thus best left until
needed.

Note well: this only makes sense for nondivergent
vector fields, such as incompressible velocity!</a:documentation>
      <element name="interpolated_field">
        <a:documentation>Options for the mass matrix of the field being interpolated</a:documentation>
        <choice>
          <element name="continuous">
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)

Required when using interpolating continuous fields</a:documentation>
              <optional>
                <element name="use_submesh">
                  <a:documentation>Lump on the submesh.
This only works for simplex meshes and is only
strictly valid on 2d meshes.</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </element>
          <element name="discontinuous">
            <optional>
              <element name="lump_mass_matrix">
                <a:documentation>Lump the mass matrix for the assembly of the projection matrix
(not for the initial galerkin projection)</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </choice>
      </element>
      <element name="lagrange_multiplier">
        <a:documentation>Options for the lagrange multiplier

Must be on a continuous mesh!</a:documentation>
        <ref name="pressure_mesh_choice"/>
        <element name="spatial_discretisation">
          <choice>
            <element name="continuous_galerkin">
              <optional>
                <element name="remove_stabilisation_term">
                  <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="integrate_divergence_by_parts">
                  <a:documentation>Integrate the divergence operator by parts.

Automatic when projecting a discontinuous field</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
            <element name="control_volumes">
              <empty/>
            </element>
          </choice>
        </element>
        <optional>
          <element name="reference_node">
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <choice>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <empty/>
            </element>
            <element name="update_scalar_field">
              <a:documentation>Update a scalar field using the lagrange multiplier from
the divergence free projection of this field.  The selected
scalar field must have solenoidal selected in its interpolation
options too and it must be on the same mesh as used for the
solenoidal projection above.

Note well: this only really makes sense for scalar fields linked to nondivergent
vector fields, such as pressure to incompressible velocity!                  </a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <empty/>
            </element>
          </choice>
        </optional>
        <element name="solver">
          <a:documentation>Solver options for the linear solve.
This method requires the inversion of a projection matrix.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
      </element>
    </element>
  </define>
  <define name="represcribe_before_interpolation">
    <element name="represcribe_before_interpolation">
      <a:documentation>Represcribe the field before interpolation.

This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!</a:documentation>
      <empty/>
    </element>
  </define>
</grammar>
