<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <define name="hr_adaptivity">
    <element name="hr_adaptivity">
      <a:documentation>Anisotropic mesh hr-adaptivity</a:documentation>
      <attribute name="replaces">
        <value>ADMESH</value>
      </attribute>
      <choice>
        <element name="period">
          <a:documentation>Time interval (in simulation time) when mesh adaptivity performed.

DO NOT SET THIS EQUAL TO OR LESS THAN ONE TIME-STEP SMALLER
THAN YOUR DUMP PERIOD BECAUSE ALL YOUR DIAGNOSTIC FIELDS WILL
APPEAR AS ZERO OR JUNK
DIAGNOSTIC FIELDS GET ZEROED AFTER AN ADAPT

Usually set to 10-20 times the timestep.</a:documentation>
          <attribute name="replaces">
            <value>TIMMES</value>
          </attribute>
          <ref name="real"/>
        </element>
        <element name="period_in_timesteps">
          <a:documentation>Adapt period in timesteps.</a:documentation>
          <ref name="integer"/>
        </element>
      </choice>
      <optional>
        <element name="cpu_period">
          <a:documentation>Time interval (in cpu time) when mesh adaptivity performed
Manual suggests disabling this option.</a:documentation>
          <attribute name="replaces">
            <value>CPUMES</value>
          </attribute>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="minimum_number_of_nodes">
          <a:documentation>The minimum number of nodes this simulation may use.
In parallel, by default, this is the global minimum number of nodes.

If the mesh adaptivity algorithm wants to place fewer nodes
than this, the desired mesh is refined everywhere in space
until it will exceed this limit. This option should generally
only be used if a specified node count is being targetted.
Default value: 0</a:documentation>
          <optional>
            <element name="per_process">
              <a:documentation>Define minimum_number_of_nodes to be the minimum number of
nodes per process (rather than the global minimum number of
nodes).</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="integer"/>
        </element>
      </optional>
      <element name="maximum_number_of_nodes">
        <a:documentation>The maximum number of nodes this simulation may use.
In parallel, by default, this is the global maximum number of nodes.

If the mesh adaptivity algorithm wants to place more
nodes than this, the desired mesh is coarsened
everywhere in space until it will fit within this limit.
In general, the error tolerances should be set so that
this is never reached; it should only be a safety catch.
A typical value is 100000.

When using vertically_structured_adaptivity this indicates the 
maximum number of nodes in the horizontal mesh, i.e. the number
of nodes in the full mesh will be much bigger and depends on the 
number of layers specified, or if using inhomogenous_vertical_resolution
on the resolution produced by the vertical adaptivity step.</a:documentation>
        <attribute name="replaces">
          <value>MXNODS</value>
        </attribute>
        <optional>
          <element name="per_process">
            <a:documentation>Define maximum_number_of_nodes to be the maximum number of
nodes per process (rather than the global maximum number of
nodes).</a:documentation>
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="integer"/>
      </element>
      <optional>
        <element name="max_node_increase">
          <a:documentation>The maximum ratio by which the number of nodes is allowed to
increase in an adapt. e.g., a value of 1.1 indicates that the
number of nodes may be increased by at most 10%.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="node_locking">
          <a:documentation>Enable to lock nodes in the mesh.</a:documentation>
          <element name="python">
            <a:documentation>Python function defining nodes to lock. Return 0 for free
nodes, and non-zero for locked nodes. Functions should be
of the form:

 def val(x, t):
    # Function code
    return # Return value

The return value must be an integer.</a:documentation>
            <ref name="python_code"/>
          </element>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="functional_tolerance">
          <a:documentation>Functional value above which elements are considered for adaption.
 0.5 to 1.0 seems O.K- it can be negative.
 0.5 corresponds to a minimum insphere radius of 0.3 relative 1 and max-edge size 2.
 Value used in code is MAX(ABS(MESTP1), 0.15)
 Manual suggests 0.0</a:documentation>
          <attribute name="replaces">
            <value>MESTP1</value>
          </attribute>
          <ref name="real"/>
        </element>
      </optional>
      <choice>
        <element name="enable_gradation">
          <a:documentation>Gradation constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.</a:documentation>
          <optional>
            <element name="gradation_parameter">
              <a:documentation>The gradation parameter. Must be a real &gt;= 1.0.

The gradation parameter constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.
A constant of 1.0 enforces a mesh of constant
edge length everywhere. A value of 2.0 would
allow the element size to double from element
to element. The default value is 1.5.</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
        </element>
        <element name="disable_gradation">
          <a:documentation>Gradation constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.</a:documentation>
          <empty/>
        </element>
        <element name="anisotropic_gradation">
          <a:documentation>Anisotropic gradation algorithm, allowing for
anisotropic bounds on the gradient of the sizing
function.</a:documentation>
          <element name="tensor_field">
            <a:documentation>Gamma is the tensor field that contains
the bounds on the edge length specified by the error metric.</a:documentation>
            <attribute name="name">
              <value>Gamma</value>
            </attribute>
            <element name="anisotropic_symmetric">
              <ref name="input_choice_real_dim_symmetric_tensor"/>
            </element>
          </element>
        </element>
      </choice>
      <optional>
        <element name="metric_advection">
          <a:documentation>Metric advection algorithm.
By advecting the metric with the flow velocity,
we can push mesh resolution ahead of the flow dynamics,
rather than always lagging behind.</a:documentation>
          <element name="spatial_discretisation">
            <a:documentation>Spatial discretisation options</a:documentation>
            <element name="control_volumes">
              <ref name="standard_control_volume_options"/>
            </element>
            <element name="conservative_advection">
              <a:documentation>Conservative discretisation of field advection equation
 TBETA=1. -- conservative (divergence form)
 TBETA=0. -- non-conservative
 0. &lt; TBETA &lt; 1.</a:documentation>
              <attribute name="replaces">
                <value>TBETA, DEFALT (TBETA = 0.0)</value>
              </attribute>
              <ref name="real"/>
            </element>
          </element>
          <element name="temporal_discretisation">
            <element name="theta">
              <a:documentation>Implicit/explicit control (TTHETA)
 =0.  -- explicit
 =0.5 -- Crank-Nicolson
 =1.  -- implicit</a:documentation>
              <attribute name="replaces">
                <value>TTHETA, DEFALT (TTHETA = 0.5)</value>
              </attribute>
              <ref name="real"/>
            </element>
            <choice>
              <element name="maximum_courant_number_per_subcycle">
                <a:documentation>Use subcycling to advect the metric.

Specify the maximum courant number per subcycle.</a:documentation>
                <ref name="real"/>
                <ref name="field_based_cfl_number_options"/>
              </element>
              <element name="number_advection_subcycles">
                <a:documentation>Use subcycling to advect the metric.

Specify the number of subcycles.</a:documentation>
                <ref name="integer"/>
              </element>
            </choice>
            <optional>
              <element name="scale_advection_time">
                <a:documentation>Scale the time period over which the metric is
advected by this factor.

Default is 1.1</a:documentation>
                <ref name="real"/>
              </element>
            </optional>
            <element name="control_volumes">
              <a:documentation>Temporal discretisation options for the control volume discretisation</a:documentation>
              <optional>
                <element name="number_advection_iterations">
                  <a:documentation>Number of iterations within an advection solve.
This increases the accuracy of the face values and ensures that
the pivoted solution is cancelled out.
Defaults to 1 if unselected.</a:documentation>
                  <attribute name="replaces">
                    <value>INT(ABS(NDISOT)/10)</value>
                  </attribute>
                  <ref name="integer"/>
                </element>
              </optional>
              <optional>
                <element name="limit_theta">
                  <a:documentation>If not active then the theta specified above will be used.
Otherwise use variable limited theta on individual faces.</a:documentation>
                  <attribute name="replaces">
                    <value>MOD(INT(ABS(NDISOT)/1),10) = 1,3,5,7,9 (odd)</value>
                  </attribute>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="pivot_theta">
                  <a:documentation>Time discretisation of upwind discretisation off which the
higher order solution is pivotted.
 - pivot_theta = 1 - implicit pivot (default if not set and 
                     best choice if not intentionally modifying
                     scheme to be explicit)
 - pivot_theta = 0 - explicit pivot</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
          </element>
          <choice>
            <element name="solver">
              <a:documentation>Solver</a:documentation>
              <ref name="linear_solver_options_asym"/>
            </element>
            <element name="explicit">
              <a:documentation>Assume this field is being solved explicitly and skip the solver.

Assumes lhs matrix only has diagonal lumped mass
and divides the rhs by this.</a:documentation>
              <empty/>
            </element>
          </choice>
          <element name="output">
            <a:documentation>Debugging output options</a:documentation>
            <optional>
              <element name="output_subcycle_vtus">
                <a:documentation>Output vtus of the advected metric and edge lengths at every subcycle</a:documentation>
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="output_final_vtus">
                <a:documentation>Output vtus of the final metric merged over all the subcycles</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </element>
      </optional>
      <optional>
        <element name="geometric_constraints">
          <a:documentation>Apply geometric constraints to the metric formation.

As specified in (Pain, 2001), the mesh adaptivity
scheme attempts to formulate an appropriate edge length
for each direction at each point in space, independent
of problem, PDE or domain.

This option instructs the error metric formation
code to inspect the boundaries of the domain
and to bound the edge lengths requested appropriately.
This procedure stops the metric from asking for edge lengths
that are inappropriately large in comparison to the
resolution required to preserve the geometric accuracy
of the boundaries.

If you get 'knife elements' near domain boundaries,
turn this on.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="bounding_box_factor">
          <a:documentation>Bounding box factor.

If the length scales specified by the metric are
unrealistically large, the mesh optimisation
algorithm can get confused. An example
would be specifying a length scale in a direction to be an
order of magnitude greater than the width
of the domain.

In order to fix this, the edge lengths requested
are bounded by the bounding box of the domain
(the smallest cuboid that contains the domain).
However, it was found that bounding by the bounding
box impairs the generation of anisotropic elements
in the mesh optimisation algorithm.

This option is multiplied by the bounding box of the domain
before it bounds the metric formed from other
considerations. By default, it is set to 2.0.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="goal_based_adaptivity">
          <a:documentation>Goal-based adaptivity. </a:documentation>
          <a:documentation>With this option,
rather than taking the user-specified interpolation
error bounds as the weights to form the error metric
from the Hessians of the solution fields,
the interpolation weight is computed to optimally
represent the value of some specified functional
of state. In other words, the mesh is optimised
for the representation of a particular goal.

This is currently experimental. Activating
this option induces the code to ignore
any error bounds associated with the fields
specified under a material_phase.

For more information on this scheme,
see (Venditti &amp; Darmofal, 2003), or
(Power et. al, 2006).

Coding your own goal is also possible
but currently undocumented. See
error_measures/Goals.F90
for examples.</a:documentation>
          <choice>
            <element name="enstrophy_goal">
              <a:documentation>Optimise for the representation of
enstrophy,
  0.5 * int( |curl(velocity)|**2 ) dV.</a:documentation>
              <attribute name="subroutine">
                <value>goal_enstrophy</value>
              </attribute>
              <attribute name="dependencies">
                <value>Velocity%1 Velocity%2 Velocity%3</value>
              </attribute>
            </element>
            <element name="temperature_gradient_goal">
              <a:documentation>Optimise for the representation of
gradients of temperature,
  int(|grad(temperature)|**2) dV.</a:documentation>
              <attribute name="subroutine">
                <value>goal_temp</value>
              </attribute>
              <attribute name="dependencies">
                <value>Temperature</value>
              </attribute>
            </element>
            <element name="les_goal">
              <a:documentation>Optimise for the contribution of the standard
Smagorinsky LES tensor.

In effect, this goal minimises
the contribution of the sub-filter scale
model -- it applies mesh resolution where
the sub-grid scale model has an effect.

int( transpose(grad(u)) . kappa . grad(u) ) dV,
with u ranging over the components of (nonlinear)
velocity and kappa the LES tensor.</a:documentation>
              <attribute name="subroutine">
                <value>goal_les_velocity</value>
              </attribute>
              <attribute name="dependencies">
                <value>NonlinearVelocity%1 NonlinearVelocity%2 NonlinearVelocity%3</value>
              </attribute>
              <optional>
                <element name="nonlinear_iterations">
                  <a:documentation>The number of nonlinear iterations to perform when
forming the metric with this goal.

Because the LES tensor explicitly depends on mesh sizing,
we can form a metric and feed this back into the goal,
using the proposed mesh sizing instead of the current mesh.
This allows us to simulate adapts without actually incurring
the cost of adaptation, for the purposes of converging the metric.
The default value is 3.</a:documentation>
                  <ref name="integer"/>
                </element>
              </optional>
            </element>
            <element name="higher_order_les_goal">
              <a:documentation>Optimise for the contribution of the new 4th-order
LES tensor.

In effect, this goal minimises
the contribution of the sub-filter scale
model -- it applies mesh resolution where
the sub-grid scale model has an effect.

int( transpose(grad(u))   . kappa . grad(u) ) dV -
int( transpose(grad_h(u)) . kappa . grad_h(u) ) dV

with u ranging over the components of (nonlinear)
velocity, kappa the LES tensor,
grad(.) differentiation of basis functions and
grad_h(.) the Galerkin projection of the first derivative.</a:documentation>
              <attribute name="subroutine">
                <value>goal_les_velocity_4th</value>
              </attribute>
              <attribute name="dependencies">
                <value>NonlinearVelocity%1 NonlinearVelocity%2 NonlinearVelocity%3</value>
              </attribute>
              <optional>
                <element name="nonlinear_iterations">
                  <a:documentation>The number of nonlinear iterations to perform when
forming the metric with this goal.

Because the LES tensor explicitly depends on mesh sizing,
we can form a metric and feed this back into the goal,
using the proposed mesh sizing instead of the current mesh.
This allows us to simulate adapts without actually incurring
the cost of adaptation, for the purposes of converging the metric.
The default value is 3.</a:documentation>
                  <ref name="integer"/>
                </element>
              </optional>
            </element>
          </choice>
          <choice>
            <element name="relative_tolerance">
              <a:documentation>The tolerance of the goal specifies the acceptable
error in the quantity computed. The adaptation scheme
attempts to adapt the mesh to ensure that the
goal computed from the primitive solution is 
within the tolerance specified here.

A relative tolerance specifies that the acceptable error
in the goal is some fraction of the value as computed
from the primitive solution. It is generally 
the easiest to use. This is a unitless percentage.</a:documentation>
              <ref name="real"/>
            </element>
            <element name="absolute_tolerance">
              <a:documentation>The tolerance of the goal specifies the acceptable
error in the quantity computed. The adaptation scheme
attempts to adapt the mesh to ensure that the
goal computed from the primitive solution is 
within the tolerance specified here.

An absolute tolerance specifies the acceptable error
in the goal, in the units of the goal itself.</a:documentation>
              <ref name="real"/>
            </element>
          </choice>
        </element>
      </optional>
      <element name="tensor_field">
        <a:documentation>Mesh size constraints: the minimum edge length bound.</a:documentation>
        <attribute name="name">
          <value>MinimumEdgeLengths</value>
        </attribute>
        <element name="anisotropic_symmetric">
          <ref name="input_choice_real_dim_symmetric_tensor"/>
        </element>
      </element>
      <element name="tensor_field">
        <a:documentation>Mesh size constraints: the maximum edge length bound.</a:documentation>
        <attribute name="name">
          <value>MaximumEdgeLengths</value>
        </attribute>
        <element name="anisotropic_symmetric">
          <ref name="input_choice_real_dim_symmetric_tensor"/>
        </element>
      </element>
      <zeroOrMore>
        <element name="reference_mesh">
          <a:documentation>Supply a reference mesh with which to bound the metric</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <attribute name="mesh_name">
            <data type="string"/>
          </attribute>
          <choice>
            <element name="minimum">
              <a:documentation>Use this reference mesh as a bound on the minimum edge
length of the metric</a:documentation>
              <ref name="comment"/>
            </element>
            <element name="maximum">
              <a:documentation>Use this reference mesh as a bound on the maximum edge
length of the metric</a:documentation>
              <ref name="comment"/>
            </element>
          </choice>
          <ref name="comment"/>
        </element>
      </zeroOrMore>
      <optional>
        <element name="aspect_ratio_bound">
          <a:documentation>Maximum aspect ratio in the adapted mesh.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="adapt_at_first_timestep">
          <a:documentation>Adapt at first timestep</a:documentation>
          <element name="number_of_adapts">
            <a:documentation>Number of adapts done after initialisation but
before the actual simulation starts</a:documentation>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="output_adapted_mesh">
              <a:documentation>Write out the first timestep adapted mesh.
This is useful when needing to re-run simulations
without waiting for the first timestep adapt</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="preserve_mesh_regions">
          <a:documentation>Enable this option to preserve any regions in your
mesh (i.e. those specified by region_ids).
Also, any prescribed fields using region_ids will be
reinitialised using them on the new mesh.

Therefore this is a required option if you want your
prescribed region_id fields to survive adapts!
Obviously this does not apply to initial conditions
set using region_ids.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="vertically_structured_adaptivity">
          <a:documentation>Vertically structured adaptivity.

The mesh will be unstructured in the horizontal, but columnar
in the vertical.
To enable this, your meshes must be derived by extrusion
from a lower-dimensional horizontal mesh.
This will give a columnar, layered mesh.</a:documentation>
          <optional>
            <element name="inhomogenous_vertical_resolution">
              <a:documentation>If this is enabled, the resolution along each column
will be computed from the error metric.
This will give a columnar mesh, but not a layered one.</a:documentation>
              <empty/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <element name="adaptivity_library">
          <a:documentation>Select the adaptivity library used by hr-adaptivity. If disabled,
the defaults are:
  In 3D: libadaptivity
  In 2D: libmba2d
  In 1D: adaptivity_1d</a:documentation>
          <choice>
            <element name="libadaptivity">
              <a:documentation>libadaptivity. 3D, parallelised.</a:documentation>
              <optional>
                <element name="sweeps">
                  <a:documentation>The number of adaptivity sweeps. Default value: 10</a:documentation>
                  <ref name="integer"/>
                </element>
              </optional>
              <ref name="comment"/>
            </element>
            <element name="libmba2d">
              <a:documentation>libmba2d. 2D. A testing parallel implementation is available.</a:documentation>
              <optional>
                <element name="quality">
                  <a:documentation>Desired output mesh quality, 0 &lt;= quality &lt;= 1.
Default value 0.6.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <ref name="comment"/>
            </element>
            <element name="adaptivity_1d">
              <a:documentation>Re-uses 1D adaptivity code from 2+1D adaptivity. 1D, serial only.</a:documentation>
              <ref name="comment"/>
            </element>
            <element name="libmba3d">
              <a:documentation>libmba3d. 3D, serial only.</a:documentation>
              <ref name="comment"/>
            </element>
          </choice>
        </element>
      </optional>
      <optional>
        <element name="debug">
          <a:documentation>hr adptivity debugging options</a:documentation>
          <optional>
            <element name="write_metric_stages">
              <a:documentation>Write out error metric at each stage of the processing
pipeline. This can be very useful in diagnosing why
adaptivity is doing something you don't expect.</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="write_adapted_mesh">
              <a:documentation>Write out the Coordinate field to a triangle mesh for every
state adapt. In parallel, a triangle mesh and .halo files
will be written for every parallel adapt iteration.</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="write_adapted_state">
              <a:documentation>Write out the system state to a vtu adapt every state adapt.
In parallel, a vtu will be written for every parallel
adapt iteration.</a:documentation>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="checkpoint">
              <a:documentation>Checkpoint the simulation after every adapt. In parallel, a
checkpoint will be written &lt;b&gt;only&lt;/b&gt; after the final adapt
iteration. Checkpoints are postfixed with "adapt_checkpoint".</a:documentation>
              <optional>
                <element name="max_checkpoint_count">
                  <a:documentation>Number of checkpoints to write before overwriting existing
checkpoints.</a:documentation>
                  <ref name="integer"/>
                </element>
              </optional>
              <ref name="comment"/>
            </element>
          </optional>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="prescribed_adaptivity">
    <element name="prescribed_adaptivity">
      <a:documentation>Mesh adaptivity, with prescribed adapt interval and target meshes.
&lt;b&gt;Serial only&lt;/b&gt;.</a:documentation>
      <element name="adapt_interval">
        <a:documentation>Options relating the the frequency of mesh adaptivity</a:documentation>
        <element name="python">
          <a:documentation>Python code defining whether to adapt the mesh, evaluated at the
end of each timestep. Return non-zero to signal a mesh adapt, and
zero otherwise. Functions should be of the form:

 def val(t):
   # Function code
   return # Return value

The return value must be an integer.</a:documentation>
          <ref name="python_code"/>
        </element>
        <ref name="comment"/>
      </element>
      <element name="mesh">
        <a:documentation>Options relating to the target meshes</a:documentation>
        <element name="name">
          <a:documentation>The target mesh. This must be a mesh specified under /geometry.</a:documentation>
          <element name="python">
            <a:documentation>Python code defining the target mesh. Functions should be of
the form:

 def val(t):
   # Function code
   return # Return value

The return value must be a string.</a:documentation>
            <ref name="python_code"/>
          </element>
          <ref name="comment"/>
        </element>
        <ref name="comment"/>
      </element>
      <ref name="comment"/>
    </element>
  </define>
  <define name="interpolation_algorithm_disabled">
    <element name="no_interpolation">
      <a:documentation>Disable interpolation</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <define name="interpolation_algorithm_scalar">
    <choice>
      <element name="consistent_interpolation">
        <a:documentation>Basis function interpolation.
The standard algorithm. It is quick
and bounded, but non-conservative and dissipative.
All other algorithms require construction of a supermesh.</a:documentation>
        <empty/>
      </element>
      <element name="galerkin_projection">
        <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
        <ref name="galerkin_projection_scalar"/>
      </element>
      <element name="grandy_interpolation">
        <a:documentation>Grandy interpolation. Conservative, but highly diffusive.
See doi:10.1006/jcph.1998.6125 .</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="interpolation_algorithm_scalar_full">
    <ref name="interpolation_algorithm_scalar"/>
  </define>
  <define name="interpolation_algorithm_scalar_full" combine="choice">
    <ref name="interpolation_algorithm_disabled"/>
  </define>
  <define name="interpolation_algorithm_vector_full">
    <ref name="interpolation_algorithm_vector"/>
  </define>
  <define name="interpolation_algorithm_vector_full" combine="choice">
    <ref name="interpolation_algorithm_disabled"/>
  </define>
  <define name="interpolation_algorithm_vector">
    <choice>
      <element name="consistent_interpolation">
        <a:documentation>Basis function interpolation.
The standard algorithm. It is quick
and bounded, but non-conservative and dissipative.
All other algorithms require construction of a supermesh.</a:documentation>
        <ref name="comment"/>
      </element>
      <element name="galerkin_projection">
        <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
        <ref name="galerkin_projection_vector"/>
      </element>
      <element name="grandy_interpolation">
        <a:documentation>Grandy interpolation. Conservative, but highly diffusive.
See doi:10.1006/jcph.1998.6125 .</a:documentation>
        <empty/>
      </element>
      <element name="geostrophic_interpolation">
        <a:documentation>Helmholtz decomposed projection of the Coriolis force. Suitable only
for Velocity fields.
&lt;b&gt;FOR TESTING ONLY - NOT FOR PRODUCTION USE&lt;/b&gt;</a:documentation>
        <element name="conservative_potential">
          <a:documentation>Options relating to the conservative potential of the Helmholtz
decomposition</a:documentation>
          <choice>
            <element name="mesh">
              <a:documentation>The mesh used for the conservative potential. Note that this is
computed using the same method as the pressure projection, and
hence LBB constraints apply.</a:documentation>
              <attribute name="name">
                <value>PressureMesh</value>
              </attribute>
            </element>
            <element name="mesh">
              <a:documentation>The mesh used for the conservative potential. Note that this is
computed using the same method as the pressure projection, and
hence LBB constraints apply.</a:documentation>
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <element name="mesh">
              <a:documentation>The mesh used for the conservative potential. Note that this is
computed using the same method as the pressure projection, and
hence LBB constraints apply.</a:documentation>
              <attribute name="name">
                <value>CoordinateMesh</value>
              </attribute>
            </element>
            <element name="mesh">
              <a:documentation>The mesh used for the conservative potential. Note that this is
computed using the same method as the pressure projection, and
hence LBB constraints apply.</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
            </element>
          </choice>
          <element name="spatial_discretisation">
            <a:documentation>Spatial discretisation options</a:documentation>
            <element name="mass">
              <a:documentation>Options relating to the mass matrix</a:documentation>
              <optional>
                <element name="lump_mass">
                  <a:documentation>Lump the mass matrix. Required for continuous fields.</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
            </element>
            <element name="continuous_galerkin">
              <a:documentation>Use a continuous Galerkin discretisation</a:documentation>
              <optional>
                <element name="integrate_divergence_by_parts">
                  <a:documentation>Integrate the divergence operator by parts</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
              <optional>
                <element name="remove_stabilisation_term">
                  <a:documentation>Remove the stabilisation term from the projection operator.

Automatic when not using P1P1.</a:documentation>
                  <ref name="comment"/>
                </element>
              </optional>
              <ref name="comment"/>
            </element>
            <ref name="comment"/>
          </element>
          <optional>
            <element name="decomposed_field">
              <a:documentation>Perform a decomposed projection of a pressure field by subtracting
this conservative potential.</a:documentation>
              <attribute name="name">
                <data type="string"/>
              </attribute>
              <ref name="comment"/>
            </element>
          </optional>
          <optional>
            <element name="reference_node">
              <a:documentation>Reference node, at which the solution value is pinned to zero</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
          <element name="solver">
            <a:documentation>Solver options for the conservative potential calculation</a:documentation>
            <ref name="linear_solver_options_sym"/>
          </element>
          <element name="galerkin_projection">
            <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
            <ref name="continuous_projection"/>
            <optional>
              <ref name="supermesh_conservation"/>
            </optional>
            <ref name="comment"/>
          </element>
          <ref name="comment"/>
        </element>
        <element name="residual">
          <a:documentation>Options relating to the non-conservative residual component of the
Helmholz decomposition</a:documentation>
          <element name="galerkin_projection">
            <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
            <ref name="continuous_discontinuous_projection"/>
            <optional>
              <ref name="supermesh_conservation"/>
            </optional>
            <ref name="comment"/>
          </element>
          <ref name="comment"/>
        </element>
        <optional>
          <element name="geopressure_preconditioner">
            <a:documentation>Precondition the Helmholtz decomposition using a GeostrophicPressure
solver</a:documentation>
            <ref name="mesh_choice"/>
            <optional>
              <element name="reference_node">
                <a:documentation>Reference node, at which the solution value is pinned to zero</a:documentation>
                <ref name="integer"/>
              </element>
            </optional>
            <element name="solver">
              <a:documentation>Solver options for the GeostrophicPressure solve</a:documentation>
              <ref name="linear_solver_options_sym"/>
            </element>
            <element name="galerkin_projection">
              <a:documentation>Galerkin projection. By default, conservative, non-dissipative and
non-bounded. The most accurate choice, in the sense of minimising
the L2 norm of the residual</a:documentation>
              <ref name="continuous_projection"/>
              <optional>
                <ref name="supermesh_conservation"/>
              </optional>
              <ref name="comment"/>
            </element>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="enforce_conservative">
            <a:documentation>Enforce a conservative Pressure gradient following the interpolation</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="enforce_conservative">
            <a:documentation>Enforce a solenoidal Velocity following the interpolation</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="enforce_solenoidal">
            <ref name="comment"/>
          </element>
        </optional>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <define name="galerkin_projection_vector">
    <ref name="continuous_discontinuous_projection"/>
    <optional>
      <ref name="supermesh_free"/>
    </optional>
    <optional>
      <ref name="supermesh_conservation"/>
    </optional>
  </define>
  <define name="galerkin_projection_scalar">
    <ref name="continuous_discontinuous_projection"/>
    <optional>
      <ref name="supermesh_free"/>
    </optional>
    <optional>
      <ref name="supermesh_conservation"/>
    </optional>
  </define>
  <define name="continuous_projection">
    <element name="continuous">
      <a:documentation>Continuous field Galerkin projection.
If the field you are interpolating is continuous, then
a linear solver is required to invert the mass matrix.</a:documentation>
      <optional>
        <choice>
          <element name="bounded">
            <a:documentation>Use a bounded Galerkin projection. Conservative, bounded in the
limit, and minimally dissipative. This algorithm starts with the
Galerkin projection and dissipates it until it achieves
boundedness.
If it does not converge, it may not be exactly bounded.
Note well: this only works for linear fields.</a:documentation>
            <attribute name="name">
              <value>Diffuse</value>
            </attribute>
            <element name="boundedness_iterations">
              <a:documentation>The number of dissipation iterations attempted to bound the
Galerkin projection.</a:documentation>
              <ref name="integer"/>
              <optional>
                <element name="tolerance">
                  <a:documentation>Specify the tolerance to which boundedness is to be tested during the iterations.
Defaults to computer precision if unspecified.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
            </element>
            <optional>
              <element name="bounds">
                <a:documentation>If the bounds on this field are known then they can be set here.
These can either further constrain the limits worked out by the
lumped version of the projection (i.e. to make sure that errors 
don't accumulate with succesive interpolations) or if apply_globally
is set they are just made to be bounded within the bounds globally
(i.e. anything between those bounds is not smoothed).</a:documentation>
                <optional>
                  <element name="upper_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="coupled">
                        <a:documentation>This field is to be considered as being coupled to another field
such that the sum of the two fields is constrained to be less than
the upper_bound specified above.

The relationships between fields are worked out according to their
priority ordering.

This method is akin to the coupled_cv advection method.</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
                <optional>
                  <element name="lower_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </optional>
            <optional>
              <element name="repair_deviations">
                <a:documentation>If, after performing all the boundedness_iterations, the field
is still not bounded then perform surgery to redistribute the
deviations to nodes that have less than their bounds.</a:documentation>
                <optional>
                  <element name="tolerance">
                    <a:documentation>Specify the tolerance to which boundedness is to be tested during the repair.
Defaults to computer precision if unspecified.</a:documentation>
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
            </optional>
          </element>
          <element name="bounded">
            <a:documentation>Use a bounded Galerkin projection. Conservative, bounded in the
limit, and hopefully minimally dissipative. This algorithm starts with the
Galerkin projection and uses the optimisation library Algencan to bound
it by minimising a functional within constraints on boundedness and conservation.
Note well: this only works for linear fields.</a:documentation>
            <attribute name="name">
              <value>Algencan</value>
            </attribute>
            <choice>
              <element name="functional">
                <attribute name="name">
                  <value>L2</value>
                </attribute>
                <optional>
                  <element name="weight">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
              <element name="functional">
                <attribute name="name">
                  <value>LumpedMassL2</value>
                </attribute>
                <optional>
                  <element name="weight">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
              <element name="functional">
                <attribute name="name">
                  <value>IntegralL2</value>
                </attribute>
                <optional>
                  <element name="weight">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
              <element name="functional">
                <attribute name="name">
                  <data type="string" datatypeLibrary=""/>
                </attribute>
                <optional>
                  <element name="weight">
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
            </choice>
            <optional>
              <element name="bounds">
                <a:documentation>If the bounds on this field are known then they can be set here.
These can either further constrain the limits worked out by the
lumped version of the projection (i.e. to make sure that errors 
don't accumulate with succesive interpolations) or if apply_globally
is set they are just made to be bounded within the bounds globally
(i.e. anything between those bounds is not smoothed).</a:documentation>
                <optional>
                  <element name="upper_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="coupled">
                        <a:documentation>This field is to be considered as being coupled to another field
such that the sum of the two fields is constrained to be less than
the upper_bound specified above.

The relationships between fields are worked out according to their
priority ordering.

This method is akin to the coupled_cv advection method.</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
                <optional>
                  <element name="lower_bound">
                    <ref name="real"/>
                    <optional>
                      <element name="apply_globally">
                        <a:documentation>If this is set the upper_bound is used everywhere.
If left unset the upper_bound is only used to constrain
the smoothed bounds calculated by the code</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
            </optional>
          </element>
        </choice>
      </optional>
      <choice>
        <element name="solver">
          <a:documentation>Solver options for the linear solve.
This method requires the inversion of a mass matrix. Note that
conservation properties are affected by the tolerance of the
linear solve.</a:documentation>
          <ref name="linear_solver_options_sym"/>
        </element>
        <element name="lump_mass_matrix">
          <a:documentation>Lump the mass matrix on the left hand side of the galerkin projection.
Hence solver options aren't necessary.

This is much more diffusive than a non-lumped Galerkin projection
for only a minimal saving in computational cost.</a:documentation>
          <empty/>
        </element>
      </choice>
    </element>
  </define>
  <define name="continuous_discontinuous_projection">
    <choice>
      <ref name="continuous_projection"/>
      <element name="discontinuous">
        <a:documentation>Discontinuous field Galerkin projection
In this case, no linear solver is required to invert the mass matrix.</a:documentation>
        <empty/>
      </element>
    </choice>
  </define>
  <define name="supermesh_free">
    <element name="supermesh_free">
      <a:documentation>Enables a supermesh free Galerkin projection. Uses incomplete
quadrature, and hence is not conservative.</a:documentation>
      <empty/>
    </element>
  </define>
  <define name="supermesh_conservation">
    <element name="supermesh_conservation">
      <a:documentation>Options for checking the supermesh conservation properties</a:documentation>
      <optional>
        <element name="tolerance">
          <a:documentation>Specify the fraction of the original elemental area/volume
to be used to check the conservation of the supermesh.

Since all fields are supermeshed together the minimum tolerance
specified over all fields will be used.

Defaults to 0.001 if unspecified.
i.e. 0.1% of the area/volume of an element in the new mesh may
be lost without warning or attempts to fix (if compiled with cgal)
during the construction of the supermesh between the old
and new meshes.</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="print_field_integral">
          <a:documentation>Compute the field integral after the interpolation and print the relative
mass loss to the logfile (level 2 verbosity).

Note this is a post interpolation step and offers no chance of
fixing the conservation error (unlike the tolerance above if compiled
with cgal)</a:documentation>
          <element name="tolerance">
            <a:documentation>Relative tolerance with which to test the conservation of the field
integral.  If the conservation fails this tolerance a warning is issued
(level 0 verbosity) and vtus containing the field are output.</a:documentation>
            <ref name="real"/>
          </element>
        </element>
      </optional>
    </element>
  </define>
</grammar>
