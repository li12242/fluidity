include "spud_base.rnc"

include "adaptivity_options.rnc"
include "diagnostic_algorithms.rnc"
include "input_output.rnc"
include "solvers.rnc"
include "stabilisation.rnc"
include "reduced_model.rnc"

start =
   (
      ## The root node of the options dictionary.
      element fluidity_options {
         comment,
         ## Model output files are named according to the simulation
         ## name, e.g. [simulation_name]_0.vtu. Non-standard
         ## characters in the simulation name should be avoided.
         element simulation_name {
            anystring
         },
         ## Option problem_type does not change the tree.  It is just used for options checking.
         element problem_type {
            element string_value {
               # Lines is a hint to the gui about the size of the text box.
               # It is not an enforced limit on string length.
               attribute lines { "1" },
               ( "fluids" | "oceans" | "multimaterial" | "porous_media" | "stokes" )
            },
            comment
         },
         geometry,
         ## Input/output options
         element io {
            ## Format for dump files. Only vtk for now.
            element dump_format {
               element string_value{
                  "vtk"
               }
            },
            (
               ## Period between dumps in time units.
               ##
               ## Specifies the period between each dump of the solution to disk.
               ## A value of 0.0 indicates that there would be a dump at every timestep.
               element dump_period {
                  attribute replaces {"TIMDUM"},
                  real
               }|
               ## Dump period, in timesteps.
               ## 
               ## Specifies the number of timesteps between each dump of the solution to disk.
               ## A value of 0 indicates a dump at every timestep.
               element dump_period_in_timesteps {
                  integer
               }
            ),
            ## Disable dump at simulation start
            element disable_dump_at_start {
               comment
            }?,
            ## Disable dump at simulation end
            element disable_dump_at_end {
               comment
            }?,
            # every CPUDUM seconds write results to disc.
            ## This is usually disabled.
            element cpu_dump_period {
               attribute replaces {"CPUDUM"},
               real
            }?,
            ## The period between dumps in walltime seconds. This is usually disabled.
            element wall_time_dump_period {
               attribute replaces {"WTIDUM"},
               real
            }?,
            ## Number of dumps before we overwrite previous dumps.
            element max_dump_file_count {
               attribute replaces {"DUMSAV"},
               integer
            }?,
            (
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "VelocityMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "PressureMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { "CoordinateMesh" }
               }|
               ## The mesh on to which all the fields will be
               ## interpolated for VTK output.
               element output_mesh {
                  attribute name { xsd:string }
               }
            ),
            ## Options for convergence analysis.
            element convergence {
               ## Whether to enable the creation of a convergence
               ## file, giving details of the convergence of each
               ## field over the global nonlinear iteration loop.
               ## The .convergence file is in the same format as the .stat file.
               element convergence_file {
                  comment
               }?,
               ## Write state to a vtu on every iteration.
               ## 
               ## This is a useful debugging tool if things are not converging.
               ## To prevent an excessive number of files being accumulated previous
               ## timestep files will be overwritten hence it is best to use
               ## in conjunction with /timestepping/nonlinear_iterations/terminate_if_not_converged
               element convergence_vtus {
                  comment
               }?
            }?,
            ## Whether to enable dumping of checkpointing output.
            ##
            ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options
            element checkpointing {
               ## Checkpointing period, in dumps. Non-negative value
               ## required. A value of zero indicates that checkpoints
               ## should be created at every dump. If
               ## /io/max_dumpfile_count is exceeded then earlier
               ## checkpoints may be overwritten.
               element checkpoint_period_in_dumps {
                  integer
               },
               ## Enable to checkpoint at simulation start.
               element checkpoint_at_start {
                  comment
               }?,
               ## Enable to force a checkpoint at simulation end.
               element checkpoint_at_end {
                  comment
               }?,
               comment
            }?,
            ## Diagnostic output (.stat file) options
            element stat {
               ## Enable to write diagnostic output at simulation start
               element output_at_start {
                  comment
               }?,
               ## Enable to write diagnostic output immediately before mesh adapts
               element output_before_adapts {
                  comment
               }?,
               ## Enable to write diagnostic output immediately after mesh adapts
               element output_after_adapts {
                  comment
               }?,
               comment
            },
            ## Specification of detectors
            element detectors {
               (
                  ## A single static detector
                  element static_detector {
                     attribute name { xsd:string },
                     (
                        element location {
                           real_dim_vector
                     }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }|
                  ## A single lagrangian detector
                  element lagrangian_detector {
                     attribute name { xsd:string },
                     (
                     ## This is the initial location of a detector that moves with the fluid velocity.
                        element location {
                           real_dim_vector
                     }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }|
                  ## Detectors with their locations specified via a python function or from a file. Allows detector arrays to be added.
                  element detector_array {
                     attribute name { xsd:string },
                     ## The number of detectors prescribed by the python function.
                     element number_of_detectors {
                        integer
                     },
                     (
                        ## Create fixed detectors.
                        element static {
                           empty
                        }|
                        ## Create detectors which move with the fluid velocity.
                        element lagrangian {
                           empty
                        }
                     ),
                     (
                        ## Python function prescribing dimensional vector input. Functions should be of the form:
                        ##
                        ##  def val(t):
                        ##     # Function code
                        ##     return # Return value
                        ##
                        ## The return value must have length number_of_detectors.
                        ##
                        ## *** IMPORTANT NOTE ***
                        ##
                        ## The t argument is for future use only - currently detector locations are only set at simulation start.
                        element python {
                          python_code
                        }|
                        ## File containing the detectors positions in binary form
                        element from_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }|
                        ## File containing the detectors positions in binary form
                        element from_checkpoint_file {
                           attribute file_name { xsd:string },
                           ## The format of the input file containing field data.
                           element format {
                             element string_value {
                                 "binary"
                             }
                           }
                        }
                     )
                  }
               )*,
               ## Enable to write detector output in binary format
               element binary_output {
                  comment
               }?
            }?,
            ## Options to create even more output in the logs:
            ##
            ## Note that the main option to control the log output is given on the command line:
            ##
            ## -v0  only output error and warnings
            ##
            ## -v1  also give "navigational information", to indicate where in the code we currently are
            ##
            ## -v2  also give any additional information (mins and maxes of fields, etc.)
            ##
            element log_output {
               ## Log all allocates and deallocates done for meshes, fields, sparsities and matrices.
               ##
               ## NOTE: Requires -v2
               element memory_diagnostics {
                  empty
               }?
            }?
         },
         ## Options dealing with time discretisation
         element timestepping {
            ## Current simulation time. At the start of the simulation this
            ## is the start time.
            element current_time {
               attribute replaces {"ACCTIM"},
               real,
               ## The following excerpt from the Udunits
               ## documentation explains the time unit encoding by
               ## example:
               ##
               ## The specification:
               ##
               ## seconds since 1992-10-8 15:15:42.5 -6:00
               ##
               ## indicates seconds since October 8th, 1992 at 3
               ## hours, 15 minutes and 42.5 seconds in the afternoon
               ## in the time zone which is six hours to the west of
               ## Coordinated Universal Time (i.e.  Mountain Daylight
               ## Time). The time zone specification can also be
               ## written without a colon using one or two-digits
               ## (indicating hours) or three or four digits
               ## (indicating hours and minutes).
               ##
               ## Time units are particularly required in situations
               ## where the problem (time-varying) boundary conditions
               ## and/ initial conditions are a function of time as
               ## defined by a calendar.  Examples include atmospheric
               ## forcing and climatology. The current time, specified
               ## above, is zero at the reference data/time.
               element time_units{attribute date { xsd:string }}?
            },
            ## The time step size. If adaptive time stepping is used
            ## then this is the initial time step size.
            element timestep {
               attribute replaces {"DT"},
               real
            },
            ## Simulation time at which the simulation should end.
            element finish_time {
               attribute replaces {"LTIME"},
               real
            },
            ## Timestep after which the simulation should end.
            element final_timestep {
               integer
            }?,
            ## Maximum CPU time (secs) taken up before
            ## simulation terminates writing results to disc.
            ## 
            ## Manual suggests 1.E+20
            element cpu_time_limit {
               attribute replaces {"CPULIM"},
               real
            }?,
            ## Maximum wall time (secs) taken up before
            ## simulation terminates writing results to disc.
            ## 
            ## This is usually disabled.
            element wall_time_limit {
               attribute replaces {"WATIME"},
               real
            }?,
            ## maximum number of non-linear iterations.
            ## 
            ## Manual suggests 2
            element nonlinear_iterations {
               attribute replaces {"ITINOI"},
               integer,
               ## tolerance for non-linear iteration.
               ## Manual suggests 1.0E-12
               element tolerance {
                  attribute replaces {"ITIERR"},
                  real,
                  (
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The infinity norm.
                      element infinity_norm {
                        empty
                      }|
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The l2 norm.
                      element l2_norm {
                        empty
                      }|
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The l2 norm evaluated on a control volume mesh.
                      element cv_l2_norm {
                        empty
                      }
                  )
               }?,
               ## Terminate the simulation if the number of
               ## nonlinear_iterations is reached
               ## and the tolerance criterion is not met.
               ## This is mostly useful as a debugging option if you
               ## suspect the solution is not converging.
               element terminate_if_not_converged {
                  empty
               }?
            }?,
            ## Vary the timestep according to the courant number.
            element adaptive_timestep {
               attribute replaces {"TIMAUT"},
               ## The timestep will be adjusted (within the tolerance
               ## and bounds specified) to target this courant
               ## number. Timestep adapts occur at the end of each
               ## timestep and after a mesh adapt.
               element requested_cfl {
                  real
               },
               timestep_cfl_number_options,
               ## Minimum time step size.
               ## Manual suggests 0.0
               element minimum_timestep {
                  attribute replaces {"MINDT"},
                  ## If enabled, signals model termination if a timestep less
                  ## than or equal to the minimum_timestep is requested. The
                  ## model will stop at the end of the timestep in order to
                  ## allow for the latest output to be written. 
                  element terminate_if_reached {
                     comment
                  }?,
                  real
               }?,
               ## Maximum time step size.
               ## Manual suggests 1.E+10
               element maximum_timestep {
                  attribute replaces {"MAXDT"},
                  real
               }?,
               ## The maximum ratio by which the timestep is allowed
               ## to increase in a timestep adapt. e.g., a value of
               ## 1.1 indicates that the timestep may be increased by
               ## at most 10%.
               element increase_tolerance {
                  real
               }?,
               ## Specify whether you want to calculate a new timestep
               ## at the first timestep or not.
               element at_first_timestep {
                  empty
               }?
            }?,
            ## Activate if you want to terminate the simulation once a
            ## steady state is reached.
            ## 
            ## Enable/disable fields in this check under each field in
            ## steady_state options.
            # Preprocessor legacy: STEDER = 0. is equivalent to inactive.
            element steady_state {
               ## Enter the tolerance to which you want a steady state to be judged.
               element tolerance {
                  attribute replaces { "STEDER" },
                  real,
                  (
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The infinity norm.
                      element infinity_norm {
                        empty
                      }|
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The l2 norm.
                      element l2_norm {
                        empty
                      }|
                      ## Select the norm with which you want the tolerance to be tested.
                      ##
                      ## The l2 norm evaluated on a control volume mesh.
                      element cv_l2_norm {
                        empty
                      }
                  )
               },
               ## If activated compare the above tolerance to the rate
               ## of change of the fields. Otherwise compare it
               ## directly to the change in the field.
               element acceleration_form {
                  empty
               }?
            }?
         },
         ## The physical parameters
         element physical_parameters {
            ## Set a gravity to be included in the buoyancy term.
            element gravity {
               ## Acceleration due to gravity. 9.8 m/s^2 on earth.
               element magnitude {
                  attribute replaces { "GRAVTY" },
                  real
               },
               ## The direction of the gravity vector.
               element vector_field {
                  attribute name { "GravityDirection" },
                  attribute rank { "1" },
                  attribute replaces { "BSOUX BSOUY BSOUZ" },
                  element prescribed {
                     element mesh {
                       attribute name {  "CoordinateMesh" }
                     },
                     prescribed_vector_field_no_adapt
                  }
               }
            }?,
            ## Options relating to Coriolis force. The rotation vector is
            ## assumed to be in the z-direction:
            ##
            ##   F_C = 2 \Omega \hat{k} \times u = f \hat{k} \times u
            element coriolis {
               attribute replaces { "OPTOME" },
               (
                  ## f-plane approximation
                  ## This means the Coriolis force looks like:
                  ##   f k x u
                  ## where k is the z unit vector
                  ##    and u the velocity vector
                  ##    and f is constant
                  element f_plane {
                     attribute replaces { "OPTOME = 0" },
                     ## f-plane approximation
                     ## This means the Coriolis force looks like:
                     ##   f k x u
                     ## where k is the z unit vector
                     ##    and u the velocity vector
                     ##    and f is constant
                     element f {
                        attribute replaces {"OMEGA" },
                        real
                     }
                  }|
                  ## Beta-plane approximation
                  ## This means the Coriolis force looks like:
                  ##   f k x u
                  ## where k is the z unit vector
                  ##    and u the velocity vector
                  ##    and f=f_0+beta . (x,y,z)
                  element beta_plane {
                     attribute replaces { "OPTOME = 1" },
                     ## Beta-plane approximation
                     ## This means the Coriolis force looks like:
                     ##   f k x u
                     ## where k is the z unit vector
                     ##    and u the velocity vector
                     ##    and f=f_0+beta . (x,y,z)
                     element f_0 {
                        attribute replaces {"OMEGA" },
                        real
                     },
                     ## Beta-plane approximation
                     ## This means the Coriolis force looks like:
                     ##   f k x u
                     ## where k is the z unit vector
                     ##    and u the velocity vector
                     ##    and f=f_0+beta . (x,y,z)
                     ## usually only the y-component of beta is non-zero
                     element beta {
                        attribute replaces {"OMEGA1 OMEGA2 OMEGA3" },
                        real_dim_vector
                     }
                  }|
                  ## Full Coriolis parameter:
                  ##   f = 2 omega sin (latitude)
                  ## where latitude=y/R_earth+latitude_0
                  ## 
                  ## Specify omega and R_earth and latitude_0
                  element sine_of_latitude {
                     attribute replaces { "OPTOME = 2" },
                     ## Full Coriolis parameter:
                     ##   f = 2 omega sin (latitude)
                     ## where latitude=y/R_earth+latitude_0
                     element omega {
                        attribute replaces {"OMEGA" },
                        real
                     },
                     ## Full Coriolis parameter:
                     ##   f = 2 omega sin (latitude)
                     ## where latitude=y/R_earth+latitude_0
                     ## 
                     ## Suggested value for R_earth: 6.371e6
                     element R_earth {
                        real
                     },
                     ## Full Coriolis parameter:
                     ##   f = 2 omega sin (latitude)
                     ## where 
                     ##   latitude=y/R_earth+latitude_0
                     ## latitude_0 is the latitude of y=0
                     element latitude_0 {
                        real
                     }
                  }|
                  ## Full representation on sphere
                  element on_sphere {
                     ## Earth rotation rate
                     ## 
                     ## Suggested value: 2 pi / 86400 = 7.27220522e-5
                     element omega {
                        attribute replaces {"OMEGA" },
                        real
                     }
                  }|
                  ## As f_plane, but with the value for f set using a python
                  ## function. Allows for time varying rotation rate.
                  ##
                  ## Functions should be of the form:
                  ##
                  ##  def val(t):
                  ##     # Function code
                  ##     return # Return value
                  ##
                  ## where the return value is a float.
                  element python_f_plane {
                     python_code
                  }
               )
            }?
         },
         ## The material or phase options
         element material_phase {
            attribute name { xsd:string },
            ## The equation of state
            element equation_of_state {
               (
                  (
                     ## Equations of state for ocean (and simple fluid) applications
                     element fluids {
                        (
                           ## Incompressible linear equation of state
                           ## 
                           ## (e.g. density=denini*(1.0-dengam*(temperature-temini)+dengam_sal*(salinity-S0)))
                           element linear {
                              attribute replaces { "EQNSTA=0 or 1" },
                              ## The reference or background density
                              element reference_density {
                                 attribute replaces {"DENINI"},
                                 real
                              },
                              ## Enable to add temperature dependency
                              ## to the equation of state.
                              element temperature_dependency {
                                 attribute replaces { "BOUSIN, EQNSTA=0" },
                                 ## The reference or background
                                 ## temperature (actual temperature =
                                 ## calculated temperature plus this
                                 ## value).
                                 element reference_temperature {
                                    attribute replaces {"TEMINI"},
                                    real
                                 },
                                 ## The thermal expansion coefficient
                                 element thermal_expansion_coefficient {
                                    attribute replaces {"DENGAM"},
                                    real
                                 }
                              }?,
                              ## Enable to add salinity dependency to
                              ## the equation of state.
                              element salinity_dependency {
                                 attribute replaces { "BOUSIN, EQNSTA=1" },
                                 ## The reference or background
                                 ## salinity (actual salinity =
                                 ## calculated salinity plus this
                                 ## value).
                                 element reference_salinity {
                                    attribute replaces {"S0 if from .dat file?, GAMDE3(1) if from gem"},
                                    real
                                 },
                                 ## The haline contraction coefficient
                                 element saline_contraction_coefficient {
                                    attribute replaces {"DENGAM_SAL if from .dat file?, GAMDE2(1) if from gem"},
                                    real
                                 }
                              }?,
                              ## Enable this option to subtract out
                              ## the hydrostatic level
                              element subtract_out_hydrostatic_level {
                                 attribute replaces {"BHOUT"},
                                 empty
                              }?
                           }|
                           ## 2002 McDougall, Jackett, Wright and
                           ## Feistel equation of state using Pade
                           ## approximation
                           element ocean_pade_approximation {
                              attribute replaces { "EQNSTA = 2 or 3" },
                              element include_depth_below_surface {
                                 attribute replaces { "EQNSTA = 2 if switched on" },
                                 empty
                              }?
                           }
                        )
                     }|
                     ## Equations of state for compressible applications
                     element compressible {
                        ## Mie-Grunneisen EoS
                        ##
                        ## Used with compressible simulations
                        element miegrunneisen {
                           attribute replace { "MKCOMP from solidity_inputs.inp" },
                           ## reference uncompressed density
                           ##
                           ## if activated then either Liquid EoS or
                           ## full Mie-Grunneisen EoS
                           ##  - replaces EOS TYPE = 1 or 3 from
                           ##  solidity_imputs.inp -> MATEOS
                           ## if not activated then replaces EOS TYPE 2 from
                           ## solidity_inputs.inp -> MATEOS
                           element reference_density {
                              attribute replaces { "DENINI for single materials, REFERENCE DENS. from solidity_inputs.inp -> DENINIMAT for multimaterials" },
                              real
                           }?,
                           ## Ratio of specific heats at constant
                           ## pressure to that at constant volume
                           ##
                           ## Requires an energy field.
                           ## If activated then a full Mie-Grunneisen EoS 
                           ##  - replaces EOS TYPE = 3 from solidity_imputs.inp -> MATEOS
                           ## if not activated then either EOS TYPE 1 or 3
                           ## from solidity_inputs.inp -> MATEOS
                           element ratio_specific_heats {
                              attribute replaces { "DENGAM for single materials, DEN GAM from solidity_inputs.inp -> DENGAMMAT for multimaterials" },
                              real
                           }?,
                           ## bulk_sound_speed_squared = isothermal_bulk_modulus/reference_density
                           ##
                           ## if activated then either full or partial Liquid EoS or full
                           ## Mie-Grunneisen EoS - replaces EOS TYPE = 1, 2 or 3
                           ## from solidity_imputs.inp -> MATEOS
                           element bulk_sound_speed_squared {
                              attribute replaces { "GASCON for single materials, COMPRESS COEF. from solidity_inputs.inp -> GASCONMAT for multimaterials" },
                              real
                           }?
                        }
                     }
                  )
               )
            }?,
            ## Subgridscale parameterisations
            element subgridscale_parameterisations {
               ## Lagrangian-averaged Navier-Stokes equations 
               element LANS {
                  (
                     ## smoothing length specified as isotropic homogeneous
                     element alpha_isotropic_homogeneous {
                        real
                     }|
                     element alpha_anisotropic_homogeneous_cartesian {
                        real_dim_symmetric_tensor
                     }
                  )
                  #               (
                  #                  element leray {
                  #                     empty
                  #                  }|
                  #                  element LANS_momentum_form {
                  #                     empty
                  #                  }|
                  #                  element LANS_stress_form {
                  #                     empty
                  #                  }
                  #               )
               }?,
               ## You MUST add the following additional fields for this:
               ##  DistanceToTop
               ##  DistanceToBottom
               ##  DistanceToSideBoundaries
               ##  PerturbationDensity
               element Gent_McWilliams {
                  ## This is the diffusivity along density
                  ## surfaces. At the moment the dianeutral
                  ## diffusivity is hardcoded to be 10^-7 x
                  ## isoneutral_diffusivity.
                  element isoneutral_diffusivity {
                     real
                  },
                  ## This is the diffusivity that parameterises the
                  ## effects of the baroclinic eddies.
                  element GentMcWilliams_diffusivity {
                     real
                  },
                  ## The vertical and off-diagonal components of the
                  ## Gent-McWilliams diffusivity tensor need to be
                  ## tapered to zero near the boundaries of the
                  ## domain. A taper should also be applied where the
                  ## density slope is large - define "large" by
                  ## setting maximum_density_slope below.
                  element tapering {
                     ## Where the slope of the density surface is
                     ## greater than or equal to the
                     ## maximum_density_slope, an exponential taper is
                     ## applied to the isoneutral diffusivity and a
                     ## linear taper is applied to the GentMcWilliams
                     ## diffusivity.
                     element maximum_density_slope {
                        real
                     },
                     ## The exponential taper has the form
                     ## tanh((S_max-sqrt(S.S))/S_d) where S_mac is the
                     ## maximum_density_slope, S is the local slope of
                     ## the density surface and S_d is a parameter
                     ## that controls the width of the tapering
                     ## region.
                     element width_of_exponential_taper_region {
                        real
                     },
                     ## If the slope of the density surface is less
                     ## than the maximum_density_slope but we are
                     ## still near the surface, a sine taper is
                     ## applies to both the diffusivities - "near" is
                     ## defined as d < R1 |S| where d is the distance
                     ## to the top, |S| is the slope of the density
                     ## surface and R1 is the
                     ## first_baroclinic_Rossby_radius.
                     element first_baroclinic_Rossby_radius {
                        real
                     },
                     ## Near the bottom and side boundaries the
                     ## Gent-McWlliams diffusivity is tapered to zero
                     ## by multiplying by c*DistanceToBoundary
                     element constant_for_linear_taper {
                        real
                     }
                  }
               }?,
               ## This is the generic length scale (vertical turbulence mixed layer) model, 
               ## based here on Warner et al 2005, Ocean Modelling 8:81-113,
               ## which is itself based on the works of Umlauf and Burchard 2003.
               ##
               ## The GLS model encodes four individual turbulence closure models which can be chosen via 'option' below.
               ##
               ## You will need to make sure that DistanceToTop and DistanceToBottom fields (under geometry/ocean_boundaries 
               ## are switched on, as well as PerturbationDensity.
               element GLS {
                  ## The base GLS option:
                  ## 1. k-kl which is a variant of Mellor-Yamada 2.5
                  ## 2. k-epsilon
                  ## 3. k-omega
                  ## 4. 'gen' from Warner et al 2005
                  element option {
                     element string_value {
                     "k-kl"|"k-epsilon"|"k-omega"|"gen"
                     }
                  },
                  ## The stability function choice:
                  ## 1. KanthaClayson-94 which corresponds to Kantha and Clayson 1994
                  ## 2. Galperin-88 which corresponds to Galperin et al 1988
                  ## 3. Canuto-01-A which corresponds to choice A from Canuto et al 2001
                  ## 4. Canuto-01-B which corresponds to choice B from Canuto et al 2001
                  element stability_function {
                     element string_value {
                     "KanthaClayson-94"|"GibsonLaunder-78"|"Canuto-01-A"|"Canuto-01-B"
                     }
                  },
                  ## Do you want the boundary conditions to be set automatically?
                  ## Make sure the ocean geometry settings are enabled for this option
                  element calculate_boundaries {
                     element string_value {
                     "neumann"|"dirichlet"
                     },
                     ## Force the surface values to be equal to that of the Dirichlet BC.
                     ## This forms an ill-posed problem, but appears to stabilise some simulations.
                     ## Manual suggests that this is OFF unless you're having difficulties.
                     element fix_surface_values {
                        empty
                     }?
                  }?,
                  ## Turbulent kinetic energy
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSTurbulentKineticEnergy" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field,
                           element priority {
                              integer
                           },
                           ## Minimum value of TKE in m2s2. A typical value will be around 1e-6
                           element minimum_value {
                              real
                           }
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Generic second equation used in GLS
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSGenericSecondQuantity" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field,
                           element priority {
                              integer
                           }
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                      )
                  },
                  ## Length scale (a diagnostic with GLS)
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSLengthScale" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Eddy viscosity K_M
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "GLSEddyViscosityKM" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_tensor_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Eddy diffusivity K_H
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "GLSEddyDiffusivityKH" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_tensor_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Buoyancy frequency
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSBuoyancyFrequency" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Velocity shear
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSVelocityShear" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Shear production P
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSShearProduction" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Buoyancy production B
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSBuoyancyProduction" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Dissipation epsilon
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSDissipationEpsilon" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Stability function S_M
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSStabilityFunctionSM" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Stability function S_H
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSStabilityFunctionSH" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Source1 - TKE source term
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSSource1" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Source2 - Second Quantity source term
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSSource2" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Absorption1 - TKE absorption term
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSAbsorption1" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Absorption2 - Second Quantity absorption term
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSAbsorption2" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## GLS Wall function
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSWallFunction" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Background viscosity
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "GLSBackgroundViscosity" },
                     (
                        element prescribed {
                           mesh_choice,
                           prescribed_tensor_field
                        }
                     )
                  }?,                  
                  ## Background diffusivity
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "GLSBackgroundDiffusivity" },
                     (
                        element prescribed {
                           mesh_choice,
                           prescribed_tensor_field
                        }
                     )
                  }?,
                  ## Vertical eddy viscosity
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSVerticalViscosity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,                  
                  ## Vertical eddy diffusivity
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "GLSVerticalDiffusivity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?
               }?,
               element Mellor_Yamada {
                  ## Kinetic Energy
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "KineticEnergy" },
                     attribute replaces { "IDENT = 101" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Turbulent Length Scale x Kinetic Energy
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "TurbulentLengthScalexKineticEnergy" },
                     attribute replaces { "IDENT = 102" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                      )
                  },
                  ## Vertical Viscosity
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "VerticalViscosity" },
                     attribute replaces { "IDENT = 103" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?,
                  ## Vertical Diffusivity of Temperature
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "VerticalDiffusivity" },
                     attribute replaces { "IDENT = 104" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  }?
               }?,
               ## Trivial case in which the user supplies the diffusivity.
               element prescribed_diffusivity {
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "PrescribedDiffusivity" },
                     element prescribed {
                        mesh_choice,
                        prescribed_tensor_field_no_adapt
                     }
                  }
               }?,
               ## [UNDER DEVELOPMENT] Standard k-epsilon model (see Ferziger and Peric(2002) p.295).
               ## Solves 2 additional equations for diffusivity epsilon and turbulent kinetic energy k, in order to close momentum equations.
               element k-epsilon {
                  ## Turbulent kinetic energy (k)
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "TurbulentKineticEnergy" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Turbulent diffusivity (epsilon)
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "TurbulentDiffusivity" },
                     (
                        element prognostic {
                           velocity_mesh_choice,
                           prognostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                      )
                  },
                  ## Length scale (a diagnostic with k-epsilon)
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "LengthScale" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_scalar_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Eddy viscosity
                  element tensor_field {
                     attribute rank { "2" },
                     attribute name { "EddyViscosity" },
                     (
                        element diagnostic {
                           internal_algorithm,
                           velocity_mesh_choice,
                           diagnostic_tensor_field
                        }|
                        element aliased {
                           generic_aliased_field
                        }
                     )
                  },
                  ## Enable this option to use recommended boundary conditions:
                  ## k = 0, and eps = nu * (delta^2 k/delta n^2) on walls, where n = wall normal.
                  element calculate_boundaries {
                     element string_value {
                     "neumann"|"dirichlet"
                     }
                  }?,
                  ## Eddy-viscosity coefficient: nu_T = density * C_mu * k**2 / epsilon.
                  ## Recommended value: 0.09.
                  element C_mu {real},
                  ## Diffusivity production coefficient.
                  ## Recommended value: 1.44.
                  element C_eps_1 {real},
                  ## Diffusivity destruction coefficient.
                  ## Recommended value: 1.92.
                  element C_eps_2 {real},
                  ## Turbulent Schmidt number (eddy viscosity coefficient from k equation).
                  ## Recommended value: 1.0.
                  element sigma_k {real},
                  ## Turbulent Schmidt number (eddy-viscosity coefficient from epsilon equation).
                  ## Recommended value: 1.3.
                  element sigma_eps {real}

               }?
            }?,
            ## Pressure
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Pressure" },
               ## Field type
               (
                  element prognostic {
                     # in the future this can be any mesh_choice:
                     element mesh {
                        attribute name { "PressureMesh" }
                     },
                     prognostic_pressure_field
                  }|
                  element prescribed {
                     # in the future this can be any mesh_choice:
                     element mesh {
                        attribute name { "PressureMesh" }
                     },
                     prescribed_scalar_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Pressure" }
                  }
               )
            }?,
            ## Density
            element scalar_field {
               attribute rank { "0" },
               attribute name { "Density" },
               ## Field type
               (
                  element diagnostic {
                     internal_algorithm,
                     velocity_mesh_choice,
                     diagnostic_scalar_field
                  }|
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_scalar_field
                  }|
                  element prognostic {
                     pressure_mesh_choice,
                     prognostic_density_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Density" }
                  }
               )
            }?,
            ## Velocity vector and momentum options
            element vector_field {
               attribute rank { "1" },
               attribute name { "Velocity" },
               ## Field type
               (
                  element prognostic {
                     element mesh {
                        attribute name { "VelocityMesh" }
                     },
                     prognostic_velocity_field
                  }|
                  element prescribed {
                     element mesh {
                        attribute name { "VelocityMesh" }
                     },
                     prescribed_vector_field
                  }|
                  element aliased {
                     attribute material_phase_name { xsd:string },
                     attribute field_name {"Velocity" }
                  }
               )
            },
            scalar_field_choice*,
            vector_field_choice*,
            tensor_field_choice*,
            ## Parameters required to model spontaneous electrical potentials in porous media.
            element electrical_properties {
               (
                  ## Specify electrical conductivity of fluid (S/m).
                  ## This assumes that salinity and temperature are not used.
                  element conductivity {real}|
                  ## Calculate conductivity from fluid salinity
                  element conductivity_from_salinity {
                     empty
                  }|
                  ## Calculate conductivity from fluid salinity and temperature
                  element conductivity_from_salinity_and_temperature {
                     empty
                  }
               ),
               ## Various coupling coefficients associated with spontaneous potentials.
               element coupling_coefficients {
                  ## Electrokinetic coupling coefficient (V/Pa).
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "Electrokinetic" },
                     (
                        element prescribed {
                           velocity_mesh_choice,
                           prescribed_scalar_field_no_adapt
                        }|
                        element diagnostic {
                           velocity_mesh_choice,
                           scalar_python_diagnostic_algorithm,
                           diagnostic_scalar_field_no_adapt
                        }  
                     )
                  }?,
                  ## Thermoelectric coupling coefficient (V/K).
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "Thermoelectric" },
                     (
                        element prescribed {
                           velocity_mesh_choice,
                           prescribed_scalar_field_no_adapt
                        }|
                        element diagnostic {
                           velocity_mesh_choice,
                           scalar_python_diagnostic_algorithm,
                           diagnostic_scalar_field_no_adapt
                        }  
                     )
                  }?,
                  ## Electrochemical coupling coefficient (V.L/mol).
                  element scalar_field {
                     attribute rank { "0" },
                     attribute name { "Electrochemical" },
                     (
                        element prescribed {
                           velocity_mesh_choice,
                           prescribed_scalar_field_no_adapt
                        }|
                        element diagnostic {
                           velocity_mesh_choice,
                           scalar_python_diagnostic_algorithm,
                           diagnostic_scalar_field_no_adapt
                        }  
                     )
                  }?
               }   
            }?,
            ## Parameters required to model multiphase flow in porous media
            element multiphase_properties {
               ## Relative permeability end point relperm_max
               ## in eq: relperm_max*(saturation/porosity)**(-relperm_exponent)
               ## Value between 0 and 1
               element relperm_max {real},
               ## Relative permeability exponent relperm_exponent
               ## in eq: relperm_max*(saturation/porosity)**(-relperm_exponent)
               element relperm_exponent {real},
               ## Immobile volume of fluid phase
               element immobile_fraction {real}?
            }?,
            sediment?
         }+,
         ## Mesh adaptivity options
         element mesh_adaptivity {
            ## Options involving mesh movement (Lagrangian, ALE methods)
            ##  Allow a moving mesh.
            ##  Assigns memory for grid velocities
            ##  Amends previous timestep`s mass matrix
            element mesh_movement {
               attribute replaces { "MVMESH = TRUE, ZERQG, CMCHAN = TRUE" },
               (
                  ## enable movement of mesh with the free surface
                  element free_surface {
                     (
                        ## Only move the nodes on the free surface using
                        ## the surface height calculated at it.
                        element move_surface_nodes {
                          empty
                        }|
                        ## Move the whole mesh according to the free surface
                        ## height, scaled linearly by the depth from the surface.
                        ##
                        ## Requires the specification of ocean_boundaries under
                        ## geometry.
                        element move_whole_mesh {
                          empty
                        }
                     )
                  }|
                  ## Enable movement of mesh by an imposed Grid Velocity.
                  ## Requires a prescribed GridVelocity field (see below).
                  element imposed_grid_velocity {
                     empty
                  }|
                  ## enable full ale movement of mesh
                  element explicit_ale {
                     element number_of_linesearch_pts {integer},
                     element maximum_iterations {integer},
                     element max_elements_second_level {integer},
                     element functional1_weight {real}, 
                     element functional2_weight {real},
                     element functional3_weight {real}, 
                     element functional4_weight {real},
                     element functional5_weight {real},
                     element minimum_val_functional_change {real},       
                     element minimum_val_functional {real},      
                     element coarse_tolerance {real},
                     element fine_tolerance {real},
                     element gradient_dx {real},  
                     element gradient_dy {real}, 
                     element gradient_dz {real},
                     element move_nodes_in_x {empty}?,
                     element move_nodes_in_y {empty}?,
                     element move_nodes_in_z {empty}?
                  }|
                  ## enable vertical movement of mesh (TBD)
                  element vertical_ale {
                     attribute replaces { "NCOLOP < 0 " },
                     (
                        ## Functionals
                        element physical_functionals {
                           ## move the nodes along an isosurface
                           ##Please specify a scalar field
                           element minimise_relative_velocity_dot_grad_density {
                              attribute replaces { "NCOLOP = -1" },
                              attribute name { xsd:string }
                           }|
                           ## Lock a node to a high curvature region, 
                           ##Please specify a scalar field
                           element use_hessian_density {
                              attribute replaces { "NCOLOP = -2" },
                              attribute name { xsd:string }
                           }
                        },
                        ##Mesh Quality terms
                        element mesh_quality_terms {
                           ##Spring term, default value is 1.0
                           element spring_term {
                              real 
                           }?,
                           ## Exponential term, default value is 1.0
                           element exponential_term{
                              real 
                           }?
                        }?,
                        element block_nodes_in_x {empty}?,
                        element block_nodes_in_y {empty}?,
                        element block_nodes_in_z {empty}?
                     )
                  }                  
               ),
               ## The velocity of the mesh.
               element vector_field {
                  attribute name { "GridVelocity" },
                  attribute rank { "1" },
                  (
                     element diagnostic {
                       internal_algorithm,
                       element mesh {
                         attribute name {  "CoordinateMesh" }
                       },
                       diagnostic_vector_field
                     }|
                     element prescribed {
                       element mesh {
                         attribute name {  "CoordinateMesh" }
                       },
                       prescribed_vector_field_no_adapt
                     }
                  )
               }               
            }?,
            (
               hr_adaptivity |
               prescribed_adaptivity
            )?
         }?,
         ## Information needed are a set of coordinates and 
         ## radius for each particle.
         element imported_solids{       
            (  element solid_type{
                  attribute name {"cylinders"},
                  element cylinder_width{real}
               }|
               element solid_type{
                  attribute name {"spheres"}
               }|
               element solid_type{
                  attribute name {"small_spheres"}
               }|
               element solid_type{
                  attribute name {"external_2D_mesh"},
                  (
                     element mapping_type{
                        attribute name{"brute_force"},
                        empty
                     }|
                     element mapping_type{
                        attribute name{"fastest_n_to_n"},
                        ## As a rule of thumb, (Xmax-Xmin)/(number of bins_x) should be
                        ## greater than (at least twice) the maximum element size
                        ## of the fluid mesh (in the region where the particle is).
                        ## Same thing applies in Y and Z
                        ## directions. Note that in some cases,
                        ## choosing the maximum element size for the
                        ## whole fluid mesh
                        ## might prove to slow down the mapping a
                        ## bit.(bins might not have the
                        ## optimal size)
                        element max_number_of_bins_x{integer},
                        element max_number_of_bins_y{integer},
                        element max_number_of_bins_z{integer},
                        element ntry {integer}
                     }
                  ),
                  element volume_checking_tol{real}
               }|
               element solid_type{
                  attribute name {"external_3D_mesh"},
                  (
                     element mapping_type{
                        attribute name{"brute_force"},
                        empty
                     }|
                     element mapping_type{
                        attribute name{"fastest_n_to_n"},
                        ## As a rule of thumb, (Xmax-Xmin)/(number of bins_x) should be
                        ## greater than (at least twice) the maximum element size
                        ## of the fluid mesh (in the region where the particle is).
                        ## Same thing applies in Y and Z
                        ## directions. Note that in some cases,
                        ## choosing the maximum element size for the whole fluid mesh 
                        ## might prove to slow down the mapping a
                        ## bit.(bins might not have the
                        ## optimal size)
                        element max_number_of_bins_x{integer},
                        element max_number_of_bins_y{integer},
                        element max_number_of_bins_z{integer},
                        element ntry {integer}
                     }
                  ),
                  element volume_checking_tol{real}
               }
            ),
            input_solid_dynamics_choice,
            element number_of_particles {integer},
            element position_script{python_code}?,
            element radius_script{python_code}?,
            element translation_velocity_script{python_code}?,
            element angular_velocity_script{python_code}?,
            element buoyancy {empty}?,
            element oneway {empty}?,
            element solid_concentration_max{real},
            element solid_absorption_factor{real},
            element solid_density{real},
            element use_multimaterials{empty}?,
            element calculate_total_volume{empty}?,
            element create_buffer{
               element buffer{real},
               element solid_concentration_min{real},
               element include_in_drag{empty}?,
               element profile1{real},
               element profile2{real},
               element profile3{real,
                  element constant_profile{real}
               }
            }?,
            element visualize_solidfluid{empty}?,
            element use_particle_cfl{empty}?,
            element calculate_drag{empty}?,
            element output_drag{empty}?,
            element output_particle_vtus{empty}?         
         }?,

         ## traffic model
         element traffic_model {
            ## number of vehicles to be modelled
            element number_of_vehicles{integer},
            ## specify the traffic model input file
            element vehicle_activity_file{attribute file_name { xsd:string }},
            ## traffic_model_time_lag
            ##
            ## traffic_time=traffic_time+lag
            element traffic_model_time_lag{real},
            ## scaling factors between fluidity, traffic and wind tunnel models
            element scale{
               ## between fluidity and field
               ## usually between 1:150 and 1:200
               element model_scale{real},
               ## usually  2.5 - 3.0 m/s
               element reference_velocity_field{real},
               ## normalized should be 1. m/s 
               ## otherwise use the maximum inflow velocity
               element reference_velocity_model{real},
               ## usually in field scale
               ## check specific road network
               element road_network_scale{real},
               ## between fluidity and field
               ## usually between 1:150 and 1:200
               element vehicle_scale{real},
               ## in metres
               element exhaust_diameter{real}
            },
            ## bounding box for traffic network
            ##
            ## ignore vehicles outside this box 
            element bounding_box{
               element x_min{real},
               element x_max{real},
               element y_min{real},
               element y_max{real}
            }?,
            ## if the bottom of the domain is not flat
            ## this makes sure the vehicles will follow the 
            ## road gradient
            ## you need to specify the boundary id of the road
            element sloping_floor{integer}?,
            ## tailpipe emissions
            element emissions_factors{
               ## use a constant emissions factor
               element type{
                  attribute name{"constant_emissions_factors"},
                  element emissions_factor{real}
               }|
               ## use the TRL instantaneous emissions model (IEDB)
               ## this is not open source and therefore the database
               ## needs to be read in
               element type{
                  attribute name{"modelled_emissions_factors"},
                  element passenger_vehicle_petrol{xsd:string}?,
                  element passenger_vehicle_diesel{xsd:string}?,
                  element large_vehicle{xsd:string}?
               }
            }?,
            ## options for the solution of the tailpipe tracer releases
            ## if the emissions factors are not specified
            ## it will use a constant emissions factor
            element scalar_field {
               attribute rank { "0" },
               attribute name { "TrafficTracerTemplate" },
               ## Field type
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }
            }?

         }?,
         biology?,
         forcing?,
         reduced_model?,
         ## Porous Media
         element porous_media {
            ## Specify scalar field Porosity
            element scalar_field {
               attribute name { "Porosity" },
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            },
            ## Specify field Permeability
            (
               element scalar_field {
                  attribute name { "Permeability" },
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_scalar_field
                  }
               }|
               element vector_field {
                  attribute name { "Permeability" },
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_vector_field
                  }
               }|
               element tensor_field {
                  attribute name { "Permeability" },
                  element prescribed { 
                     velocity_mesh_choice,
                     prescribed_tensor_field
                  }
               }
            ),
            ## Specify scalar field Electrical Conductivity
            element scalar_field {
               attribute name { "ElectricalConductivity" },
               element diagnostic {
                  velocity_mesh_choice,
                  (
                     internal_algorithm |
                     scalar_python_diagnostic_algorithm
                  ),
                  diagnostic_scalar_field_no_adapt
               }
            }?,
            element multiphase_parameters {
               ## Capillary pressure multiplier cp_A
               ## in eq: cp_A*((Phase1_saturation+0.00001)**(-cp_expo))
               element cp_A {real}?,
               ## Capillary pressure exponent cp_expo
               ## in eq: cp_A*((Phase1_saturation+0.00001)**(-cp_expo))
               element cp_expo {real}?
            }?
         }?
      }
   )      

sediment = 
   (
      ## A simple sediment model in which different classes of sediment fall 
      ## and diffuse at different rates.
      element sediment {
         ## This field is the basis for all sediment fields. Each
         ## sediment class has a sediment field with name
         ## SedimentClassName where ClassName is the name of the
         ## class.
         ##
         ## By default, all sediment classes have exactly the same
         ## characteristics, however each class can be given its own
         ## settling velocity, diffusivity and initial condition under
         ## the sediment_class element and this will override the
         ## default specified here.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SedimentTemplate" },
            ## Field type
            element prognostic {
               velocity_mesh_choice,
               prognostic_scalar_field
            }
         },
         ## This field is the template for the sediment flux
         ## diagnostic which records the flux of sediment through the
         ## domain boundary.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SedimentFluxTemplate" },
            ## Field type
            element diagnostic {
               ## Surface ids over which to calculate the flux:
               element surface_ids {
                  integer_vector
               },
               velocity_mesh_choice,
               diagnostic_scalar_field
            }
         },
         element sediment_class {
            attribute name { xsd:string },
            initial_condition_scalar*,
            ## Diffusivity for sediment class
            element tensor_field {
               attribute name { "Diffusivity" },
               attribute rank { "2" },
               attribute replaces { "TMUXX TMUYY TMUZZ TMUYZ TMUXZ TMUXY TALLMU TCONMU" },
               (
                  element prescribed {
                     mesh_choice?,
                     prescribed_tensor_field_no_adapt
                  }|
                  element diagnostic {
                    tensor_python_diagnostic_algorithm,
                    diagnostic_tensor_field
                  }
               )
            }?,
            ## Velocity at which this sediment sinks through the water column.
            ## 
            ## This velocity is in the direction of gravity so if the substance
            ## floats upwards, this field should be negative.
            element scalar_field {
               attribute name { "SinkingVelocity" },
               attribute rank { "0" },
               element prescribed {
                  prescribed_scalar_field_no_adapt
               }
            }?,
            ## This is the density of this sediment. It will be used
            ## with the sediment concentration in the equation of state.
            element density {
               real
            }
         }+
      }
   )

# Choice of input method, e.g. for boundary conditions
input_choice_real =
   (
      input_choice_real_contents
   )

input_choice_real_plus_boundary_forcing =
   (
      input_choice_real_contents|
        element from_file {
           element tidal {
                attribute file_name { string },
                attribute variable_name_amplitude { string },
                attribute variable_name_phase { string },
                ## See E.W. Schwiderski - Rev. Geophys. Space
                ## Phys. Vol. 18 No. 1 pp. 243--268, 1980
                ## for details of these constituent.
                attribute name {"M2"|"S2"|"N2"|"K2"|"K1"|"O1"|"P1"|"Q1"|"Mf"|"Mm"|"Ssa"}
           }+
         }|
        ## Set the boundary free-surface height from NEMO data.
        ## A prescribed NEMO pressure scalar field must be set to use this option.
        ## Set the name of the prescribed NEMO pressure scalar field below.
        element NEMO_data {
           attribute field_name { string }
        }
   )

input_choice_real_plus_file =
   (
      input_choice_real_contents|
      ## Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      ##
      ## THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase
      element from_file {
         attribute file_name { xsd:string },
         (
            vtu_input_format
         ),
         comment
      }|
      ## Initialize the field from NEMO data. Note that a file path
      ## under '/ocean_forcing/external_data_boundary_conditions' must
      ## be set to use this option.
      element NEMO_data {
          element format {
              element string_value {
                  "Temperature"|"Salinity"|"Free-surface height"
              }
          }
      }
   )

input_choice_real_contents =
   ## Constant value
   element constant {
      real
   }|
   ## Generic function prescribing real input
   element generic_function {
      anystring
   }|
   ## Python function prescribing real input. Functions should be of the form:
   ##
   ##  def val(X, t):
   ##     # Function code
   ##     return # Return value
   ##
   ## where X is a tuple of length geometry dimension.
   element python {
      python_code
   }

initial_condition_scalar = 
   (
      ## Initial condition for WholeMesh
      ##
      ## Only specify one condition if not using mesh regions.
      ## Otherwise select other initial_condition option, specify region_ids
      ## and distinct names.  Then add extra intial conditions for other regions.
      element initial_condition {
         attribute name { "WholeMesh" },
         input_choice_initial_condition_real
      }|
      ## Multiple initial_conditions are allowed if specifying
      ## different values in different
      ## regions of the mesh (defined by region_ids).  In this case
      ## each initial_condition
      ## requires a distinct name for the options dictionary.
      element initial_condition {
         attribute name { string },
         region_ids,
         input_choice_initial_condition_real
      }
   )

# Choice of input method for initial conditions
# Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
input_choice_initial_condition_real =
   (
      ## Constant value
      element constant {
         real
      }|
      ## Generic function prescribing real input
      element generic_function {
         anystring
      }|
      ## Python function prescribing real input. Functions should be of the form:
      ##
      ##  def val(X, t):
      ##     # Function code
      ##     return # Return value
      ##
      ## where X is a tuple of length geometry dimension.
      element python {
         python_code
      }|
      ## Initialise the field from an existing file (indended
      ## primarily for use in checkpointing). The file mesh must match
      ## the mesh of this field  (except for piecewise constant fields 
      ## which will be remapped back from the discontinuous nodal values). 
      ## In parallel the process number is
      ## appended to the filename, e.g. if the file_name attribute is
      ## set to "input.vtu", process 0 reads from "input-0.vtu".
      element from_file {
         attribute file_name { xsd:string },
         (
            vtu_input_format|
            netcdf_input_format
         ),
         comment
      }|
      ## Initialize the field from NEMO data. Note that a file path
      ## under '/ocean_forcing/external_data_boundary_conditions' must
      ## be set to use this option.
      element NEMO_data {
          element format {
              element string_value {
                  "Temperature"|"Salinity"|"Free-surface height"
              }
          }
      }
   )

# Choice of input method, e.g. for boundary conditions
input_choice_real_dim_vector =
   (
      input_choice_real_dim_vector_contents
   )

# Choice of input method, e.g. for prescribed fields
input_choice_real_dim_vector_plus_file =
   (
      input_choice_real_dim_vector_contents|
      ## Initialise the field from an existing file (indended primarily for picking up prescribed fields from previously run prognostic simulations). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      ##
      ## THIS WILL NOT WORK FOR PRESCRIBED FIELDS NOT DIRECTLY UNDERNEATH /material_phase
      element from_file {
         attribute file_name { xsd:string },
         (
            vtu_input_format
         ),
         comment
      }|
      ## Initialize the field from NEMO data. Note that a file path
      ## under '/ocean_forcing/external_data_boundary_conditions' must
      ## be set to use this option.
      element NEMO_data {
          ## Currently, only the velocity vector field may be initialised in this manner.
          element format {
              element string_value {
                  "Velocity"
              }
          }
      }
   )

input_choice_real_dim_vector_contents =
   ## Constant value
   element constant {
      real_dim_vector
   }|
   ## Python function prescribing dimensional vector input. Functions should be of the form:
   ##
   ##  def val(X, t):
   ##     # Function code
   ##     return # Return value
   ##
   ## where X and the return value are tuples of length geometry dimension.
   element python {
      python_code
   }

# Choice of input method, e.g. for boundary conditions
# this one specifies a vector field of dim minus one
input_choice_real_dim_minus_one_vector =
   (
      ## Constant value
      element constant {
         real_dim_minus_one_vector
      }|
      # ## Generic function prescribing dimensional vector input
      # element generic_function {
      #    anystring
      # }|
      ## Python function prescribing dimensional vector input. Functions should be of the form:
      ##
      ##  def val(X, t):
      ##     # Function code
      ##     return # Return value
      ##
      ## where X and the return value are tuples of length geometry dimension.
      element python {
         python_code
      }
   )

## Import data from NetCDF CF-1.x file.
input_choice_netcdf =
   (
      element from_file {
         ## The format of this file should conform to NetCDF CF 1.x
         ## (http://cf-pcmdi.llnl.gov/)
         attribute file_name { xsd:string },
         comment
      }
   )

# Choice of input method for initial conditions
# Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
input_choice_initial_condition_vector =
   (
      ## Constant value
      element constant {
         real_dim_vector
      }|
      # ## Generic function prescribing dimensional vector input
      # element generic_function {
      #    anystring
      # }|
      ## Python function prescribing dimensional vector input. Functions should be of the form:
      ##
      ##  def val(X, t):
      ##     # Function code
      ##     return # Return value
      ##
      ## where X and the return value are tuples of length geometry dimension.
      element python {
         python_code
      }|
      ## Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field (except for piecewise constant fields which will be remapped back from the discontinuous nodal values).
      element from_file {
         attribute file_name { xsd:string },
         (
            vtu_input_format
         ),
         comment
      }|
      ## Initialize the field from NEMO data. Note that a file path
      ## under '/ocean_forcing/external_data_boundary_conditions' must
      ## be set to use this option.
      element NEMO_data {
          ## Currently, only the velocity vector field may be initialised in this manner.
          element format {
              element string_value {
                  "Velocity"
              }
          }
      }
   )  

# Choice of input method for initial/boundary conditions
# version for real symmetric tensor
input_choice_real_dim_symmetric_tensor =
   (
      ## Constant symmetric tensor
      element constant {
         real_dim_symmetric_tensor
      }|
#      ## Generic function prescribing symmetric tensor input
#      element generic_function {
#         anystring
#      }|
      ## Python command prescribing symmetric tensor input.
      ##
      ## Note that it is for the python function to determine 
      ## that the results it produces are, in fact, symmetric.
      ##
      ## An example that returns the three-dimensional identity:
      ##
      ##  def val(X, t):
      ##    return [[1, 0, 0],
      ##                [0, 1, 0],
      ##                [0, 0, 1]]
      element python {
         python_code
      }
   )

# Choice of input method for initial/boundary conditions
# version for real tensor
input_choice_real_dim_tensor =
   (
      ## Constant tensor
      element constant {
         real_dim_tensor
      }|
#      }|
#      ## Generic function prescribing tensor input
#      element generic_function {
#         anystring
#      }|
      ## Python command prescribing tensor input.
      ##
      ## An example that returns the three-dimensional identity:
      ##
      ##  def val(X, t):
      ##    return [[1, 0, 0],
      ##                [0, 1, 0],
      ##                [0, 0, 1]]
      element python {
         python_code
      }
   )

prognostic_velocity_field =
   (
      velocity_equation_choice,
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## A new version of continuous galerkin assembly.
            element continuous_galerkin {
               advection_stabilisation_options,
               ## Discretisation options for the mass terms in the velocity equation.
               element mass_terms{
                  ## Lump the mass matrix - currently required if solving for pressure
                  ## and not using the schur complement scheme under Pressure
                  element lump_mass_matrix {
                     ## Lump on the submesh.
                     ## This only works for simplex meshes and is only
                     ## strictly valid on 2d meshes.
                     element use_submesh {
                       empty
                     }?
                  }?,
                  ## Remove the mass terms from the equation.
                  element exclude_mass_terms {
                     empty
                  }?
               },
               ## Discretisation options for the advection terms in the velocity equation.
               element advection_terms {
                  ## Integrate the advection terms of the momentum equation by parts.
                  ## This allows for the imposition of weak boundary conditions.
                  ## If activated the element advection matrix takes the form:
                  ##    /                                            /
                  ##  - | (grad N_A dot nu) N_B rho dV - (1. - beta) | N_A ( div nu ) N_B rho dV
                  ##    /                                            /
                  ## otherwise it takes the standard form:
                  ##    /                                     /
                  ##    | N_A (nu dot grad N_B) rho dV + beta | N_A ( div nu ) N_B rho dV
                  ##    /                                     /
                  ## where beta is set in conservative_advection, N is
                  ## a shape function and nu is the relative nonlinear
                  ## velocity.
                  element integrate_advection_by_parts {
                     empty
                  }?,
                  ## Remove the advection terms (u.grad u rho + beta
                  ## div u rho u) from the equation.
                  ## This overrides any other advection term options
                  ## (including conservative_advection below).
                  element exclude_advection_terms {
                     empty
                  }?
               },
               ## Discretisation options for the stress terms in the velocity equation.
               element stress_terms {
                  (
                     ## Use tensor form of the stress terms:
                     ##
                     ## mu u_{i,jj}
                     ##
                     ## This is only valid for incompressible
                     ## simulations as it is basically a simplication
                     ## of full stress form when divergent elements can
                     ## be cancelled out.
                     ##
                     ## Only diaonal components of viscosity
                     ## (i.e. either isotropic or
                     ## diagonal) are physical for isotropic materials.
                     ##
                     ## If components differ from each other
                     ## this must be for numerical reasons (i.e. not
                     ## physical variations in viscosity otherwise
                     ## simplification is not valid).
                     ##
                     ## If activated, the dim x dim (in this example
                     ## 3d) discrete stress matrix takes the form:
                     ##
                     ##  /  mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z
                     ##  |   0                                             ...
                     ##  \   0
                     ##
                     ##      0
                     ##  ... mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z   ...
                     ##      0
                     ##
                     ##      0                                                           \
                     ##  ... 0                                                           |
                     ##     mu_xx*N_a,x*N_b,x + mu_yy*N_a,y*N_b,y + mu_zz*N_a,z*N_b,z   /
                     ##
                     ## which is derived from b_a^T c b_b, where:
                     ##
                     ##  b_a = / N_a,x  \   c = /  mu_xx    0      0    \
                     ##        | N_a,y  |       |    0    mu_yy    0    |
                     ##        \ N_a,z  /       \    0      0    mu_zz  /
                     ##
                     ## where N_a and N_b are shape functions of the
                     ## ath and bth node respectively and mu are the
                     ## components of the viscosity tensor.
                    element tensor_form {
                      empty
                    }|
                     ## Use full stress form of the stress tensor:
                     ##
                     ## 2*mu (u_{(i,j)} - 1/3*\delta_{ij}u_{k,k})
                     ##
                     ## This couples the velocity components together.
                     ## It is required if performing a compressible simulation.
                     ##
                     ## If using a viscosity ALL COMPONENTS OF
                     ## VISCOSITY MUST BE SET (i.e. either
                     ## anisotropic_symmetric or
                     ## anisotropic_asymmetric tensors).
                     ##
                     ## If components differ form each other this must
                     ## be for numerical reasons (i.e. not physical
                     ## variations in viscosity as the material is isotropic).
                     ##
                     ## If activated, the dim x dim (in this example
                     ## 3d) discrete stress matrix takes the form:
                     ##
                     ##  /   4/3*N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_xy + N_a,z*N_b,z*mu_xz
                     ##  |   N_a,x*N_b,y*mu_xy - 2/3*N_a,y*N_b,x*mu_yx                       ...
                     ##  \   N_a,x*N_b,z*mu_xz - 2/3*N_a,z*N_b,x*mu_zx
                     ##
                     ##      N_a,y*N_b,x*mu_xy - 2/3*N_a,x*N_b,y*mu_xy
                     ##  ... N_a,x*N_b,x*mu_xy + 4/3*N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_yz   ...
                     ##      N_a,y*N_b,z*mu_yz - 2/3*N_a,z*N_b,y*mu_zy
                     ##
                     ##      N_a,z*N_b,x*mu_xz - 2/3*N_a,x*N_b,z*mu_xz                       \
                     ##  ... N_a,z*N_b,y*mu_yz - 2/3*N_a,y*N_b,z*mu_yz                       |
                     ##      N_a,x*N_b,x*mu_xz + N_a,y*N_b,y*mu_yz + 4/3*N_a,z*N_b,z*mu_zz   /
                     ##
                     ## which is derived from b_a^T c b_b, where:
                     ##
                     ##  b_a = / N_a,x   0     0   \   c = /  4/3*mu_xx  -2/3*mu_xy -2/3*mu_xz  0    0    0   \
                     ##        |  0    N_a,y   0   |       | -2/3*mu_yx   4/3*mu_yy -2/3*mu_yz  0    0    0   |
                     ##        |   0     0   N_a,z |       | -2/3*mu_zx  -2/3*mu_zy  4/3*mu_zz  0    0    0   |
                     ##        | N_a,y N_a,x   0   |       |     0           0          0     mu_xy  0    0   |
                     ##        | N_a,z   0   N_a,x |       |     0           0          0       0  mu_xz  0   |
                     ##        \   0   N_a,z N_a,y /       \     0           0          0       0    0  mu_yz /
                     ##
                     ## where N_a and N_b are shape functions of the ath and bth node respectively and mu are the components of the viscosity tensor.
                     element stress_form {
                        ## Use the legacy form of the stress tensor.
                        ##
                        ## This differs from the standard method in how the components 
                        ## of the viscosity tensor are distributed.
                        ##
                        ## If activated, the dim x dim (in this case
                        ## 3d) stress matrix takes the form:
                        ##
                        ##  /   4/3*N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_zz
                        ##  |   N_a,x*N_b,y*mu_yx - 2/3*N_a,y*N_b,x*mu_yy                     ...
                        ##  \   N_a,x*N_b,z*mu_zx - 2/3*N_a,z*N_b,x*mu_zz
                        ##
                        ##      N_a,y*N_b,x*mu_xy - 2/3*N_a,x*N_b,y*mu_xx
                        ##  ... N_a,x*N_b,x*mu_xx + 4/3*N_a,y*N_b,y*mu_yy + N_a,z*N_b,z*mu_zz ...
                        ##      N_a,y*N_b,z*mu_zy - 2/3*N_a,z*N_b,y*mu_zz
                        ##
                        ##      N_a,z*N_b,x*mu_xz - 2/3*N_a,x*N_b,z*mu_xx                     \
                        ##  ... N_a,z*N_b,y*mu_yz - 2/3*N_a,y*N_b,z*mu_yy                     |
                        ##      N_a,x*N_b,x*mu_xx + N_a,y*N_b,y*mu_yy + 4/3*N_a,z*N_b,z*mu_zz /
                        ##
                        ## where N_a and N_b are shape functions of
                        ## the ath and bth node respectively and mu
                        ## are the components of the viscosity tensor.
                      element legacy_stress_form {
                        empty
                      }?
                    }
                  )
               },
               ## large-eddy simulation
               element les_model {
                  ## literature sybol: Cs
                  ##
                  ## suggested value 0.1
                  element smagorinsky_coefficient {
                     real
                  },
                  ## les options
                  element order {
                     ## similar to the original Smag model
                     element second_order{empty}
                   |
                     ## this adds a fourth order operator to tackle the
                     ## dissipation issues of the original Smag model
                     ##
                     ## use this if your turbulence dissipates faster than it should
                     ##
                     ## requires a fine mesh to perform well
                     element fourth_order{empty}
                  }
               }?
            }|
            ## Discontinuous galerkin formulation. Confusingly it is not necessary to provide
            ## a discontinuous velocity field for this to work!
            element discontinuous_galerkin {
               attribute replaces { "DISOPT" },
               ## Discretisation options for the mass terms in the velocity equation.
               element mass_terms{
                  ## Lump the mass matrix
                  element lump_mass_matrix {
                    empty
                  }?,
                  ## Remove the mass terms from the equation.
                  element exclude_mass_terms {
                     empty
                  }?
               }?,
               element viscosity_scheme {
                  (
                     ## Classical scheme from Bassi and Rebay 
                     ## (JCP 131 267-179 1997)
                     element bassi_rebay {
                        empty
                     }|
                     ## Scheme in which upwinding is applied in
                     ## alternating directions. Devised by C.Pain.
                     element arbitrary_upwind {
                        empty
                     }|
                     ## Classical interior penalty scheme
                     ## see, e.g., SIAM Journal on Numerical Analysis
                     ## Vol. 39, No. 5 (2002), pp. 1749-1779 
                     element interior_penalty {
                        ## Penalty_parameter
                        ## The penalty term Int [u][v] dS on element boundaries
                        ## is scaled by C = C_0 h**p
                        ## This option specifies the C_0
                        ## There is a theoretical lower bound for 
                        ## stability and hence convergence
                        element penalty_parameter {
                           real
                        },
                        ## Penalty_parameter
                        ## The penalty term Int [u][v] dS on element boundaries
                        ## is scaled by C = C_0 h**p
                        ## This option specifies p
                        ## Theoretically p=-1 is required for linear elements
                        element edge_length_power {
                           real
                        },
                        ## Option for how to compute the edge length h
                        element edge_length_option {
                           ## Use face integral (take sqrt in 3D)
                           element use_face_integral {
                              empty
                           }|
                           ## Use difference between element centre 
                           ## and neighbour centre
                           ## Use 2x distance to face centre on boundaries
                           element use_element_centres {
                              empty
                           }
                        },
                        ## Switch on debugging output
                        element debug {
                           ## Bound for testing element gradient matrix
                           element gradient_test_bound {
                              real
                           },
                           ## Remove the elemental integral:
                           ## Int grad u.kappa.grad v dV
                           element remove_element_integral {
                              empty
                           }?,
                           ## Remove the primal fluxes
                           element remove_primal_fluxes {
                              empty
                           }?,
                           ## Remove the penalty fluxes
                           element remove_penalty_fluxes {
                              empty
                           }?
                        }?
                     }
                  )
               },
               element advection_scheme {
                  (
                     ## Straightforward upwinding of the nonlinear velocity.
                     element upwind {
                        empty
                     }|
                     ## Disable advection
                     element none {
                        empty
                     }
                  ),
                  ## Integrate the advection terms of the momentum equation by parts.
                  ##
                  ## Integrating the advection term by parts is
                  ## necessary for a discontinuous
                  ## galerkin discretisation however it is possible to
                  ## select how many times the
                  ## integration by parts is performed.
                  ## Twice is the norm.
                  element integrate_advection_by_parts {
                    (
                      ## If activated the element advection matrix takes the form:
                      ##    /                                 /
                      ##    | N_A (nu dot grad N_B) dV + beta | N_A ( div nu ) N_B dV
                      ##    /                                 /
                      ##      /                                         /
                      ##  + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - 1] | N_A_i (nu dot n) N_B_i ds
                      ##      /                                         /
                      ## where beta is set in conservative_advection,
                      ## N is a shape function (uppercase
                      ## subscripts indicate nodes A or B while
                      ## lowercase subscripts indicate inner or outer
                      ## faces i and o respectively), nu is the
                      ## nonlinear velocity and n is the outward
                      ## pointing normal from the element.
                      element twice {
                        empty
                      }|
                      ## If activated the element advection matrix takes the form:
                      ##    /                                        /
                      ##  - | (grad N_A dot nu) N_B dV - (1. - beta) | N_A ( div nu ) N_B dV
                      ##    /                                        /
                      ##      /                                   /
                      ##  + I | N_A_i (nu dot n) N_B_o ds + (1-I) | N_A_i (nu dot n) N_B_i ds
                      ##      /                                   /
                      ## where beta is set in conservative_advection,
                      ## N is a shape function (uppercase
                      ## subscripts indicate nodes A or B while
                      ## lowercase subscripts indicate inner or outer
                      ## faces i and o respectively), nu is the
                      ## nonlinear velocity and n is the outward
                      ## pointing normal from the element.
                      element once {
                        empty
                      }
                    )
                  },
                  ## If activated the conservation term:
                  ##  /
                  ##  | N_A ( div nu ) N_B dV
                  ##  /
                  ## is integrated_by_parts such that the element
                  ## advection matrix becomes:
                  ##         /                                        /
                  ##  - beta | (grad N_A dot nu) N_B dV + (1. - beta) | N_A (nu dot grad N_B) dV
                  ##         /                                        /
                  ##      /                                                /
                  ##  + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - (1-beta)] | N_A_i (nu dot n) N_B_i ds
                  ##      /                                                /                  
                  ## where beta is set in conservative_advection, N is
                  ## a shape function (uppercase
                  ## subscripts indicate nodes A or B while lowercase
                  ## subscripts indicate inner or outer
                  ## faces i and o respectively), nu is the nonlinear
                  ## velocity and n is the outward pointing normal
                  ## from the element.
                  ## This is invariant regardless of whether the main
                  ## advection term is integrated by parts once or
                  ## twice.
                  element integrate_conservation_term_by_parts {
                    empty
                  }?
               }
            }
         ),
         ## Conservative discretisation of momentum equations
         ##  BETA=1. -- conservative (divergence form)
         ##  BETA=0. -- non-conservative
         ##  0. < BETA < 1.
         element conservative_advection {
            attribute replaces {"BETA"},
            real
         }
      },
      ## Temporal discretisation options
      element temporal_discretisation {
         ## Implicit/explicit control (THETA)
         ##  =0.  -- explicit
         ##  =0.5 -- Crank-Nicolson
         ##  =1.  -- implicit
         element theta {
            attribute replaces {"THETA"},
            real
         },
         ## Non-linear relaxation term
         ##  =0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
         ##  =1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
         ##  0. < ITHETA < 1.
         element relaxation {
            attribute replaces {"ITHETA"},
            real
         },
         element discontinuous_galerkin {
            (
               ## Use timestep subcycling to solve this equation.
               element advection_cycling {
                  ## Specify the number of subcycles.
                  element number_advection_subcycles {
                     integer
                  },
                  ## Specify whether coriolis should be included in the 
                  ## subcycling.
                  element coriolis_in_subcycles {
                     empty
                  }?
               }
            )?
         }?
      },
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_vector
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_vector
         }
      )+,
      ## Boundary conditions
      element boundary_conditions {
         attribute replaces { "boundary, TMPER1 TMPER2 TMPERI" },
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         velocity_boundary_conditions
      }*,
      ## For a Newtonian fluid this is the shear viscosity.
      ##
      ## For continuous_galerkin see stress_terms to see how the
      ## viscosity tensor is dealt with in the momentum equation.
      element tensor_field {
         attribute replaces {"MUPTXX MUPTYY MUPTZZ MUPTYZ MUPTXZ MUPTXY RMUPXX RMUPYY RMUPZZ RMUPYZ RMUPXZ RMUPXY CONMU ALLMU TWOMU ONEMU"},
         attribute name { "Viscosity" },
         attribute rank { "2" },
         (
            element prescribed {
               mesh_choice?,
               prescribed_tensor_field_no_adapt
            }|
            element diagnostic {
               mesh_choice?,
               (
                  bulk_viscosity_algorithm |
                  tensor_python_diagnostic_algorithm
               ),
               diagnostic_tensor_field
            }
         )
      }?,
      ## Source
      element vector_field {
         attribute name { "Source" },
         attribute rank { "1" },
         attribute replaces { "CONSOX CONSOY CONSOZ RONSOX RONSOY RONSOZ ZSOX ZSOY ZSOZ" },
         (
            element prescribed {
               mesh_choice?,
               prescribed_vector_field_no_adapt
            }|
            element diagnostic {
               (
                  vector_python_diagnostic_algorithm |
                  imposed_material_velocity_source_algorithm |
                  internal_velocity_source_algorithm
               ),
               diagnostic_vector_field
            }
         ),
         element lump_source {
            attribute replaces { "SLUMP" },
            empty
         }?
      }?,
      ## Absorption
      element vector_field {
         attribute name { "Absorption" },
         attribute rank { "1" },
         attribute replaces { "XABSZE YABSZE ZABSZE XABS YABS ZABS XABSOR YABSOR ZABSOR XABSCO YABSCO ZABSCO" },
         (
            element prescribed {
               prescribed_vector_field_no_adapt
            }|
            element diagnostic { 
               (
                  vector_python_diagnostic_algorithm |
                  imposed_material_velocity_absorption_algorithm |
                  internal_velocity_absorption_algorithm
               ),
               diagnostic_vector_field
            }
         ),
         (
           ## Default absorption: no lumping, is fully evaluated before the
           ## the pressure correction.
           element default_absorption {
              attribute replaces {"ABSLUM"},
              empty
           }|
           ## Lump the inclusion of absorbtion terms.
           element lump_absorption {
              attribute replaces {"ABSLUM"},
              ## Lump on the submesh.
              ## This only works for simplex meshes and is only
              ## strictly valid on 2d meshes.
              element use_submesh {
                empty
              }?
           }|
           ## Includes the pressure correction to the velocity in the
           ## absorption term (for theta>0). This makes the absorption
           ## term more implicit. The absorption term is lumped if and
           ## only if the mass matrix is lumped (lump_mass_matrix).
           element include_pressure_correction {
              empty
           }
         )
      }?,
      ## SurfaceTension
      element tensor_field {
         attribute name { "SurfaceTension" },
         attribute rank { "2" },
         (
            element diagnostic {
                internal_algorithm,
                attribute field_name { "MaterialVolumeFraction" },
                ## Choose whether the mass matrix is lumped or not for the calculation of the gradient
                element lump_mass_matrix {
                  empty
                }?,
                ## Solver options are necessary if you're not lumping your mass or if you're field isn't dg
                element solver {
                  linear_solver_options_sym
                }?,
                ## Choose whether the surface tension term in the momentum equation is integrated by parts or not
                element integrate_by_parts {
                  empty
                }?,
                diagnostic_tensor_field
            }
         )
      }?,
      prognostic_vector_output_options,
      prognostic_velocity_stat_options,
      vector_convergence_options,
      prognostic_detector_options,
      vector_steady_state_options,
      adaptivity_options_prognostic_vector_field,
      interpolation_algorithm_vector,
      discrete_properties_algorithm_vector?
   )

prognostic_scalar_field =
   (
      scalar_equation_choice,
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## Continuous Galerkin formulation
            element continuous_galerkin {
               advection_stabilisation_options,
               ## Discretisation options for the advection terms.
               element advection_terms {
                  ## Integrate the advection terms of the advection equation by
                  ## parts.
                  element integrate_advection_by_parts {
                     comment
                  }?,
                  ## Remove the advection terms from the equation.
                  ## This overrides any other advection term options (including
                  ## conservative_advection below).
                  element exclude_advection_terms {
                     comment
                  }?
               },
               ## Discretisation options for the mass terms.
               element mass_terms {
                  ## Lump the mass matrix
                  element lump_mass_matrix {
                     attribute replaces { "TLUMP" },
                     empty
                  }?,
                  ## Remove the mass terms from the equation. This requires an
                  ## implicitness factor theta = 1.0 (under
                  ## temporal_discretisation).
                  element exclude_mass_terms {
                     empty
                  }?
               },
               comment
            }|
            ## Discontinuous galerkin formulation. You can also use this
            ## formulation with a continuous field in which case a simple
            ## galerkin formulation will result. 
            element discontinuous_galerkin {
               attribute replace { "70 <= DISOTT <= 90" },
               element advection_scheme {
                  (
                     ## Straightforward upwinding of the nonlinear velocity.
                     ## This uses SU stabilisation with optimal choice for the
                     ## stabilisation parameter, and stabilisation parameter
                     ## scale factor 0.5.
                     element upwind {
                        empty
                     }|
                     ## Disable advection
                     element none {
                        empty
                     }
                  ),
                  ## Integrate the advection terms of the
                  ## advection-diffusion equation by parts.
                  ## Integrating the advection term by parts is
                  ## necessary for a discontinuous
                  ## galerkin discretisation however it is possible to
                  ## select how many times the
                  ## integration by parts is performed.
                  ## Twice is the norm.
                  element integrate_advection_by_parts {
                    (
                      ## If activated the element advection matrix takes the form:
                      ##    /                                 /
                      ##    | N_A (nu dot grad N_B) dV + beta | N_A ( div nu ) N_B dV
                      ##    /                                 /
                      ##      /                                         /
                      ##  + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - 1] | N_A_i (nu dot n) N_B_i ds
                      ##      /                                         /
                      ## where beta is set in conservative_advection,
                      ## N is a shape function (uppercase
                      ## subscripts indicate nodes A or B while
                      ## lowercase subscripts indicate inner or outer
                      ## faces i and o respectively), nu is the
                      ## nonlinear velocity and n is the outward
                      ## pointing normal from the element.
                      element twice {
                        empty
                      }|
                      ## If activated the element advection matrix takes the form:
                      ##    /                                        /
                      ##  - | (grad N_A dot nu) N_B dV - (1. - beta) | N_A ( div nu ) N_B dV
                      ##    /                                        /
                      ##      /                                   /
                      ##  + I | N_A_i (nu dot n) N_B_o ds + (1-I) | N_A_i (nu dot n) N_B_i ds
                      ##      /                                   /
                      ## where beta is set in conservative_advection,
                      ## N is a shape function (uppercase
                      ## subscripts indicate nodes A or B while
                      ## lowercase subscripts indicate inner or outer
                      ## faces i and o respectively), nu is the
                      ## nonlinear velocity and n is the outward
                      ## pointing normal from the element.
                      element once {
                        empty
                      }
                    )
                  },
                  ## If activated the conservation term:
                  ##  /
                  ##  | N_A ( div nu ) N_B dV
                  ##  /
                  ## is integrated_by_parts such that the element
                  ## advection matrix becomes:
                  ##         /                                        /
                  ##  - beta | (grad N_A dot nu) N_B dV + (1. - beta) | N_A (nu dot grad N_B) dV
                  ##         /                                        /
                  ##      /                                                /
                  ##  + I | N_A_i (nu dot n) N_B_o ds + [(1-I) - (1-beta)] | N_A_i (nu dot n) N_B_i ds
                  ##      /                                                /                  
                  ## where beta is set in conservative_advection, N is
                  ## a shape function (uppercase
                  ## subscripts indicate nodes A or B while lowercase
                  ## subscripts indicate inner or outer
                  ## faces i and o respectively), nu is the nonlinear
                  ## velocity and n is the outward pointing normal
                  ## from the element.
                  ## This is invariant regardless of whether the main
                  ## advection term is integrated by parts once or
                  ## twice.
                  element integrate_conservation_term_by_parts {
                    empty
                  }?
               },
               element diffusion_scheme {
                  (
                     ## Classical scheme from Bassi and Rebay 
                     ## (JCP 131 267-179 1997)
                     element bassi_rebay {
                        empty
                     }|
                     ## Compact discontinuous Galerkin scheme.
                     ## (Peraire and Persson SIAM J. Sci. Comput. 30, p1806)
                     element compact_discontinuous_galerkin {
                        ## Penalty_parameter
                        ## Add penalty term Int [u][v] dS on element boundaries
                        ## scaled by C_0
                        element penalty_parameter {
                           real
                        }?,
                        ## Switch on debugging output
                        element debug {
                           ## Bound for testing element gradient matrix
                           element gradient_test_bound {
                              real
                           },
                           ## Remove the elemental integral:
                           ## Int grad u.kappa.grad v dV
                           element remove_element_integral {
                              empty
                           }?,
                           ## Remove the primal fluxes
                           element remove_primal_fluxes {
                              empty
                           }?,
                           ## Remove the CDG fluxes
                           element remove_cdg_fluxes {
                              empty
                           }?,
                           ## When present, the penalty term
                           ## Int [u][v] dS on element boundaries is
                           ## scaled by C = C_0 h**p This option
                           ## specifies p.
                           element edge_length_power {
                              real
                           }?
                        }?
                     }|
                     ## Scheme in which upwinding is applied in
                     ## alternating directions. Devised by C.Pain.
                     element arbitrary_upwind {
                        empty
                     }|
                     ## Classical interior penalty scheme
                     ## see, e.g., SIAM Journal on Numerical Analysis
                     ## Vol. 39, No. 5 (2002), pp. 1749-1779 
                     element interior_penalty {
                        ## Penalty_parameter
                        ## The penalty term Int [u][v] dS on element boundaries
                        ## is scaled by C = C_0 h**p
                        ## This option specifies the C_0
                        ## There is a theoretical lower bound for 
                        ## stability and hence convergence
                        element penalty_parameter {
                           real
                        },
                        ## Penalty_parameter
                        ## The penalty term Int [u][v] dS on element boundaries
                        ## is scaled by C = C_0 h**p
                        ## This option specifies p
                        ## Theoretically p=-1 is required for linear elements
                        element edge_length_power {
                           real
                        },
                        ## Option for how to compute the edge length h
                        element edge_length_option {
                           ## Use face integral (take sqrt in 3D)
                           element use_face_integral {
                              empty
                           }|
                           ## Use difference between element centre 
                           ## and neighbour centre
                           ## Use 2x distance to face centre on boundaries
                           element use_element_centres {
                              empty
                           }
                        },
                        ## Switch on debugging output
                        element debug {
                           ## Bound for testing element gradient matrix
                           element gradient_test_bound {
                              real
                           },
                           ## Remove the elemental integral:
                           ## Int grad u.kappa.grad v dV
                           element remove_element_integral {
                              empty
                           }?,
                           ## Remove the primal fluxes
                           element remove_primal_fluxes {
                              empty
                           }?,
                           ## Remove the penalty fluxes
                           element remove_penalty_fluxes {
                              empty
                           }?
                        }?
                     }
                  )
               },
               ## This introduces a simple upwind diffusion based on eqn 2.52 in 
               ## Donea and Huerta (2003) "Finite elements for flow problems".
               element upwind_stabilisation {
                  empty
               }?,
               (
                  element slope_limiter {
                     attribute name { "Cockburn_Shu" },
                     ## TVB tolerance parameter, below this value (scaled by
                     ## dx**2) no limiting is done.
                     ## Reduce to do more limiting, increase to do less
                     ## Minimum value 0.0
                     ## Suggested value 5.0
                     element TVB_factor {
                        real
                     },
                     ## Tolerate negative weights in the reconstruction
                     ## Algorithm finds the "least bad" coordinates to use.
                     ## May lead to overshoots on funky meshes.
                     element tolerate_negative_weights {
                        empty
                     }?,
                     ## Limit factor
                     ## This value is used to scale the reconstructed slope
                     ## Minimum value 1.0
                     ## Suggested value 1.1
                     element limit_factor {
                        real
                     }
                  }|
                  ## Hermite-WENO limiter
                  element slope_limiter {
                     attribute name { "Hermite_Weno" },
                     ##Power coefficient in weights.
                     ##This must be a positive number, possibly
                     ##an integer. Larger power coefficient leads
                     ##to greater penalisation of oscillations, on 
                     ##the other hand causes numerical problems if it
                     ##gets too big.
                     ##Suggested value = 4.
                     element power_coefficient {
                        real
                     },
                     ##Relative/absolute tolerance threshold for 
                     ##oscillation indicator. Values below this emphasise
                     ##absolute rather than relative magnitudes of 
                     ##tracer gradients. 
                     ##Suggested value = 0.001*T
                     ##where T is a typical value of the tracer which
                     ##you might use in a scaling analysis.
                     element tolerance_threshold_oscillations {
                        real
                     },
                     ##Relative/absolute tolerance threshold for 
                     ##weights. Values below this emphasise
                     ##absolute rather than relative magnitudes of 
                     ##oscillations indicator. 
                     ##Suggested value = 1.0e-3
                     element tolerance_threshold_weights {
                        real
                     },
                     ##Tolerance for discontinuity detector.
                     ##Uses method of 
                     ##http://www.gce.ucl.ac.be/~remacle/pdf/detect.pdf
                     ##Detector values greater than this indicate
                     ##discontinuities at the inflow boundary
                     ##Suggested value = L^(-p-1)/2)
                     ##where L is the horizontal lengthscale
                     ##and p is the polynomial order
                     element discontinuity_tolerance {
                        real
                     },
                     ##Tolerance for limiter
                     ##Doesn't apply limiter if max abs value of tracer
                     ##over the element is below this tolerance
                     ##Recommended value is something very small
                     ##but not zero
                     element limit_tolerance {
                        real
                     },
                     (
                        ##At boundaries there are less polynomials to
                        ##construct. With this option, the missing
                        ##polynomials are simply ignored.
                        element boundary_treatment {
                           attribute name { "ignore_missing_polys" }
                        }|
                        ##At boundaries there are less polynomials to
                        ##construct. With this option, the missing
                        ##polynomials are replaced with the polynomial
                        ##in the current element.
                        element boundary_treatment {
                           attribute name { "replace_missing_polys" }
                        }|
                        ##At boundaries there are less polynomials to
                        ##construct. With this option, the reconstruction
                        ##is applied at one order down.
                        ##Since HWENO currently only works for P1,
                        ##this amounts to L_2 projection to P0.
                        element boundary_treatment {
                           attribute name { "lower_order" }
                        }
                     ),
                     ##Switch to chuck out lots of debugging output.
                     ##Not for production runs.
                     element debugging {
                        empty
                     }?,
                     ##Don't include Hermite polynomials.
                     element leave_out_hermite_polynomials {
                        empty
                     }?
                  }|
                  element slope_limiter {
                     attribute name { "minimal" }
                  }
               )?,
               ## Discretisation options for the mass terms.
               element mass_terms {
                  ## Remove the mass terms from the equation.
                  element exclude_mass_terms {
                     empty
                  }?
               }?
            }|
            pure_cv_options|
            coupled_cv_options|
            ## **DO NOT USE!**
            ## This is a temporary discretisation option to help Cian
            ## implement P0 advection-diffusion.
            element finite_volume {
               element diffusion_scheme {
                  (
                     element bassi_rebay {
                        element penalty {
                          real
                        }?
                     }|
                     element ldg {
                        empty
                     }
                  )
               }
            }
         ),
         ## Conservative discretisation of field advection equation
         ##  TBETA=1. -- conservative (divergence form)
         ##  TBETA=0. -- non-conservative
         ##  0. < TBETA < 1.
         element conservative_advection {
            attribute replaces {"TBETA, DEFALT (TBETA = 0.0)"},
            real
         }
      },
      element temporal_discretisation {
         ## Implicit/explicit control (TTHETA)
         ##  =0.  -- explicit
         ##  =0.5 -- Crank-Nicolson
         ##  =1.  -- implicit
         element theta {
            attribute replaces {"TTHETA, DEFALT (TTHETA = 0.5)"},
            real
         },
         temporal_control_volume_options?,
         temporal_discontinuous_galerkin_options?
      },
      (
         ## Solver
         element solver {
            linear_solver_options_asym
         }|
         ## Assume this field is being solved explicitly and skip the solver.
         ##
         ## ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.
         ##
         ## Assumes lhs matrix only has diagonal lumped mass (times
         ## density if appropriate for equation)
         ## and divides the rhs by this.
         element explicit {
            empty
         }
      ),
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_real
         }
      )+,
      ## Boundary conditions
      element boundary_conditions {
         attribute replaces { "boundary, TTPER1 TTPER2 TTPERI" },
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         ## Type
         (
            element type {
               attribute name { "dirichlet" },
               ## Apply the dirichlet bc weakly.  Available
               ## automatically with discontinuous_galerkin and
               ## control_volume
               ## spatial_discretisations.
               ## If not selected boundary conditions are applied strongly.
               element apply_weakly {
                  ## If the initial condition and boundary conditions
                  ## differ, setting this option will cause the initial
                  ## condition on the boundary to be overwritten with
                  ## the boundary condition. Since you are applying the
                  ## boundary condition weakly, you probably do *not*
                  ## want this.
                  element boundary_overwrites_initial_condition {
                     empty
                  }?
               }?,
               input_choice_real
            }|
            element type {
               attribute name { "neumann" },
               input_choice_real
            }|
            element type {
               attribute name { "robin" },
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }|
            ## Prevent the field from fluxing out of the boundary.
            ## Only applicable to control volume spatial discretisations.
            element type {
              attribute name { "zero_flux" },
              empty
            }
         )
      }*,
      ## Choice of subgridscale model to apply to this field. 
      ## Note that the selected parameterisation must be switched 
      ## on for this material phase.
      ##
      ## At this time, do not switch on this option if you are using Mellor-Yamada.
      (
         element subgridscale_parameterisation {
            attribute name { "Gent_McWilliams"}
         }|
         element subgridscale_parameterisation {
            attribute name { "GLS"}
         }|
         element subgridscale_parameterisation {
            attribute name { "prescribed_diffusivity"}
         }
      )?,
      ## Diffusivity for field
      element tensor_field {
         attribute name { "Diffusivity" },
         attribute rank { "2" },
         attribute replaces { "TMUXX TMUYY TMUZZ TMUYZ TMUXZ TMUXY TALLMU TCONMU" },
         (
            element prescribed {
                mesh_choice?,
                prescribed_tensor_field_no_adapt
            }|
            ## For electrical modelling only - holds electrical conductivity
            element diagnostic {
               (
                  tensor_python_diagnostic_algorithm |
                  internal_algorithm
               ),
               diagnostic_tensor_field
            }
         )
      }?,
      ## source term
      element scalar_field {
         attribute name { "Source" },
         attribute rank { "0" },
         attribute replaces { "ZSOT" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt
            }|
            ## This only works for traffic modelling
            element diagnostic {
               (
                  scalar_python_diagnostic_algorithm |
                  internal_algorithm
               ),
               diagnostic_scalar_field_no_adapt
            } 
         )
      }?,
      ## Absorption term
      element scalar_field {
         attribute name { "Absorption" },
         attribute rank { "0" },
         attribute replaces { "TABSZE TABS TABSCO TABSOR" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt
            }|
            element diagnostic {
               (
                  scalar_python_diagnostic_algorithm |
                  internal_algorithm
               ),
               diagnostic_scalar_field_no_adapt
            }
         )
      }?,
      ## Velocity at which this substance sinks through the water column.
      ## 
      ## This velocity is in the direction of gravity so if the substance
      ## floats or swims upwards, this field should be negative.
      element scalar_field {
         attribute name { "SinkingVelocity" },
         attribute rank { "0" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt
            }|
            element diagnostic {
               (
                  scalar_python_diagnostic_algorithm |
                  internal_algorithm
               ),
               diagnostic_scalar_field_no_adapt
            }
         )
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar,
      discrete_properties_algorithm_scalar?,
      ## Set the priority of this field
      ## This determines the order in which scalar_fields are solved for:
      ##  - higher numbers have the highest priority
      ##  - lower numbers (including negative) have the lowest priority
      ##  - default if not set is 0
      element priority {
         integer
      }?
   )

prognostic_density_field =
   (
      scalar_equation_choice?,
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## Continuous Galerkin formulation.
            element continuous_galerkin {
               advection_stabilisation_options,
               ## Discretisation options for the advection terms.
               element advection_terms {
                  ## Integrate the advection terms of the momentum equation by
                  ## parts.
                  element integrate_advection_by_parts {
                     comment
                  }?
               },
               ## Discretisation options for the mass terms.
               element mass_terms {
                  ## Lump the mass matrix
                  element lump_mass_matrix {
                     empty
                  }?
               },
               comment
            }|
            ## Use a control volume discretisation.
            element control_volumes {
              spatial_control_volume_options
            }
         )
      },
      element temporal_discretisation {
         ## Implicit/explicit control (TTHETA)
         ##  =0.  -- explicit
         ##  =0.5 -- Crank-Nicholson
         ##  =1.  -- implicit
         element theta {
            attribute replaces {"TTHETA, DEFALT (TTHETA = 0.5)"},
            real
         },
         temporal_control_volume_options?
      },
      (
         ## Solver
         element solver {
            linear_solver_options_asym
         }|
         ## Assume this field is being solved explicitly and skip the solver.
         ##
         ## ONLY AVAILABLE FOR PURE CONTROL VOLUME SPATIAL DISCRETISATIONS.
         ##
         ## Assumes lhs matrix only has diagonal lumped mass (times
         ## density if appropriate for equation)
         ## and divides the rhs by this.
         element explicit {
            empty
         }
      )?,
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_real
         }
      )+,
      ## Boundary conditions
      element boundary_conditions {
         attribute replaces { "boundary, TTPER1 TTPER2 TTPERI" },
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         ## Type
         (
            element type {
               attribute name { "dirichlet" },
               ## Apply the dirichlet bc weakly.  Available
               ## automatically with discontinuous_galerkin,
               ## and control_volume spatial_discretisations.
               ## If not selected boundary conditions are applied strongly.
               element apply_weakly {
                  ## If the initial condition and boundary conditions
                  ## differ, setting this option will cause the initial
                  ## condition on the boundary to be overwritten with
                  ## the boundary condition. Since you are applying the
                  ## boundary condition weakly, you probably do *not*
                  ## want this.
                  element boundary_overwrites_initial_condition {
                     empty
                  }?
               }?,
               input_choice_real
            }
         )
      }*,
      ## source term
      element scalar_field {
         attribute name { "Source" },
         attribute rank { "0" },
         attribute replaces { "ZSOT" },
         (
            element prescribed {
               prescribed_scalar_field_no_adapt,
               recalculation_options?
            }|
            ## This only works for traffic modelling
            element diagnostic {
              internal_algorithm,
              diagnostic_scalar_field_no_adapt
            } 
         )
      }?,
      ## Absorption term
      element scalar_field {
         attribute name { "Absorption" },
         attribute rank { "0" },
         attribute replaces { "TABSZE TABS TABSCO TABSOR" },
         element prescribed {
            prescribed_scalar_field_no_adapt
         }
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar,
      discrete_properties_algorithm_scalar?,
      ## Set the priority of this field
      ## This determines the order in which scalar_fields are solved for:
      ##  - higher numbers have the highest priority
      ##  - lower numbers (including negative) have the lowest priority
      ##  - default if not set is 0
      element priority {
         integer
      }?
   )

geometry = 
   (
      ## Options dealing with the specification of geometry
      element geometry {
         ## Dimension of the problem.
         ## <b>This can only be set once</b>
         element dimension {
            attribute replaces {"NDIM"},
            element integer_value {
               attribute rank {"0"},
               ("3"|"2"|"1")
            }
         },
         ## The position mesh
         element mesh {
            attribute name { "CoordinateMesh" },
            mesh_info
         },
         ## The velocity mesh
         element mesh {
            attribute name { "VelocityMesh" },
            mesh_info
         },
         ## The pressure mesh
         element mesh {
            attribute name { "PressureMesh" },
            mesh_info
         },
         element mesh {
            attribute name { xsd:string },
            mesh_info,
            element exclude_from_mesh_adaptivity{empty}?
         }*,
         ## Quadrature
         element quadrature {
            ## Quadrature degree
            ## 
            ## note: this specifies the degree of quadrature,
            ## not the number of gauss points
            element degree {
               attribute replaces {"NGI"},
               integer
            },
            ## Surface quadrature degree
            ## 
            ## note: this specifies the degree of surface
            ## quadrature not the number of surface gauss points
            element surface_degree {
               attribute replaces {"SNGI"},
               integer
            }?,
            ## Sets the degree of quadrature on each quadrilateral
            ## face of the control volume. 
            ##
            ## Defaults to 1 if
            ## unselected which is the same as pre-new options
            ## behaviour.
            element controlvolume_surface_degree {
               integer
            }?,
            ## Select which family of quadrature rules to use.
            ## The default is family_cools.
            ## family_wandzura allows for degree up to 30
            ## on triangular meshes.
            ## family_grundmann_moeller allows for degree up to
            ## 29 on simplicial meshes in arbitrary dimension.
            element quadrature_family {
               element string_value {
                  ( "family_cools" | "family_grundmann_moeller" | "family_wandzura" ) 
               }
            }?
         },
         ## This causes the change of variables associated with each element in 
         ## the mesh to be stored rather than calculated every time it is used. 
         ## This should speed up computations at a cost of some memory. 
         ## 
         ## The cache is automatically regenerated after mesh movement or 
         ## adaptivity and is automatically disabled for non-linear positions fields.
         element disable_geometric_data_cache {
            empty
         }?,
         ## Options specifying that the problem is on the surface of the sphere.
         element spherical_earth {
            attribute replaces{"ISPHERE"},
            (
               element linear_mapping {
                  attribute replaces{ "ISPHERE=1" },
                  empty
               }|
               ## Enabling this option approximates the curvature of the Earth as an
               ## nth degree polynomial, where n is the polynomial degree of the coordinate mesh.
               element superparametric_mapping {
                  attribute replaces{ "ISPHERE=2" },
                  empty
               }
            )
         }?,
         ## Options specifying the top surface and bottom of the domain
         ## used in various ocean calculations.
         element ocean_boundaries {
            ## Specify the surface ids that make up the top of the domain,
            ## i.e. the free surface or rigid lid.
            element top_surface_ids {
               integer_vector
            },
            ## Specify the surface ids that make up the bottom.
            element bottom_surface_ids {
               integer_vector
            },
            ## Diagnostic field giving the distance to the top surface.
            element scalar_field {
               attribute rank { "0" },
               attribute name { "DistanceToTop" },
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "CoordinateMesh" }
                  },
                  diagnostic_scalar_field
               }
            },
            ## Diagnostic field giving the distance to ocean bottom.
            element scalar_field {
               attribute rank { "0" },
               attribute name { "DistanceToBottom" },
               element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name {  "CoordinateMesh" }
                  },
                  diagnostic_scalar_field
               }
            }
         }?
      }
   )


# Default child of diagnostic scalar field
diagnostic_scalar_field =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )
   
# Default child of diagnostic scalar field without adaptivity options
diagnostic_scalar_field_no_adapt =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      diagnostic_detector_options
   )

# Default child of diagnostic scalar field
diagnostic_scalar_field_tidal_range =
   (
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      diagnostic_detector_options,
      adaptivity_options_scalar_field,
      (
          element spin_up_time {
             real
          }
      )       
   )

# Default child of prescribed scalar field
# This is a choice of ways of inputing the prescribed field
prescribed_scalar_field =
   (
      prescribed_scalar_field_no_adapt,
      adaptivity_options_scalar_field,
      interpolation_algorithm_scalar?,
      discrete_properties_algorithm_scalar?,
      recalculation_options?
   )

# Default child of prescribed scalar field without adaptivity options
# This is a choice of ways of inputing the prescribed field
prescribed_scalar_field_no_adapt =
   (
      prescribed_values_scalar_field,
      prescribed_output_options,
      prescribed_scalar_stat_options,
      prescribed_detector_options
   )
   
prescribed_values_scalar_field =
   (
      (
         ## Value for WholeMesh
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_real_plus_file
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_real_plus_file
         }
      )+
   )

# Default child of diagnostic vector field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic vector fields
diagnostic_vector_field =
   (
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,      
      diagnostic_detector_options,
      vector_steady_state_options,      
      adaptivity_options_vector_field,
      recalculation_options?
   )


diagnostic_vector_field_bed_shear_stress =
   (
      (
          element density {
             real
          }
      ),       
      (
          element drag_coefficient {
             real
          }
      ),   
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      diagnostic_detector_options,
      adaptivity_options_vector_field
   )



# Default child of prescribed vector field
# This is a choice of ways of inputing the prescribed field
prescribed_vector_field =
   (
      prescribed_vector_field_no_adapt,
      adaptivity_options_vector_field,
      interpolation_algorithm_vector?,
      discrete_properties_algorithm_vector?,
      recalculation_options?
   )
   
# Default child of prescribed vector field without adaptivity options
# This is a choice of ways of inputing the prescribed field
prescribed_vector_field_no_adapt =
   (
      prescribed_values_vector_field,
      prescribed_output_options,
      prescribed_vector_stat_options,
      prescribed_detector_options
   )

prescribed_values_vector_field =
   (
      (
         ## Value for WholeMesh
         ##
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_real_dim_vector_plus_file
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_real_dim_vector_plus_file
         }
      )+
   )

# Default child of diagnostic tensor field
# Currently, this is empty, but in future this might include
# options that are general to all diagnostic tensor fields
diagnostic_tensor_field =
   (
      diagnostic_output_options,
      adaptivity_options_tensor_field
   )

# Default child of prescribed tensor field
# This is a choice of ways of inputing the prescribed tensor field
# If the field is constant then a symmetric, or asymmetric tensor may be entered
prescribed_tensor_field =
   (
      prescribed_values_tensor_field,
      prescribed_output_options,
      adaptivity_options_tensor_field
   )
   
# Default child of prescribed tensor field
# This is a choice of ways of inputing the prescribed tensor field
# If the field is constant then a symmetric, or asymmetric tensor may be entered
prescribed_tensor_field_no_adapt =
   (
      prescribed_values_tensor_field,
      prescribed_output_options
   )

prescribed_values_tensor_field =
   (
      (
         ## Value for WholeMesh
         ##
         ## Only specify one value if not using mesh regions.
         ## Otherwise select other value option, specify region_ids
         ## and distinct names.  Then add extra values for other regions.
         element value {
            attribute name { "WholeMesh" },
            input_choice_tensor_field
         }|
         ## Multiple values are now allowed if using different value assignments
         ## in different regions of the mesh (specified by region_ids).
         ## In this case each value requires a distinct name for the options dictionary.
         element value {
            attribute name { string },
            region_ids,
            input_choice_tensor_field
         }
      )+
   )

prognostic_pressure_field =
   (
      element spatial_discretisation {
         (
            element continuous_galerkin {
               ## remove the  fourth order pressure stabilisation term KCMC
               ## must be removed for multimaterial and free surface calculations
               element remove_stabilisation_term {
                  attribute replaces { "NOFILT" }
               }?,
               ## Integrate the continuity equation by parts.
               ##
               ## This allows for the imposition of weak velocity boundary conditions with continuous_galerkin.
               ## If activated this means that the pressure gradient operator is not integrated by parts.
               element integrate_continuity_by_parts {
                  attribute replaces { "PREOPT" },
                  empty
               }?
            }|
            element control_volumes {
               attribute replaces { "NCOLOP = X1XXXXX -> INTERF, NOFILT" }
            }
         )
      },
      ## Reference node (Node at which pressure = 0.)
      ##
      ## Must be less than the total number of nodes.
      ## If parallel must be less than the total number of nodes of the first processor.
      ##
      ## Note - it is also an option to remove the null-space of the residual vector. This
      ## option is available under solvers.
      element reference_node {
         attribute replaces { "NDPSET" },
         integer
      }?,
      ## **UNDER DEVELOPMENT**
      ## This searches the CMC matrix diagonal looking for nodes that are less than the maximum value time epsilon(0.0) (i.e. nodes that are effectively zero).
      ## It then zeros that row and column and places a one on the diagonal and a zero on the rhs.
      ## At a debug level of 2 it also prints out the value and the sum of the row values.
      ## This is useful as a debugging tool if PETSc complains about zeros on the diagonal (i.e. if you have a stiff node in your mesh) but doesn't necessary produce nice answers at the end.
      element repair_stiff_nodes {
         empty
      }?,
      ## Atmospheric pressure
      ##
      ## Manual suggests 1.01325E+6
      element atmospheric_pressure {
         attribute replaces {"PATMOS"},
         real
      }?,
      ## scheme
      element scheme {
         ## Use a poisson pressure equation to calculate a first guess at pressure.
         ## This does not necessarily satisfy continuity.
         ##   = 1 -- use a poisson guess at every timestep
         ##   = 0 -- never use a poisson guess
         ##   =-1 -- use a poisson guess at the first timestep only
         ## Manual suggests -1
         element poisson_pressure_solution {
            attribute replaces {"POISON"},
            (
               element string_value{
                  # Lines is a hint to the gui about the size of the text box.
                  # It is not an enforced limit on string length.
                  attribute lines { "1" },
                  ( "never" | "every timestep" | "only first timestep")
               },
               comment
            )
         },
         (
            ## Use the incompressible projection method to determine
            ## the pressure and satisfy continuity
            element use_projection_method {
               attribute replaces {"PROJEC"},
               ## Assemble and use the full schur complement.
               ## This allows you to not lump the mass matrix if you're using
               ## cg and to use the full momentum matrix in the projection if
               ## you so desire.
               element full_schur_complement {
                 ( 
                   ## Specify the inner matrix (IM) to form the projection schur complement (C^T*IM^{-1}*C). 
                   ## Use the full mass matrix.
                   ##
                   ## Make sure you've not lumped your mass in the velocity spatial_discretisation if you want to be consistent!
                   element inner_matrix {
                     attribute name { "FullMassMatrix" },
                     element solver {
                       linear_solver_options_sym
                     }
                   }|
                   ## Specify the inner matrix (IM) to form the projection schur complement (C^T*IM^{-1}*C). 
                   ## Use the full momentum matrix.
                   ##
                   ## Doesn't really matter if you've lumped your mass or not but why would you if you're doing a full inner solve anyway?
                   element inner_matrix {
                     attribute name { "FullMomentumMatrix" },
                     element solver {
                       linear_solver_options_asym
                     }
                   }
                 ),
                 (
                   ## Specify the preconditioner matrix to use on the schur complement.
                   ##
                   ## For DG, the LumpedSchurComplement is our best approximation to CMC.
                   element preconditioner_matrix {
                     attribute name { "LumpedSchurComplement" },
                     element lump_on_submesh {
                       empty
                     }?
                   }|
                   ## Specify the preconditioner matrix to use on the schur complement.
                   ##
                   ## DiagonalSchurComplement = C_P^T * [(Big_m)_diagonal]^-1 * C
                   element preconditioner_matrix {
                     attribute name { "DiagonalSchurComplement" },
                     empty
                   }|
                   ## Specify the preconditioner matrix to use on the schur complement.
                   element preconditioner_matrix {
                     attribute name { "NoPreconditionerMatrix" },
                     empty
                   }
                 )
               }?
            }|
            ## Use the compressible projection method to determine the
            ## pressure and satisfy continuity and the eos.
            ## This is only currently compatible with control volume
            ## pressure spatial discretisations and requires a
            ## multimaterial eos.
            element use_compressible_projection_method {
               attribute replaces {"MKCOMP from solidity_options.inp"},
               (
                  ## Variable (normally a density) used to normalise
                  ## each materials contribution
                  ## to the C_P^T matrix.  Leave unselected for no normalisation.
                  ## Selects the MaterialDensity field.
                  element normalisation {
                     attribute name{ "MaterialDensity" },
                     empty
                  }|
                  ## Variable (normally a density) used to normalise
                  ## each materials contribution
                  ## to the C_P^T matrix.  Leave unselected for no normalisation.
                  ## Selects the bulk Density field.
                  element normalisation {
                     attribute name{ "Density" },
                     empty
                  }|
                  ## Variable (normally a density) used to normalise
                  ## each materials contribution
                  ## to the C_P^T matrix.  Leave unselected for no normalisation.
                  ## Allows the selection of an arbitrary field.
                  element normalisation {
                     attribute name{ string },
                     empty
                  }
               )?

            }
         ),
         ## rediscretise the equations at every timestep and iteration
         ## (this is useful as a debugging tool but shouldn't be necessary for any application runs)
         element update_discretised_equation {
            attribute replaces {"CMCHAN"},
            empty
         }?
      },
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_real
         }
      )*,
      element boundary_conditions {
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         ## Type
         element type {
            attribute name { "dirichlet" },
            ## Apply the dirichlet bc weakly.  Available
            ## automatically with discontinuous_galerkin and
            ## control_volume spatial_discretisations.
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
              ## If the initial condition and boundary conditions
              ## differ, setting this option will cause the initial
              ## condition on the boundary to be overwritten with
              ## the boundary condition. Since you are applying the
              ## boundary condition weakly, you probably do *not*
              ## want this.
              element boundary_overwrites_initial_condition {
                 empty
              }?
            }?,
            input_choice_real_plus_boundary_forcing
         }
      }*,
      pressure_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      detector_options_disabled_default,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar_full,
      discrete_properties_algorithm_scalar?
   )

prognostic_geostrophic_pressure_field =
   (
      element spatial_discretisation {
         ## Enables / disables RHS terms in the geopressure solver:
         ##
         ##   include_buoyancy - Include both the buoyancy and Coriolis terms on the RHS
         ##   exclude_buoyancy - Include only the Coriolis term on the RHS
         ##   exclude_coriolis - Include only the buoyancy term on the RHS
         element geostrophic_pressure_option {
            attribute replaces { "GEOBAL" },
            element string_value {
               "include_buoyancy" | "exclude_buoyancy" | "exclude_coriolis"
            }
         }
      },
      (
         ## Sets node 1 in the mesh as a reference node
         element reference_node {
            attribute name { "node_1" },
            element integer_value {
              attribute rank { "0" },
              attribute shape { "1" },
              "1"
            },
            comment
         }|
         ## Sets a custom node in the mesh as a reference node
         element reference_node {
            attribute name { "custom"},
            integer
         }|
         ## Sets the value of the field to zero at a supplied coordinate.
         ## This is a post-processing step after the solve, and hence should
         ## be used with the solver/remove_null_space option.
         element zero_coord {
           real_dim_vector
         }
      )?,
      (
         ## Solver
         element solver {
            linear_solver_options_sym
         }
      ),
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_real
         }
      )*,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar_full,
      discrete_properties_algorithm_scalar?
   )
   
# Balance pressure field, this is a copy of prognostic_scalar_field above
# removing all options that don't apply (mainly advection related)
prognostic_balance_pressure_field =
   (
      ## Spatial discretisation options
      element spatial_discretisation {
         # note I removed disott here as it
         # will switch on free-surface options in geoeli1p
         # should be hard-coded to 0 in comsca therefore
         # tlump is irrelevant
         # suftem should be hard-coded to .false. if nlevel is set
         ## Geostrophic pressure option
         element geostrophic_pressure_option {
            attribute replaces { "GEOBAL" },
            element string_value {
               "include_buoyancy"|"exclude_buoyancy"
            }
         }
         # unfortunately tbeta doesn`t make sense here
         # so we have to code an exception for not having it in comsca
      },
      # Temporal_discretisation doesn`t apply to balance pressure
      # (there`s no time derivative). Exception again
      # Solver block is the same as prognostic_scalar_field
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      # Alas, no initial_condition either, so we'd better not checkpointing it...
      ## Disables checkpointing of this field
      element exclude_from_checkpointing {
        comment
      },
      # There are boundary conditions, but nothing you can set
      # (all derived from velocity b.c.s)
      # no Diffusivity tensor_field
      # no Source scalar_field
      # no Absorption scalar_field
      # no adaptive time-stepping
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar_full,
      discrete_properties_algorithm_scalar?
   )

# Vertical balance pressure field, this is a copy of prognostic_scalar_field above
# removing all options that don't apply (mainly advection related)
prognostic_vertical_balance_pressure_field =
   (
      ## Spatial discretisation options
      element spatial_discretisation {
        # we don't have any yet
        empty
      },
      # Temporal_discretisation doesn`t apply to balance pressure
      # (there`s no time derivative). Exception again
      # no solver block as we don't do a PETSc solve
      # Alas, no initial_condition either...
      # boundary conditions are fixed (p=0 on top)
      # no Diffusivity tensor_field
      # no Source scalar_field
      # no Absorption scalar_field
      # no adaptive time-stepping
      ## Disables checkpointing of this field
      element exclude_from_checkpointing {
        comment
      },
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar,
      discrete_properties_algorithm_scalar?
   )
   
# free surface field, this is a copy of prognostic_scalar_field above
# removing all options that don't apply (mainly advection related)
prognostic_free_surface_field =
   (
      (
         ## Spatial discretisation options
         element spatial_discretisation {
            ## Form a full 3D system for the free surface
            element free_surface_3D {
               attribute replaces { "DISOTT=2^0 (frees3d)" },
               empty
            }?,
            element fourth_order_dissipation {
               attribute replaces { "DISOTT=2^2 (fourthfrees_diss)" },
               empty
            }?,
            ## low order (linear) free surface
            element low_order_free_surface {
               attribute replaces { "DISOTT=2^3 (geo_short)" },
               empty
            }?,
            (
               ## Select free surface filter
               ##
               ## With PN-PN we need some filter to supress spurious modes.
               element default_free_surface_filter {
                  empty
               }|
               ## Select free surface filter
               ##
               ## With PN-PN we need some filter to supress spurious modes.
               element user_specified_free_surface_filter {
                  ## Default is to apply 0.01 and for wetting and drying cases 1.0
                  element non_linear_filter_coefficient {
                     real
                  }
               }|
               ## Switch off free surface filter, this is more efficient than setting the coefficient to 0.
               element switch_off_free_surface_filter {
                  attribute replaces { "DISOTT=2^8 (nofsta)" },
                  empty
               }
            ),
            ## Apply wetting and drying routines
            element wetting_drying {
               attribute replaces { "DISOTT=2^10 (wetdry)" },
               empty
            }?,
            ## Tidal forcing options 
            element tidal_forcing {
               ## M2
               element M2 {
                 attribute replaces {"DISOTT=2^11"}, 
                 empty
               }?,
               ## S2
               element S2 {
                  empty
               }?,
               ## N2
               element N2 {
                  empty
               }?,
               ## K2
               element K2 {
                  empty
               }?,
               ## K1
               element K1 {
                  empty
               }?,
               ## O1
               element O1 {
                  empty
               }?,
               ## P1
               element P1 {
                  empty
               }?,
               ## Q1
               element Q1 {
                  empty
               }?,             
               ## Switch on all tidal components
               element all_tidal_components {
                  attribute replaces { "DISOTT=2^5 (tidallcom)" },
                  empty
               }?,
               ## Switches on a Love number of 0.3
               element love_number {
                  attribute replaces { "DISOTT=2^6 (tlove)" },
                  empty
               }?,
               ## Use static tidal force for testing
               element static_tidal_force {
                  attribute replaces { "DISOTT=2^7 (statid)" },
                  empty
               }?
            }?
         }
      ),
      # atheta, ctheta and fstheta (absorption, coriolis and free surface)
      # need to go in temporal discretisation
      # they are currently hard-coded however
      element temporal_discretisation {
         ## Implicit/explicitness for the free surface.
         ##
         ## Suggested value 1.0 (should be at least bigger than 0.5).
         ##  =0.  -- explicit
         ##  =0.5 -- Crank-Nicolson
         ##  =1.  -- implicit
         element theta {
            attribute replaces {"THETA"},
            real
         },
         # Maybe this should go under a proper absorption field under free surface?
         ## Implicit/explicitness for absorption
         ## =0.  -- explicit (default)
         ## =0.5 -- Crank-Nicolson
         ## =1.  -- implicit
         element absorption_theta {
            attribute replaces {"disott=2^4 (IMPABS)"},
            real
         }?
      },
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      (
         ## Initial condition for WholeMesh
         ##
         ## Only specify one condition if not using mesh regions.
         ## Otherwise select other initial_condition option, specify region_ids
         ## and distinct names.  Then add extra intial conditions for other regions.
         element initial_condition {
            attribute name { "WholeMesh" },
            input_choice_initial_condition_real
         }|
         ## Multiple initial_conditions are allowed if specifying
         ## different values in different
         ## regions of the mesh (defined by region_ids).  In this case
         ## each initial_condition
         ## requires a distinct name for the options dictionary.
         element initial_condition {
            attribute name { string },
            region_ids,
            input_choice_initial_condition_real
         }
      )+,
      ## Boundary conditions
      element boundary_conditions {
         attribute replaces { "boundary, TTPER1 TTPER2 TTPERI" },
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         ## Type
         (
            element type {
               attribute name { "dirichlet" },
               (
                  input_choice_real_contents|
                  element from_file {
                     element tidal {
                        attribute file_name { string },
                        attribute variable_name_amplitude { string },
                        attribute variable_name_phase { string },
                        ## See E.W. Schwiderski - Rev. Geophys. Space
                        ## Phys. Vol. 18 No. 1 pp. 243--268, 1980
                        ## for details of these constituent.
                        attribute name {"M2"|"S2"|"N2"|"K2"|"K1"|"O1"|"P1"|"Q1"|"Mf"|"Mm"|"Ssa"}
                     }+
                  }|
                  ## Set the boundary free-surface height from NEMO data.
                  ## A prescribed NEMO pressure scalar field must be set to use this option.
                  ## Set the name of the prescribed NEMO pressure scalar field below.
                  element NEMO_data {
                     attribute field_name { string }
                  }
               )
            }|
            element type {
               attribute name { "neumann" },
               input_choice_real
            }|
            element type {
               attribute name { "robin" },
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }
         )
      }*,
      # no Diffusivity for field
      # no source term
      # no Absorption term
      # no Adaptive timestepping option
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar,
      discrete_properties_algorithm_scalar?
   )

# stream function, this is a copy of prognostic_scalar_field above
# removing all options that don't apply (mainly advection related)
prognostic_stream_function_field =
   (
      ## Solver
      element solver {
         linear_solver_options_asym
      },
      ## Disables checkpointing of this field
      element exclude_from_checkpointing {
        comment
      },
      # no Diffusivity for field
      # no source term
      # no Absorption term
      # no Adaptive timestepping option
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      prognostic_detector_options,
      adaptivity_options_prognostic_scalar_field,
      interpolation_algorithm_scalar,
      discrete_properties_algorithm_scalar?
   )
   
# Richardson number field. This is a normal diagnostic scalar field, but with
# Richardson number metric options added
adaptivity_options_richardson_number_field.adaptivity_options =
   (
      ## Do not use an interpolation error driven metric for this field
      element no_interpolation_measure {
        comment
      }
   )
adaptivity_options_richardson_number_field.adaptivity_options |= adaptivity_options_scalar_field.adaptivity_options
adaptivity_options_richardson_number_field =
   (
      element adaptivity_options {
         adaptivity_options_richardson_number_field.adaptivity_options,
         ## An isotropic metric formulation based on the Richardson number. Uses
         ## the logic that wherever the Richardson number is small, we expect
         ## to need resolution. Generates edge lengths using:
         ##
         ##   Edge length = min_edge_length if Ri <= min_ri
         ##                 max_edge_length if Ri >= max_ri
         ##                 a linear fit between min_edge_length and max_edge_length otherwise
         element richardson_number_metric {
            ## Richardson number at which we have minimum edge length (default 0.0)
            element min_ri {
              real
            }?,
            ## Richardson number at which we have maximum edge length
            element max_ri {
              real
            },
            ## Minimum edge length that can be requested by the Richardson number
            ## metric
            element min_edge_length {
              real
            },
            ## Maximum edge length that can be requested by the Richardson number
            ## metric
            element max_edge_length {
              real
            },
            ## Enable to preserve anisotropy when merging with other metric
            ## formulations
            element anisotropy_preserving_merge {
               comment
            }?,
            comment
         }?,
         adaptivity_preprocessing
      }?
   )
diagnostic_richardson_number_field = diagnostic_scalar_field_no_adapt
diagnostic_richardson_number_field &= adaptivity_options_richardson_number_field

diagnostic_cv_gradient_vector_field =
   (
      ## Choose whether the mass matrix is lumped or not
      element lump_mass_matrix {
            empty
      }?,
      ## Solver options are necessary if you're not lumping your mass or if you're field isn't dg
      element solver {
         linear_solver_options_sym
      }?,
      ## Normalise the gradient by its magnitude
      element normalise {
        empty
      }?,
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      vector_steady_state_options,
      adaptivity_options_vector_field,
      recalculation_options?
   )

diagnostic_gradient_vector_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_output_options,
      diagnostic_vector_stat_options,
      vector_convergence_options,
      diagnostic_detector_options,
      vector_steady_state_options,
      adaptivity_options_vector_field,
      recalculation_options?
   )

diagnostic_cv_divergence_scalar_field =
   (
      # No solver options because it can be solved directly!
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )

diagnostic_fe_divergence_scalar_field =
   (
      ## Solver
      element solver {
         linear_solver_options_sym
      },
      diagnostic_output_options,
      diagnostic_scalar_stat_options,
      scalar_convergence_options,
      diagnostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      recalculation_options?
   )

# three optional input vectors for user-specified rotation matrix
rotation_matrix_components =
   (
      ## Select if you want to specify the normal direction
      ## of the rotation matrix.
      ## If off then fluidity computes the normal (replaces GETTAN = .TRUE.)
      ## If on the tangents vectors must also be specified.
      element normal_direction {
         attribute replaces { "GETTAN=.FALSE." },
         input_choice_real_dim_vector
      }?,
      ## specify first unit tangent vector to boundary
      element tangent_direction_1 {
         attribute replaces { "GETTAN=.FALSE." },
         input_choice_real_dim_vector
      }?,
      ## specify second (if exists, i.e. if 3d) unit tangent vector to boundary
      element tangent_direction_2 {
         attribute replaces { "GETTAN=.FALSE." },
         input_choice_real_dim_vector
      }?
   )

velocity_components_choice =
   (
      (
         element align_bc_with_surface {
            element normal_component {
               input_choice_real
            }?,
            element tangent_component_1 {
               input_choice_real
            }?,
            element tangent_component_2 {
               input_choice_real
            }?,
            rotation_matrix_components,
            ## this will calculate the determinant of the
            ## rotation matrix for every boundary node
            ## and dump a vtu with the node 
            ## normals and tangenials 1/2
            element debugging_mode{empty}?
         }|
         element align_bc_with_cartesian {
            element x_component {
               input_choice_real_bc_component
            }?,
            element y_component {
               input_choice_real_bc_component
            }?,
            element z_component {
               input_choice_real_bc_component
            }?
         }
      )
   )
   
input_choice_real_bc_component = 
   (
      input_choice_real|
      element synthetic_eddy_method {
         ## use a large number to ensure Gaussian 
         ## behaviour of the fluctuating component
         element number_of_eddies {
           integer
         },
         element turbulence_lengthscale {
            input_choice_real
         },
         ## mean profile
         ##
         ## usually a function of height,
         ## for ABL simulations use a log profile
         element mean_profile {
            input_choice_real
         },
         ## Reynolds stresses profile
         ##
         ## usually a function of height,
         ## assumes that the remaining stresses are negligible 
         element Re_stresses_profile {
           input_choice_real
         }
      }
   )

# and again for robin b.c.s
robin_velocity_components_choice =
   (
      (
#         element align_bc_with_surface {
#            element normal_component {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            element tangent_component_1 {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            element tangent_component_2 {
#               element order_zero_coefficient {
#                  input_choice_real
#               },
#               element order_one_coefficient {
#                  input_choice_real
#               }
#            }?,
#            rotation_matrix_components
#         }|
         element align_bc_with_cartesian {
            element x_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?,
            element y_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?,
            element z_component {
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }?
         }
      )
   )

velocity_boundary_conditions =
   (
      (
         element type {
            attribute name { "dirichlet" },
            ## Apply the dirichlet bc weakly.  Available automatically
            ## with a discontinuous_galerkin Velocity
            ## spatial_discretisation.  Available if you
            ## integrate_continuity_by_parts with a
            ## continuous_galerkin Pressure or use a control_volume
            ## Pressure spatial_discretisation and/or
            ## integrate_advection_by_parts under Velocity
            ## spatial_discretisation with continuous_galerkin.
            ##
            ## If not selected boundary conditions are applied strongly.
            element apply_weakly {
               ## If the initial condition and boundary conditions
               ## differ, setting this option will cause the initial
               ## condition on the boundary to be overwritten with
               ## the boundary condition. Since you are applying the
               ## boundary condition weakly, you probably do *not*
               ## want this.
               element boundary_overwrites_initial_condition {
                  empty
               }?
            }?,
            velocity_components_choice
         }|
         element type {
            attribute name { "neumann" },
            velocity_components_choice
         }|
         element type {
            attribute name { "robin" },
            robin_velocity_components_choice
         }|
         element type {
            attribute name { "free_surface" }
         }|
         ## Apply quadratic drag. Specify drag coefficient. If you
         ## want to exactly replicate results from using the OCEDRA
         ## option, set this to 0.003 and remember to apply to both
         ## bottom and sides.
         element type {
            attribute name { "drag" },
            input_choice_real,
            (
              ## Use a quadratic drag.
              ##
              ## This means that the drag coefficient is nondimensional.
              element quadratic_drag {
                empty
              }|
              ## Use a linear drag (basically just a surface absorption term).
              ##
              ## This means that the drag coefficient has units of momentum.
              element linear_drag {
                empty
              }
            )
         }|


         ## Apply wind forcing specified by stress or wind velocity.
         ## Replaces windy.dat and windy.py
         element type {
            attribute name { "wind_forcing" },
            (
               ## Wind forcing with user specified wind stress
               ##
               ## <b> Note that the stress needs to be specified
               ## using the same density units as the reference_density 
               ## under equation of state.</b>So if you use the recommended
               ## non-dimensional value of 1.0 for reference_density and
               ## your calculated stress is in kg m^-1s^-2 and the dimensional
               ## reference_density is 1000.0 kg m^-3, you need to divide
               ## the calculated stress in SI units by 1000.0.
               element wind_stress {
                  input_choice_real_dim_minus_one_vector|
                  element from_netcdf {
                     ## The format of this file should conform to NetCDF CF 1.x
                     ## (http://cf-pcmdi.llnl.gov/).
                     attribute file_name { xsd:string },
                     attribute east_west { xsd:string },
                     attribute north_south { xsd:string },
                     comment
                  }
               }|
               ## Wind forcing with user specified 10m wind velocity
               element wind_velocity {
                  ## Specify wind drag coefficient (dimensionless)
                  ## Suggested value: 4.0e-4
                  element wind_drag_coefficient {
                     input_choice_real
                  },
                  ## Density of air. 
                  ##
                  ## <b>Note that you have to specify
                  ## this density in the same units as the 
                  ## reference_density under equation of state.</b>
                  ## So with a typicial value of rho_air=1.3 kgm^-3
                  ## and rho_water=1000 kgm^-3, if you fill in the 
                  ## recommended (non-dimensional) value of 1.0 for 
                  ## reference_density, this field needs to be 1.3e-3.
                  element density_air {
                     real
                  },
                  ## Specify wind velocity
                  element wind_velocity {
                     input_choice_real_dim_minus_one_vector|
                     element from_netcdf {
                        ## The format of this file should conform to NetCDF CF 1.x
                        ## (http://cf-pcmdi.llnl.gov/)
                        attribute file_name { xsd:string },
                        attribute east_west { xsd:string },
                        attribute north_south { xsd:string },
                        comment
                     }
                  }
               }
            )
         }|

         ## When using control_volumes under Pressure
         ## spatial_discretisation or when using
         ## integrate_continuity_by_parts with continuous_galerkin
         ## Pressure and continuous_galerkin Velocity this
         ## boundary condition type imposes a weak no normal flow
         ## boundary condition on the surface_ids specified.
         element type {
            attribute name { "no_normal_flow" },
            empty
         }|

         ## Implements a penalty function for the near wall region.
         ## Using this option coarse meshes can
         ## be used in the near wall region.
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         ##
         ## See Bazilevs et al. 2007
         element type{
            attribute name { "near_wall_treatment" },
            element tolerance {real},
            ## if not set then Cb=2*h, where h is the element size
            element Cb {real}?
         }|
         ## Log law of the wall
         ##
         ## Should be used in combination with a no_normal_flow condition. 
         element type{
            attribute name { "log_law_of_wall" },
            element surface_roughness {real}
         }|
         ## Dummy BC
         ##
         ## Should be used in combination with the near_wall_treatment condition.
         ## When activated wall treatment is not applied on the wall-outflow edge.
         element type{
            attribute name { "outflow" }
         }
      )
   )
   
# Output options for prognostic fields
prognostic_scalar_output_options =
   (
      ## Specify what is written to vtu dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Output a file details the convergence (or otherwise) of
         ## this field with every advective nonlinear
         ## iteration.
         ## ONLY WORKS FOR PURE CONTROL VOLUME DISCRETISATIONS.
         element convergence_file {
            comment
         }?
      }
   )

# Output options for pressure (can't have a convergence file)
pressure_output_options =
   (
      ## Specify what is written to vtu dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?,
         ## Write out some extra debugging vtu files that can be used
         ## to analyse what goes on in the pressure projection steps.
         ## WARNING: this may create a huge amount of vtu files, as 
         ## multiple files are written per nonlinear iteration.
         element debugging_vtus {
            empty
         }?
      }
   )

# Output options for prognostic fields
prognostic_vector_output_options =
   (
      ## Specify what is written to dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## on the previous timestep.
         ## (included under the name: Old<field_name> )
         element include_previous_time_step {
            empty
         }?,
         ## Select this option to also write the values of this field
         ## used in the nonlinear iteration.
         ## (included under the name: Nonlinear<field_name> )
         element include_nonlinear_field {
            empty
         }?
      }
   )
   
# Field output options for all other fields
field_output_options =
   (
      ## Specify what is written to dump files.
      element output {
         ## Exclude this field from dump files.
         element exclude_from_vtu {
            comment
         }?
      }
   )
field_output_options_disabled =
   (
      ## Specify what is written to vtu dump files.
      element output {
         (
            ## Exclude this field from dump files.
            element exclude_from_vtu {
               comment
            }|
            ## Include this field in dump files.
            element include_in_vtu {
               comment
            }
         )
      }
   )
   
diagnostic_output_options = field_output_options
prescribed_output_options = field_output_options

# Options for inclusion/exclusion of standard field statistics from the .stat
# file
include_stat =
   (
      ## Include this field in the .stat file (magnitude and components)
      element include_in_stat {
         comment
      }
   )
exclude_components_from_stat =
   (
      ## Include just the magnitude of this field in the .stat file
      ## (excluding the components)
      element exclude_components_from_stat {
         comment
      }
   )
exclude_stat =
   (
      ## Exclude this field from the .stat file.
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for prognostic scalar fields
prognostic_scalar_stat_options = 
   (
      ## Specify what is added to .stat files
      element stat {
        prognostic_scalar_stat_options.stat
      }
   )
  
# Diagnostic statistics for all other scalar fields
prognostic_scalar_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_scalar_stat_no_old_or_nonlinear_options.stat
         
      }
   )

diagnostic_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options
prescribed_scalar_stat_options = prognostic_scalar_stat_no_old_or_nonlinear_options

# Combining of stat elements for scalar fields
prognostic_scalar_stat_options.stat = prognostic_scalar_stat_no_old_or_nonlinear_options.stat
prognostic_scalar_stat_options.stat &=
   (
      ## Enable to include the previous timestep value of this field in the .stat file.
      element include_previous_time_step {
         comment
      }?,
      ## Enable to include the values of this field in the nonlinear
      ## iteration in the .stat file.
      element include_nonlinear_field {
         comment
      }?
   )
prognostic_scalar_stat_no_old_or_nonlinear_options.stat = 
   (
      exclude_stat?,
      cv_stats?,
      surface_integral_stats_scalar*,
      mixing_stats*
   )   
   
# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_enabled_default = include_stat
vector_field_stat_options_enabled_default |= exclude_components_from_stat
vector_field_stat_options_enabled_default |= exclude_stat

# Diagnostic statistics options for vector fields, with enabled by default
vector_field_stat_options_disabled_default = exclude_stat
vector_field_stat_options_disabled_default |= exclude_components_from_stat
vector_field_stat_options_disabled_default |= include_stat

# Diagnostic statistics for prognostic vector fields
prognostic_velocity_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         (
            prognostic_velocity_stat_options.stat
         )
      }      
   )

# Diagnostic statistics for all other vector fields
prognostic_vector_stat_no_old_or_nonlinear_options =
   (
      ## Specify what is added to .stat files
      element stat {
         prognostic_vector_stat_no_old_or_nonlinear_options.stat
      }
   )
diagnostic_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options
prescribed_vector_stat_options = prognostic_vector_stat_no_old_or_nonlinear_options

# Combining of stat elements for vector fields
prognostic_velocity_stat_options.stat = prognostic_vector_stat_no_old_or_nonlinear_options.stat
prognostic_velocity_stat_options.stat &=
   (
      ## Specify how the previous timestep value of this field is added to the .stat file.
      element previous_time_step {
         vector_field_stat_options_disabled_default
      },
      ## Specify how the values of this field used in the nonlinear iteration are added to the .stat file.
      element nonlinear_field {
         vector_field_stat_options_disabled_default
      },
      ## What surface IDs do you want to do the calculation over?
      element compute_body_forces_on_surfaces {
         ## Enable to output the pressure and viscous terms separately (as well
         ## as the total force)
         element output_terms {
            comment
         }?,
         integer_vector
      }?,
      ## Calculate the error in the conservation of momentum
      ## IN PROGRESS - Does not include all terms!
      element calculate_momentum_conservation_error {
         empty
      }?
   )
prognostic_vector_stat_no_old_or_nonlinear_options.stat =
   (
      vector_field_stat_options_enabled_default,
      surface_integral_stats_vector*
   )

# Convergence options for prognostic scalar fields
scalar_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Exclude this field from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Convergence statistics options for prognostic vector fields (velocity)
vector_convergence_options =
   (
      ## Decide whether this field is tested for convergence
      ## during nonlinear iterations
      ## (if /timestepping/nonlinear_iterations and
      ## /timestepping/nonlinear_iterations/tolerance are
      ## enabled).
      ## Also specifies whether the field is added to the 
      ## convergence file (if /io/convergence_file is enabled).
      element convergence {
         (
            ## Include this field (magnitude and components)
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            element include_in_convergence {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in convergence testing
            ## (if /timestepping/nonlinear_iterations and
            ## /timestepping/nonlinear_iterations/tolerance are
            ## enabled) and file (if /io/convergence_file is enabled)
            ## i.e. excluding the components
            element exclude_components_from_convergence {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_convergence {
               comment
            }
         )
      }
   )

# Steady state options for prognostic scalar fields
scalar_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            element include_in_steady_state {
               comment
            }|
            ## Exclude this field from steady state testing
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Steady state statistics options for prognostic vector fields (velocity)
vector_steady_state_options =
   (
      ## Decide whether this field is tested for a steady state
      ## between timesteps
      ## (if /timestepping/steady_state is
      ## enabled).
      element steady_state {
         (
            ## Include this field (magnitude and components)
            ## in steady state testing
            ## (if /timestepping/steady_state is enabled)
            element include_in_steady_state {
               comment
            }|
            ## Include just the magnitude of this field 
            ## in steady state testing
            ## (if /timestepping/steady_state is
            ## enabled)
            ## i.e. excluding the components
            element exclude_components_from_steady_state {
               comment
            }|
            ## Exclude this field entirely from convergence testing and file 
            element exclude_from_steady_state {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_enabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }|
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }
         )
      }
   )

# Options for whether a field is to be included in detector output.
detector_options_disabled_default = 
   (
      ## Specify what is added to detector files
      element detectors {
         (
            ## This field is not output at detector locations.
            element exclude_from_detectors {
               comment
            }|
            ## This field is output at each detector location.
            element include_in_detectors {
               comment
            }
         )
      }
   )

# Detector output defaults on for prognostic and diagnostic fields, 
# off for prescribed.
prognostic_detector_options = detector_options_enabled_default
diagnostic_detector_options = detector_options_enabled_default
prescribed_detector_options = detector_options_disabled_default

generic_aliased_field =
   (
      attribute material_phase_name { xsd:string },
      attribute field_name { xsd:string }
   )

# Most common mesh choices
mesh_choice = 
   (
      element mesh {
         attribute name { xsd:string }
      }|
      element mesh {
         attribute name { "CoordinateMesh" }
      }|
      element mesh {
         attribute name { "VelocityMesh" }
      }|
      element mesh {
         attribute name { "PressureMesh" }
      }
   )

# Not really a choice, for fields that have to be on the velocity mesh
# currently that's all scalar fields, except pressure
# and of course velocity itself
# If you want to implement scalar fields on other meshes, feel free to do so
# but bare in mind you need to make sure the field stays outside RMEM.
# Currently all scalar fields are packed in RMEM with length nonods
velocity_mesh_choice =
   (
      (
         element mesh {
            attribute name { "VelocityMesh" }
         }|
         element mesh {
            attribute name { "PressureMesh" }
         }|
         element mesh {
            attribute name { "CoordinateMesh" }
         }|
         element mesh {
            attribute name { string }
         }
      )
   )

pressure_mesh_choice =
   (
      (
         element mesh {
            attribute name { "PressureMesh" }
         }|
         element mesh {
            attribute name { "VelocityMesh" }
         }|
         element mesh {
            attribute name { "CoordinateMesh" }
         }|
         element mesh {
            attribute name { string }
         }
      )
   )

# This is the choice of additional scalar field to be solved for
scalar_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
      (
         element scalar_field {
            attribute rank { "0" },
            attribute name { xsd:string },
            ## Field type
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element diagnostic {
                  scalar_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Prognostic scalar fields below this
         element ___Prognostic_Fields_Below___ {
            empty
         }|

# This is the long list of fields that FLUIDITY knows about
# -- First is a list of fields that are primarily prognostic,
#    but can be set to prescribed, or aliased...
# -- The list is in order of most frequently used.

         ## Salinity
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Salinity" },
            attribute replaces { "IDENT = 42" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Temperature" },
            attribute replaces { "IDENT = -1" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Background Temperature
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BackgroundTemperature" },
            (
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Passive Tracer
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Tracer" },
            attribute replaces { "IDENT = 666" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Free Surface
         ## NOTE: if you are using the free_surface boundary condition
         ## applied to the Velocity field (recommended), you should not 
         ## use the prognostic FreeSurface field. In this case you may 
         ## (optionally) add a diagnostic FreeSurface field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FreeSurface" },
            (
               ## Free Surface
               ## NOTE: the diagnostic FreeSurface field only works in combination
               ## with the free_surface boundary condition applied to the Velocity
               ## field. It gives you a 3D field (constant over the vertical)
               ## of the free surface elevation.
               element diagnostic {
                  internal_algorithm,
                  # this is hard-coded on the PressureMesh as long as the Pressure is
                  # if this is no longer true, it should be option-checked to be on the
                  # same mesh as Pressure
                  ## Must be on the same mesh as Pressure
                  element mesh {
                     attribute name { "PressureMesh" }
                  },
                  diagnostic_scalar_field
               }
               
            )
         }|
         ## Second Fluid
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SecondFluid" },
            attribute replaces { "IDENT = 56" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Diffuse Interface
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DiffuseInterface" },
            attribute replaces { "IDENT = 57" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BalancePressure" },
            attribute replaces { "IDENT = -2003" },
            (
               element prognostic {
                  # Note the assumptions about quadratic/linear below and hard-coding
                  # of the mesh, this is because of restrictions of the
                  # current code, will change in the near future.
                  ## Note that this is not the quadratic mesh balance pressure is
                  ## actually calculated on, but the linear mesh it is projected back
                  ## on for output purposes.
                  element mesh {
                     attribute name {  "VelocityMesh" }
                  },
                  prognostic_balance_pressure_field
               }
            )
         }|
         ## If enabled, decomposes Pressure by solving for the balanced part of 
         ## Pressure using a "geopressure" solver:
         ## 
         ##   f = - grad p_gp + g
         ##
         ## By choosing an appropriate mesh (typically velocity mesh order + 1)
         ## for the balanced part of pressure, physical balance can be
         ## represented to a higher degree of accuracy.
         ##
         ## Expanded BalancePressure field. As BalancePressure, but with
         ## additional options, including the ability to choose a general
         ## mesh for the geopressure solver.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GeostrophicPressure" },
            attribute replaces { "IDENT = -2003" },
            (
               element prognostic {
                  ## The GeostrophicPressure mesh. Must be continuous.
                  ## 
                  ## <b>WARNING: It is usual for this to be a higher degree
                  ## mesh than the velocity mesh</b>
                  element mesh {
                     attribute name { xsd:string },
                     comment
                  },
                  prognostic_geostrophic_pressure_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HydrostaticPressure" },
            (
               element prognostic {
                  ## This needs to be a DG mesh
                  mesh_choice,
                  prognostic_vertical_balance_pressure_field
               }
            )
         }|
         ## MaterialVolumeFraction field:
         ##
         ## Volume fraction of this material.
         ## Required in multimaterial simulations.
         ##  - if prognostic solves for the volume fraction
         ##  - if prescribed uses a specified volume fraction
         ##  - if diagnostic solves for the final material volume fraction
         ## Only 1 diagnostic MaterialVolumeFraction field allowed per
         ## simulation or solves for all the volume fractions based on
         ## the SumMaterialVolumeFractions field.
         ## 
         ## A diagnostic MaterialVolumeFraction field is currently required for
         ## compressible multimaterial simulations (even if only 1 material).
         ## Generally also requires a MaterialDensity field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialVolumeFraction" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field,
                  cap_option?,
                  surface_tension_option?
               }|
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field,
                  cap_option?
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field,
                  cap_option?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## MaterialDensity field:
         ##
         ## Field for the density of this material.
         ## Required in multimaterial simulations.
         ##  - prescribed if an incompressible simulation
         ##  - diagnostic if using a linear equation of state
         ##  - prognostic if a compressible simulation
         ## (note that if you set a multimaterial
         ## equation of state and this field is
         ## prognostic then its initial condition
         ## will be overwritten by the density that
         ## satisfies the initial pressure and
         ## the equation of state)
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialDensity" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## MaterialInternalEnergy field:
         ##
         ## Field for the internal energy of this material.
         ## Required in multimaterial compressible simulations
         ## with full miegrunneisen (perfect gas) eos.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialInternalEnergy" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## InternalEnergy field:
         ##
         ## Field for the internal energy of a single material.
         ## Required in compressible simulations
         ## with full miegrunneisen (perfect gas) eos.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "InternalEnergy" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## SumMaterialVolumeFractions field:
         ##
         ## Sums the prognostic MaterialVolumeFraction fields.
         ## - diagnostic: sums all the volume fractions in the other
         ##   material phases
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SumMaterialVolumeFractions" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CopiedField - This field copies the previous timesteps
         ## values from another (specified) field at every iteration
         ## and then solves the field using different (again, specified)
         ## scheme and solution options.
         ## For instance, this field can be used to create a diffused
         ## field to adapt to.
         ## Unless someone requests otherwise this is only currently possible
         ## for fields within the same material_phase.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CopiedField" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  attribute copy_from_field { string },
                  prognostic_scalar_field
               }
            )
         }|
         ## Calculate the stream function of 2D incompressible flow. Note 
         ## that this *only* makes sense for proper 2D (not pseudo-2D) simulations.
         ## Requires a continuous mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "StreamFunction" },
            (
               element prognostic {
                  mesh_choice,
                  prognostic_stream_function_field
               }
            )
         }|
         ## Phytoplankton
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Phytoplankton" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Zooplankton
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Zooplankton" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Nutrient
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Nutrient" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|
         ## Detritus
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Detritus" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|

         ## PhaseVolumeFraction:
         ## Required in porous_media problem type
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhaseVolumeFraction" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }|
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }
            )
         }|

         ## Electrical Potential:
         ## Required in electrokinetic, electrothermal
         ## and electrochemical problems
         ## (sub-option of porous_media problem type)
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ElectricalPotential" },
            (
               element prognostic {
                  velocity_mesh_choice,
                  prognostic_scalar_field
               }
            )
         }|

         # Insert new prognostic scalar fields here using the template:
         #        element scalar_field {
         #            attribute rank { "0" },
         #            attribute name { "NewFieldName" },
         #            (
         #               element prognostic {
         #                  velocity_mesh_choice,
         #                  prognostic_scalar_field
         #               }|
         #               element prescribed {
         #                  velocity_mesh_choice,
         #                  prescribed_scalar_field
         #               }|
         #               element aliased {
         #                  generic_aliased_field
         #               }
         #            )
         #        }
         
# -- Second is a list of fields that are primarily prescribed,
#    but can be aliased. An example is wind velocity.
# -- The list is in order of most frequently used.

         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DistanceToSideBoundaries" },
            attribute replaces { "IDENT = -144" },
            (
               element prescribed {
                  velocity_mesh_choice,
                  prescribed_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
#
# Insert new prescribed scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  velocity_mesh_choice,
#                  prescribed_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic scalar fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PerturbationDensity" },
            attribute replaces { "IDENT = -143" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## ControlVolumeDivergence:
         ##
         ## div field
         ##
         ## Divergence of the velocity field where
         ## the divergence operator is defined using
         ## the control volume C^T matrix.
         ## This assumes that the test space is discontinuous
         ## control volumes.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  diagnostic_cv_divergence_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## FiniteElementDivergence:
         ##
         ## div field
         ##
         ## Divergence of the velocity field where
         ## the divergence operator is defined using
         ## the finite element C^T matrix.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FiniteElementDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_fe_divergence_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Diffusive dissipation
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DiffusiveDissipation" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Viscous dissipation
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ViscousDissipation" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Richardson Number:
         ##
         ##  Ri = \frac{N^2}{(\frac{\partial u}{\partial z})^2 + (\frac{\partial u}{\partial z})^2}
         ## with 
         ##  N^2 = -\frac{g}{\rho_0}\frac{\partial \rho}{\partial z}
         ##
         ## Limitations:
         ##  - Gravity must be constant.
         ##  - Assumes gravity is in -ve final coordinate direction.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "RichardsonNumber" },
            attribute depends { "Velocity,PerturbationDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_richardson_number_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CFLNumber
         ##
         ## See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CFLNumber" },
            attribute replaces { "IDENT = -601" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## ControlVolumeCFLNumber
         ##
         ## Courant Number as defined on a control volume mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeCFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## DG_CourantNumber
         ##
         ## Courant Number as defined on a DG mesh
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DG_CourantNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Discontinuity detector
         ##
         ## takes value 1 where detector is triggered
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "DiscontinuityDetector" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## CVMaterialDensityCFLNumber
         ##
         ## Courant Number as defined on a control volume mesh and
         ## incorporating the MaterialDensity.
         ## Requires a MaterialDensity field!
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CVMaterialDensityCFLNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SolidConcentration" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## This scalar field is meant to replace DENTRAF.
         ## Basically, if you use new options, DENTRAF is no longer needed
         ## No repointing is done from this field to DENTRAF.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "CopyofDensity" },
            attribute replaces { "DENTRAF" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Solid_configuration to 
         ## Visualize the solids and MaterialVolumeFraction together
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VisualizeSolidFluid" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Solid_configuration to 
         ## Visualize the solid_Concentration
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VisualizeSolid" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Solid_configuration to 
         ## map  the solid_Concentration from particle mesh to 
         ## the fluid mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ParticleScalar" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Explicit_ALE to 
         ## visualize functional values before iterations start.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FunctionalBegin" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## Add field to be used by Explicit_ALE to 
         ## visualize functional values at each iteration.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "FunctionalIter" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }
            )
         }|
         ## add a MaterialVolume scalar_field to calculate the spatially varying 
         ## volume of a material (requires a MaterialVolumeFraction)
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialVolume" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## add a MaterialMass scalar_field to calculate the spatially varying 
         ## mass of a material (requires a MaterialVolumeFraction and a MaterialDensity)
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialMass" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculates the MaterialDensity based on the bulk Pressure
         ## (and MaterialInternalEnergy if appropriate) for the equation
         ## of state of this material.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialEOSDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculates the MaterialPressure based on the MaterialDensity
         ## (and MaterialInternalEnergy if appropriate) for the equation
         ## of state of this material.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaterialPressure" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculates the BulkMaterialPressure based on the MaterialDensity
         ## and MaterialVolumeFraction (and MaterialInternalEnergy if appropriate) 
         ## for the equation of state of all materials.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BulkMaterialPressure" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Grid Reynolds number
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GridReynoldsNumber" },
            (element diagnostic {
               internal_algorithm,
               element mesh {
                  attribute name { "VelocityMesh" }
               },
               diagnostic_scalar_field
            }
            | element aliased { generic_aliased_field })
         }|
         ## GridPecletNumber
         ##
         ## Peclet Number Pe = U*dx/2*diffusivity
         ##
         ## Also see the test case 'grid_peclet_number'
         ## if you wish to see the effect of changing the 
         ## diffusivity on a 1D, cg-discretised tracer-field
         ##
         ## Adapting to this field is not recommended
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GridPecletNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  ## Mesh on which to calculate dx
                  mesh_choice,
                  ## This is the name of the scalar field
                  ## to calculate the Peclet number for
                  ## Note this field needs to have a diffusivity
                  element field_name { string },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Horizontal velocity divergence:
         ##
         ## div_H velocity
         ##
         ## Uses the gravity field direction to determine the horizontal plane.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HorizontalVelocityDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Velocity divergence:
         ##
         ## div velocity
         ##
         element scalar_field {
            attribute rank { "0" },
            attribute name { "VelocityDivergence" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Vorticity for a 2D field:
         ##
         ##  du   dv
         ##  -- - --
         ##  dy   dx
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Vorticity2D" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Kinetic energy density:
         ##
         ##  1/2 rho_0*|u|^2
         ##
         ## where rho_0 is the (reference) density 
         ##
         ## Limitations:
         ##  - The Density, PerturbationDensity, KineticEnergyDensity and Velocity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "KineticEnergyDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Gravitational potential energy density:
         ##
         ## rho_0*(1.0 + rho')*(g dot (r - r_0))
         ##
         ## where rho_0 is the (reference) density, rho' is the perturbation density and r_0 is the potential energy zero point.
         ##
         ## Limitations:
         ##  - Requires a constant gravity direction.
         ##  - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GravitationalPotentialEnergyDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field,
                  ## Coordinate of a point with a potential energy of zero.
                  element zero_point {
                     real_dim_vector
                  }
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Isopycnal coordinate
         ##
         ##  z_star(x,t) = 1/A int_V' H(rho(x',t)-rho(x,t)) dV'
         ##
         ## where rho is the density, A is the width/area of the domain
         ##
         ## Limitations:
         ##  - You need to specify a (fine) mesh to redistribute the PerturbationDensity onto
         ##  - Requires a constant gravity direction.
         ##  - The Density, PerturbationDensity and GravitationalPotentialEnergyDensity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "IsopycnalCoordinate" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  ## This is the mesh onto which we redistribute the PerturbationDensity
                  element fine_mesh {
                     attribute name { string }
                  },
                  diagnostic_scalar_field                 
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Background potential energy density:
         ##
         ## PE_b = rho*z_star
         ##
         ## where rho is the density, z_star is the isopycnal coordinate
         ##
         ## Limitations:
         ##  - Requires a constant gravity direction.
         ##  - The Density, PerturbationDensity and
         ##  GravitationalPotentialEnergyDensity fields must be on the
         ##  same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "BackgroundPotentialEnergyDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field                 
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Ertel potential vorticity:
         ##
         ##  (f + curl u) dot grad rho'
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PotentialVorticity" },
            attribute depends { "Velocity,PerturbationDensity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Relative potential vorticity:
         ##
         ##   curl u dot grad rho'
         element scalar_field {
            attribute rank { "0" },
            attribute name { "RelativePotentialVorticity" },
            attribute depends { "Velocity,PerturbationDensity" },
            (
              element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|         
         ## Local average mesh edge lengths
         element scalar_field {
          attribute rank { "0" },
            attribute name { "MeshEdgeLengths" },
            (
              element diagnostic {
                  internal_algorithm,
                  element mesh {
                     attribute name { "CoordinateMesh" }
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculate the horizontal stream function psi where:
         ##   \partial_x \psi = -v
         ##   \partial_y \psi = u
         ## where u and v are perpendicular to the gravity direction. Applies a
         ## strong Dirichlet boundary condition of 0 on all boundaries.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HorizontalStreamFunction" },
            attribute depends { "Velocity" },
            (
              element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  ## Solver
                  element solver {
                     linear_solver_options_sym
                  },
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Speed:
         ##
         ##  |u|
         ##
         ## Limitations:
         ##  - The Speed and Velocity fields must be on the same mesh.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "Speed" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Volume of the vehicles
         ##
         ## used in Traffic Modelling
         element scalar_field {
            attribute rank { "0" },
            attribute name { "SolidPhase" },
            attribute raplaces { "IDENT = -42"},
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two scalar fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ScalarAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_scalar_field,
                  ## Evaluate the absolute difference once the average difference has been removed?
                  element relative_to_average {
                    empty
                  }?,
                  ## Ignore boundary nodes (i.e. zero them when calculating the difference)
                  element ignore_boundaries {
                    empty
                  }?
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,
                  element solver {
                    linear_solver_options_sym
                  }?,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Primary production of Phytoplankton. This is calculated by
         ## the ocean biology module and will not be calculated unless
         ## ocean biology is being simulated.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PrimaryProduction" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Grazing of Phytoplankton by Zooplankton. This is calculated by
         ## the ocean biology module and will not be calculated unless
         ## ocean biology is being simulated.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "PhytoplanktonGrazing" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )

         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "TidalRange" },
            attribute replaces { "IDENT = -32" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field_tidal_range
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MaxFreeSurface" },
            attribute replaces { "IDENT = -33" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "MinFreeSurface" },
            attribute replaces { "IDENT = -34" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeM2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseM2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeS2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseS2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeN2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseN2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeK2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseK2" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeK1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseK1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeO1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseO1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeP1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseP1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeQ1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseQ1" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeMf" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseMf" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeMm" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseMm" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicAmplitudeSSa" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the universal numbering of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "UniversalNumber" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the processors which own the nodes of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "NodeOwner" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Output the processors which own the elements of the mesh on which this field is based.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "ElementOwner" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Primary production of Phytoplankton. This is calculated by
         ## the ocean biology module and will not be calculated unless
         ## ocean biology is being simulated.
         element scalar_field {
            attribute rank { "0" },
            attribute name { "HarmonicPhaseSSa" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }
                  
# Insert new diagnostic scalar fields here using the template:
#        element scalar_field {
#            attribute rank { "0" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  velocity_mesh_choice,
#                  diagnostic_scalar_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

# This is the choice of additional vector field to be solved for
vector_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic vector fields are not possible (other than velocity and those known fields below).
      (
         ## Generic field variable (vector)
         element vector_field {
            attribute rank { "1" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  vector_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
#
# -- List of fields that are primarily prognostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prognostic_fields_below___ {
            empty
         }|
#
# -- List of fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed vector fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

         ## MaterialVelocity field.  Used to impose a velocity on a material
         ## in combination with the imposed_material_velocity_absorption_algorithm
         ## for VelocityAbsorption and imposed_material_velocity_source_algorithm 
         ## for VelocitySource.
         element vector_field {
            attribute rank { "1" },
            attribute name { "MaterialVelocity" },
            (
               element prescribed {
                  mesh_choice,
                  prescribed_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
#
# Insert new prescribed vector fields here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased. An example is Tidal Range.
# -- The list is in order of most frequently used.
#
         ## Diagnostic vector fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         ## Temperature gradient
         element vector_field {
            attribute rank { "1" },
            attribute name { "TemperatureGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Gradient of a scalar field.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "Gradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  diagnostic_scalar_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Gradient of a scalar field evaluated using the C gradient
         ## matrix constructed using finite elements.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "FiniteElementGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  element integrate_gradient_by_parts {
                     empty
                  }?,
                  diagnostic_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Gradient of a scalar field evaluated using the transpose
         ## of the C^T divergence matrix constructed using finite
         ## elements.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "FiniteElementDivergenceTransposed" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  mesh_choice,
                  element integrate_divergence_by_parts {
                     empty
                  }?,
                  diagnostic_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Relative vorticity field - curl of the velocity field
         element vector_field {
            attribute rank { "1" },
            attribute name { "Vorticity" },
            (
               element diagnostic {
                  internal_algorithm,
                  ### Relative vorticity
                  #element algorithm {
                  #   attribute name { "curl" },
                  #   attribute material_phase_support { "single" },
                  #   attribute source_field_name { "Velocity" }
                  #},
                  element mesh {
                     attribute name { "VelocityMesh" }
                  },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|        
         ## Planetary vorticity
         ##
         ## Limitations:
         ##  - Requires geometry dimension of 3.
         element vector_field {
            attribute rank { "1" },
            attribute name { "PlanetaryVorticity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Absolute vorticity:
         ##
         ##   f + curl u
         ##
         ## Limitations:
         ##  - Requires a geometry dimension of 3.
         element vector_field {
            attribute rank { "1" },
            attribute name { "AbsoluteVorticity" },
            attribute depends { "Velocity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Gradient of a scalar field evaluated using the transpose
         ## of the C^T matrix constructed using control volumes.
         ## Field must be in this material_phase.
         element vector_field {
            attribute rank { "1" },
            attribute name { "ControlVolumeDivergenceTransposed" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name { string },
                  velocity_mesh_choice,
                  diagnostic_cv_gradient_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Solid Velocity field.  Used to generate the momentum source 
         element vector_field {
            attribute rank { "1" },
            attribute replaces {"UTRAF,VTRAF,WTRAF"},
            attribute name { "SolidVelocity" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## Same as Solid Velocity field but it is on the Particle mesh.
         ## It is used to map the velocities coming from an external program like
         ## FEMDEM or DEM to the fluid mesh. 
         element vector_field {
            attribute rank { "1" },
            attribute name { "ParticleVector" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## Same as Solid Velocity field but it is on the Particle mesh.
         ## It is used to map the velocities coming from an external program like
         ## FEMDEM or DEM to the fluid mesh. 
         element vector_field {
            attribute rank { "1" },
            attribute name { "ParticleForce" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|

         ## Same as Solid Velocity field but it is on the Particle mesh.
         ## It is used to map the velocities coming from an external program like
         ## FEMDEM or DEM to the fluid mesh. 
         element vector_field {
            attribute rank { "1" },
            attribute name { "SolidForce" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         element vector_field {
            attribute rank { "1" },
            attribute name { "VelocityPlotForSolids" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## Same as Solid Velocity field but it is on the Particle mesh.
         ## It is used to map the velocities coming from an external program like
         ## FEMDEM or DEM to the fluid mesh. 
         element vector_field {
            attribute rank { "1" },
            attribute name { "FunctionalGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## LinearMomentum field.
         ##  p = \rho*u 
         ## (where p is the linear momentum, \rho the density and u the velocity)
         element vector_field {
             attribute rank { "1" },
             attribute name { "LinearMomentum" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Calculate the control volume auxiliary gradient for a particular field.
         ## The related field must be a scalar field in this material_phase.
         element vector_field {
            attribute rank { "0" },
            attribute name { "ControlVolumeAuxiliaryGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  attribute gradient_of_field { string },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Calculate the dg (Bassi Rebay) auxiliary gradient for a particular field.
         ## The related field must be a scalar field in this material_phase.
         element vector_field {
            attribute rank { "0" },
            attribute name { "DGAuxiliaryGradient" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  attribute gradient_of_field { string },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Experimental geostrophic source field to be used in combination with
         ## a free surface. Does not solve a vertical balance yet.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GeostrophicSource" },
            (
               element diagnostic {
                  internal_algorithm,
                  mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "AbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

         ## Absolute Difference between two vector fields.
         ##
         ## Both fields must be in this material_phase.
         ## Assumes both fields are on the same mesh as the AbsoluteDifference field.
         element vector_field {
            attribute rank { "1" },
            attribute name { "VectorAbsoluteDifference" },
            (
               element diagnostic {
                  internal_algorithm,
                  attribute field_name_a { string },
                  attribute field_name_b { string },
                  mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         
         ## Bed Shear Stress = density*drag_coeff*|u|*u
         ##
         ## at the moment this assumes the density and drag coefficients are constants.
         ## This diagnostic vector field is only calculated over surface elements/nodes, 
         ## interior nodes will have zero value.
         element vector_field {
             attribute rank { "1" },
             attribute name { "BedShearStress" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_vector_field_bed_shear_stress
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Max Bed Shear Stress.
         ##
         ## Note that you need BedShearStress turned on for this to work.
         element vector_field {
             attribute rank { "1" },
             attribute name { "MaxBedShearStress" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice
                   #diagnostic_vector_field_max_bed_shear_stress
                }|
                element aliased {
                   generic_aliased_field
                }
             ),
            ## This is the time after which the max operator is
            ## applied to the bed shear stress.
            element spin_up_time {
               real
            }
         }|

         ## Coordinate field remapped to the mesh of your choice.
         element vector_field {
             attribute rank { "1" },
             attribute name { "DiagnosticCoordinate" },
             (
                element diagnostic {
                   internal_algorithm,
                   mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|

         ## Displacement
         element vector_field {
             attribute rank { "1" },
             attribute name { "Displacement" },
             (
                element diagnostic {
                   internal_algorithm,
                   velocity_mesh_choice,
                   diagnostic_vector_field
                }|
                element aliased {
                   generic_aliased_field
                }
             )
         }|
         ## Galerkin projection of one field onto another mesh.
         ##
         ## The field must be in this material_phase.
         ## 
         ## NOTE: you need the solver options if the mesh
         ## of this field is continuous.
         element vector_field {
            attribute rank { "1" },
            attribute name { "GalerkinProjection" },
            (
               element diagnostic {
                  internal_algorithm,
                  element source_field_name { string },
                  mesh_choice,
                  ## Lump the mass matrix of the galerkin projection
                  ## less accurate but faster and might give smoother result.                  
                  element lump_mass {
                     empty
                  }?,                  
                  element solver {
                  linear_solver_options_sym
                  }?,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Computes the buoyancy term
         element vector_field {
            attribute rank { "1" },
            attribute name { "Buoyancy" },
            (
               element diagnostic {
                  buoyancy_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## Projects the Coriolis term onto the mesh of this diagnostic field.
         ## Note that multiple projection methods are available (under the
         ## algorithm option).
         element vector_field {
            attribute rank { "1" },
            attribute name { "Coriolis" },
            (
               element diagnostic {
                  coriolis_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }
            )
         }|
         ## Compute the imbalanced component of velocity,
         ## that is,
         ## u - u_bal
         ## where u_bal is the velocity that puts the state in geostrophic
         ## balance.
         ## Note: if your VelocityMesh is continuous, then the solver option
         ## is necessary.
         element vector_field {
            attribute rank { "1" },
            attribute name { "ImbalancedVelocity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  element solver {
                  linear_solver_options_sym
                  },
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|
         ## Compute the balanced component of velocity,
         ## that is, the velocity that puts the state in geostrophic
         ## balance.
         ## This diagnostic depends on ImbalancedVelocity.
         element vector_field {
            attribute rank { "1" },
            attribute name { "BalancedVelocity" },
            attribute depends { "ImbalancedVelocity" },
            (
               element diagnostic {
                  internal_algorithm,
                  velocity_mesh_choice,
                  diagnostic_vector_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }

# Insert new diagnostic vector field here using the template:
#        element vector_field {
#            attribute rank { "1" },
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_vector_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )  

# This is the choice of additional tensor fields
tensor_field_choice =
   (
# The first is a generic field, which may be used for any user-defined field
# that FLUIDITY knows nothing about, or a generic diagnostic
# Prognostic tensor fields are not possible.
      (
         ## Generic field variable (tensor)
         element tensor_field {
            attribute rank { "2" },
            attribute name { xsd:string },
            ## Field type
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }|
               element diagnostic {
                  tensor_diagnostic_algorithms,
                  velocity_mesh_choice,
                  diagnostic_tensor_field
               }
            )
         }|
#
# -- Second is a list of tensor fields that are primarily prescribed,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Prescribed scalar fields below this
         element ___Prescribed_fields_below___ {
            empty
         }|

         ## MaterialViscosity field:
         ##
         ## Field for the viscosity of this material.
         ## Required if using a diagnostic bulk viscosity
         ## in a multimaterial simulation.
         element tensor_field {
            attribute rank { "2" },
            attribute name { "MaterialViscosity" },
            (
               element prescribed {
                  mesh_choice,
                  prescribed_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }|

#
# Insert new prescribed tensor fields here using the template:
#        element tensor_field {
#            attribute rank { "2" },
#            attribute name { "NewFieldName" },
#            (
#               element prescribed {
#                  mesh_choice,
#                  prescribed_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }|
#
# -- Last is a list of fields that are primarily diagnostic,
#    but can be aliased.
# -- The list is in order of most frequently used.
#
         ## Diagnostic tensor fields below this
         element ___Diagnostic_Fields_Below___ {
            empty
         }|
         ## From a field on a mesh, diagnose the anisotropic
         ## interpolation weight that would give the mesh back.
         ## It is computed as:
         ## \Eps = M^-1 |H|
         element tensor_field {
            attribute rank { "2" },
            attribute name { "FieldTolerance" },
            (
               element diagnostic {
                  internal_algorithm,
                  element source_field_name { string },
                  velocity_mesh_choice,
                  diagnostic_tensor_field
               }|
               element aliased {
                  generic_aliased_field
               }
            )
         }

# Insert new diagnostic tensor field here using the template:
#        element tensor_field {
#            attribute name { "NewFieldName" },
#            (
#               element diagnostic {
#                  internal_algorithm,
#                  mesh_choice,
#                  diagnostic_tensor_field
#               }|
#               element aliased {
#                  generic_aliased_field
#               }
#            )
#        }
      )
   )

mesh_info =
   (
      ## Read mesh from file.
      element from_file {
         (
            ## Triangle mesh format.
            ##
            ## Enter the base name without the .edge .ele, .face or
            ## .node extensions, and without process numbers.
            element format {
              attribute name { "triangle" },
              comment
            }|
            ## Read the mesh from a vtu. Note that the mesh will have no surface
            ## or region IDs.
            element format {
              attribute name { "vtu" },
              comment
            }|
            ## CGNS mesh format (not yet implemented)
            element format {
               attribute name { "cgns" },
               comment
            }
         ),
         attribute file_name { xsd:string },
         from_file_mesh_stat_options,
         comment
      }|
      ## Make mesh from existing mesh. 
      element from_mesh {
         mesh_choice,
         element mesh_shape {
            element polynomial_degree {
               integer
            }
         }?,
         element mesh_continuity {
            element string_value{
               "continuous" | "discontinuous"
            }
         }?,
         ## Make mesh periodic
         element periodic_boundary_conditions {
            attribute name { xsd:string },
            ## List of boundary ids that are aliased to
            element physical_boundary_ids {
               integer_vector
            },
            ## List of boundary ids that are aliased
            element  aliased_boundary_ids {
               integer_vector
            },
            ## Python code which takes coordinate of an aliased
            ## boundary node and returns the coordinate of a physical
            ## boundary node
            element coordinate_map {
               python_code
            },
            ## <b>Don't turn this on by hand!</b>
            ## This option gets set by the periodise tool, to indicate
            ## that this mesh should have the periodic boundary conditions
            ## <b>removed</b>. See the discussion on the wiki about 
            ## parallel periodic boundary conditions.
            element remove_periodicity {
               empty
            }?
         }*,
         ## Extrude a horizontal (1D or 2D) mesh in the vertical
         element extrude {
            ## Depth over which to extrude
            ## top will be at z=0
            ## bottom will be at z=-bottom_depth
            element bottom_depth {
               input_choice_real
            },
            ## Constant or function to specify the depth of the
            ## layers. The function is a function of all coordinates
            ## (so in 2+1D: x,y and z) to specify a layer depth that
            ## varies both in the horizontal as in the vertical.
            element sizing_function {
               input_choice_real
            },
            ## surface_id to assign to the top of the extruded mesh
            element top_surface_id {
               integer
            }?,
            ## surface_id to assign to the bottom of the extruded mesh
            element bottom_surface_id {
               integer
            }?
         }?,
         derived_mesh_stat_options,
         comment
      }
   )

# Options for inclusion/exclusion of mesh statistics from the .stat file
include_mesh_in_stat =
   (
      ## Include this mesh in the .stat file
      element include_in_stat {
         comment
      }
   )
exclude_mesh_from_stat =
   (
      ## Exclude this mesh from the .stat file
      element exclude_from_stat {
         comment
      }
   )

# Diagnostic statistics options for meshed, with enabled by default
mesh_stat_options_enabled_default = include_mesh_in_stat
mesh_stat_options_enabled_default |= exclude_mesh_from_stat

# Diagnostic statistics options for meshed, with disabled by default
mesh_stat_options_disabled_default = exclude_mesh_from_stat
mesh_stat_options_disabled_default |= include_mesh_in_stat

from_file_mesh_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         mesh_stat_options_enabled_default
      }
   )
derived_mesh_stat_options =
   (
      ## Specify what is added to .stat files
      element stat {
         mesh_stat_options_disabled_default
      }
   )

input_choice_tensor_field =
   (
      (
         ## An isotropic tensor, i.e.
         ## one with no directional variation.
         ## Can be represented as a scalar real.
         element isotropic {
            input_choice_real
         }|
         ## A diagonal tensor, i.e.
         ## one with only diagonal nonzero entries.
         ## Can be represented as a vector real.
         element diagonal {
            input_choice_real_dim_vector
         }|
         ## A symmetric tensor, i.e.
         ## A^T = A
         element anisotropic_symmetric {
            input_choice_real_dim_symmetric_tensor
         }|
         ## A general asymmetric tensor.
         element anisotropic_asymmetric {
            input_choice_real_dim_tensor
         }
      )
   )

region_ids = 
   ( 
      ## Optional region ids to associate different values
      ## to different regions of the mesh.
      ## Leave unselected if you`re not using multiple regions or
      ## region_ids.
      ## Currently only works with triangle files created by gmsh2triangle.
      element region_ids {
         integer_vector
      }?
   )

temporal_control_volume_options =
   (
      ## Temporal discretisation options that are only relevant if a control volume or coupled_cv spatial discretisation is selected for this field.
      element control_volumes {
         ## Number of iterations within an advection solve.
         ## This increases the accuracy of the face values and ensures that
         ## the pivoted solution is cancelled out.
         ## Defaults to 1 if unselected.
         element number_advection_iterations {
            attribute replaces { "INT(ABS(NDISOT)/10)" },
            integer,
            ## Cut short advection_iterations if the specified tolerance
            ## is reached.
            ## This only works for pure control volume discretisations.
            element tolerance {
               real,
               (
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The infinity norm.
                  element infinity_norm {
                    empty
                  }|
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The l2 norm.
                  element l2_norm {
                    empty
                  }|
                  ## Select the norm with which you want the tolerance to be tested.
                  ##
                  ## The l2 norm evaluated on a control volume mesh.
                  element cv_l2_norm {
                    empty
                  }
               )               
            }?
         }?,
         (
            ## Use timestep subcycling to solve this equation.
            ## Specify the maximum courant number per subcycle.
            ## This only works for pure control volume discretisations.
            element maximum_courant_number_per_subcycle {
               real,
               field_based_cfl_number_options
            }|
            ## Use timestep subcycling to solve this equation.
            ## Specify the number of subcycles.
            ## This only works for pure control volume discretisations.
            element number_advection_subcycles {
               integer
            }
         )?,
         ## Only works if a control volume or coupled_cv spatial discretisation is selected.
         ## If not active then the theta specified above will be used.
         ## Otherwise use variable limited theta on individual faces.
         element limit_theta {
            attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 1,3,5,7,9 (odd)" },
            empty
         }?,
         ## Only works if a control volume or coupled_cv spatial discretisation is selected.
         ## Time discretisation of upwind discretisation off which the
         ## higher order solution is pivotted.
         ##  - pivot_theta = 1 - implicit pivot (default if not set and 
         ##                      best choice if not intentionally modifying
         ##                      scheme to be explicit)
         ##  - pivot_theta = 0 - explicit pivot
         element pivot_theta {
            real
         }?
      }
   )

temporal_discontinuous_galerkin_options = 
   (
      ## This enables DG-specific timestepping options, such as
      ## explicit advection subcycling. 
      element discontinuous_galerkin {
         (
            ## Use timestep subcycling to solve this equation.
            ## Specify the maximum courant number per subcycle.
            element maximum_courant_number_per_subcycle {
               real
            }|
            ## Use timestep subcycling to solve this equation.
            ## Specify the number of subcycles.
            element number_advection_subcycles {
               integer
            }
         )?
      }
   )

pure_cv_options = 
   (
      ## Use a pure control volume discretisations.
      ## Follows a new control volume code path.
      element control_volumes {
         spatial_control_volume_options,
         (
            ## Use the gradient of the field constructed using the
            ## basis functions of the parent finite element mesh to
            ## form the divergence.
            ##
            ## DOES NOT CURRENTLY WORK WITH ROBIN OR WEAK DIRICHLET BOUNDARY CONDITIONS!
            ##
            ## Based on schemes in Handbook of Numerical Analysis,
            ## P.G. Ciarlet, J.L. Lions eds, vol 7, pp 713-1020
            element diffusion_scheme {
              attribute name{"ElementGradient"}
            }|
            ## Use an auxiliary gradient equation to find the gradient of the field.
            ##
            ## DOES NOT CURRENTLY WORK WITH ROBIN BOUNDARY CONDITIONS!
            ##
            ## Based on scheme proposed in Bassi, F. & Rebay, S., A
            ## high-order accurate discontinuous finite element method
            ## for the numerical solution of the compressible
            ## Navier-Stokes equations, Journal Of Computational
            ## Physics, 1997, 131, 267-279
            element diffusion_scheme {
              attribute name{"BassiRebay"}
            }
         )
      }
   )

coupled_cv_options = 
   (
      ## Use a pure control volume discretisations with face value
      ## restrictions between different fields in different material_phases.
      ##
      ## THIS DOES NOT WORK WITH DIFFUSION!
      ##
      ## Follows a new control volume code path.
      element coupled_cv {
         coupled_spatial_control_volume_options,
         ## Set the maximum and minimum bounds for the sum up to and including this field.
         ## This defines the limiter used to enforce boundedness on this field.
         element parent_sum {
            element target_maximum {
              real
            },
            element target_minimum {
              real
            }
         }
      }
   )

spatial_control_volume_options = standard_control_volume_options
spatial_control_volume_options |= compressive_control_volume_options

standard_control_volume_options = 
   (
      ## First Order Upwind face value discretisation
      ##  face_value = donor_value, 
      ## where
      ##  donor_value = income*val_1 + (1.-income)*val_2, 
      ## where val_i is the value on the ith node neighbouring the face and
      ## income = [0, 1] depending on whether the flow is coming from node 1 or 2
      ## First order upwinding is monotonic so no limiting is ever required
      element face_value {
        attribute name { "FirstOrderUpwind" },
        attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 0,1" },
        empty
      }|
      ## Trapezoidal face value discretisation
      ##  face_value = 0.5*(val_1 + val_2), 
      ## where
      ##  val_i is the value on the ith node neighbouring the face
      ##
      ## Trapezoidal discretisation is unbounded so limiting is compulsory
      element face_value {
        attribute name { "Trapezoidal" },
        attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 2,3" },
        limiter_options
      }|
      ## Finite Element face value discretisation
      ##  face_value = finite element interpolation from surrounding nodes
      ##
      ## Finite element discretisation may become unbounded so limiting is often necessary.
      element face_value {
        attribute name { "FiniteElement" },
        attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 4,5,6,7" },
        limiter_options
      }|
      ## First Order Downwind face value discretisation
      ##  face_value = downwind_value, 
      ## where
      ##  donor_value = (1.-income)*val_1 + income*val_2, 
      ## where val_i is the value on the ith node neighbouring the face and
      ## income = [0, 1] depending on whether the flow is coming from node 1 or 2
      ## First order downwinding is unconditionally unstable
      element face_value {
        attribute name { "FirstOrderDownwind" },
        empty
      }
   )
   
coupled_spatial_control_volume_options = coupled_control_volume_options
coupled_spatial_control_volume_options |= compressive_control_volume_options

# coupled control volume options are the same as the standard ones (annoyingly copied and pasted)
# except that firstorderupwind gets limiter options
coupled_control_volume_options = 
   (
      ## First Order Upwind face value discretisation
      ##  face_value = donor_value, 
      ## where
      ##  donor_value = income*val_1 + (1.-income)*val_2, 
      ## where val_i is the value on the ith node neighbouring the face and
      ## income = [0, 1] depending on whether the flow is coming from node 1 or 2
      ## First order upwinding is monotonic so no limiting is ever required
      element face_value {
        attribute name { "FirstOrderUpwind" },
        attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 0,1" },
        limiter_options
      }|
      ## Trapezoidal face value discretisation
      ##  face_value = 0.5*(val_1 + val_2), 
      ## where
      ##  val_i is the value on the ith node neighbouring the face
      ##
      ## Trapezoidal discretisation is unbounded so limiting is compulsory
      element face_value {
        attribute name { "Trapezoidal" },
        attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 2,3" },
        limiter_options
      }|
      ## Finite Element face value discretisation
      ##  face_value = finite element interpolation from surrounding nodes
      ##
      ## Finite element discretisation may become unbounded so limiting is often necessary.
      element face_value {
        attribute name { "FiniteElement" },
        attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 4,5,6,7" },
        limiter_options
      }
   )
   
compressive_control_volume_options = 
   (
      ## HyperC face value discretisation
      ##
      ## face_value calculated from upper bound of explicit TVD zone of NVD diagram
      ## Normally used for MaterialVolumeFraction fields
      element face_value {
        attribute name { "HyperC" },
        attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 8,9" },
        upwind_value_options?,
        cv_face_cfl_number_options
      }|
      ## UltraC face value discretisation
      ##
      ## face_value calculated from extended upper bound of
      ## explicit TVD zone of NVD diagram assuming
      ## values bounded by target_maximum and target_minimum.
      element face_value {
        attribute name { "UltraC" },
        attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 8,9, with ULTRAC = TRUE from solidity_options.inp" },
        ## Specifiy the upper bound which UltraC will use to
        ## calculate the maximum flux.
        element target_maximum {
            real
        },
        ## Specifiy the lower bound which UltraC will use to
        ## calculate the minimum flux.
        element target_minimum {
            real
        },
        upwind_value_options?,
        cv_face_cfl_number_options
      }|
      ## **UNDER TESTING**
      ##
      ## PotentialUltraC face value discretisation
      ##
      ## face_value calculated from extended upper bound of
      ## explicit TVD zone of NVD diagram if potential
      ## value of field is sufficient (as specified by
      ## target_maximum) to ensure the correct front advection
      ## velocity.
      ##
      ## If not then either switch to HyperC or use a modified flux
      ## based on the potential function.
      element face_value {
        attribute name { "PotentialUltraC" },
        ## Specifiy the upper bound which PotentialUltraC will use
        ## to calculate the maximum flux if the potential function
        ## value is sufficient to maintain the correct front
        ## advection velocity.
        element target_maximum {
            real
        },
        ## Specifiy the lower bound which PotentialUltraC will use to calculate the minimum flux.
        element target_minimum {
            real
        },
        (
            ## Select what PotentialUltraC should do if the
            ## potential function value does not reach the required
            ## value specified by the target_maximum.
            ##
            ## Switch to using HyperC face values.  This ensures
            ## that the advection velocity is correct however may
            ## create isolated regions beneath the target_maximum.
            element switch_to_hyperc {
              empty
            }|
            ## Select what PotentialUltraC should do if the
            ## potential function value does not reach the required
            ## value specified by the target_maximum.
            ##
            ## Modify the maximum nodal values (both downwind and
            ## upwind) so that the fluxes are at their maximum
            ## possible without affecting the front advection
            ## velocity.
            element use_potential_flux {
              empty
            }
        ),
        upwind_value_options?,
        cv_face_cfl_number_options
      }
   )

#Select the type of dynamic control to be used
#Note: DEM and FEMDEM require the respective libraries
#to be compiled.
input_solid_dynamics_choice =         
   (
      ## Obtain values from point and radius file.
      ##
      ## First line of file is free to use (for comments)
      ## Second line must contain the number of particles
      ## Third and fourth line are again for comments. 
      ## Following lines include 10 columns, corresponding to 
      ## the particle's x, y, and z positions, followed by the radius, then
      ## velocities in x, y, and z directions, followed by angular velocities
      ## in the x, y, and z directions.
      element dynamic_type {
         attribute name {"from_input_file"},
         attribute file_name {xsd:string}
      }|
      ## Two python scripts must be provided. The script is cycled over each particle.
      ## One script for particle position (output is tuple of position coords)
      ## Second script is for particle radius (output is tuple of position coords)
      ## Third script is for particle translational velocity.
      ## Fourth script is for particle angular velocity. (Note: particles 
      ## have a no slip boundary condition at the surface, so this angular velocity
      ## WILL matter to the flow.)
      ## Python functions should be of the form:
      ##  def val(X, t):
      ##    Function code
      ##    return # Return value
      ## where X is a tuple of length geometry dimension.
      ##    X[0] contains the number of the particle (in real format)
      element dynamic_type {
         attribute name {"python_script"}
      }|
      element dynamic_type {
         attribute name {"use_simple_dynamics"},
         element set_bottom{real},
         element set_xmin{real},
         element set_ymin{real},
         element set_zmin{real},
         element set_xmax{real},
         element set_ymax{real},
         element set_zmax{real}
      }|
      ## Using y3D to model dynamics. Filename of input file for y3D must
      ## be specified.
      element dynamic_type {
         attribute name {"use_y3D"},
         attribute file_name {xsd:string}
      }|
      ## Using femdem 2D to model dynamics. Filename of input file must
      ## be specified.
      element dynamic_type {
         attribute name {"use_2Dfemdem"},
         attribute file_name {xsd:string}
      }|
      ## Using femdem 3D to model dynamics. Filename of input file must
      ## be specified.
      element dynamic_type {
         attribute name {"use_3Dfemdem"},
         attribute file_name {xsd:string},
         element quad2lin {
            attribute file_name {xsd:string}
         }
      }         
   )

cap_option =
   (
      ## Cap the min and max values of this field when using
      ## it as a volume fraction to work out bulk material
      ## properties.
      ## No capping used if not selected.
      element cap_values {
         ## Set the upper bound on the field.
         ## Defaults to huge(0.0)*epsilon(0.0) if not set.
         element upper_cap {
            real
         }?,
         ## Set the lower bound on the field.
         ## Defaults to -huge(0.0)*epsilon(0.0) if not set.
         element lower_cap {
            real
         }?
      }
   )

surface_tension_option =
   (
      element surface_tension {
        ## Surface tension coefficient
        element surface_tension_coefficient {
          real
        },
        ## The equilibrium contact angle (in radians) with the boundaries identified by the surface ids
        element equilibrium_contact_angle {
          real,
          ## Surface ids:
          element surface_ids {
              integer_vector
          }
        }?
      }
   )

limiter_options =
  (
      (
        ## Limit the face value to satisfy a boundedness criterion.
        element limit_face_value{
          (
            sweby_limiter|
            ultimate_limiter
          )
        }|
        ## Do not limit the face value
        element do_not_limit_face_value{
          empty
        }
      )
  )

sweby_limiter = 
  ## See "High-Resolution Schemes Using Flux Limiters for
  ## Hyperbolic Conservation-Laws", P. K. Sweby, 1984, Siam
  ## Journal on Numerical Analysis, 21, 995-1011
  element limiter {
    attribute replaces { "MOD(INT(ABS(NDISOT)/1),10) = 2,3,4,5" },
    attribute name {"Sweby"},
    slope_options?,
    upwind_value_options?
  }

ultimate_limiter =
  ## See "The Ultimate Conservative Difference Scheme Applied
  ## to Unsteady One-Dimensional Advection", B. P. Leonard,
  ## 1991, Computer Methods in Applied Mechanics and
  ## Engineering, 88, 17-74
  element limiter {
    attribute name {"Ultimate"},
    field_based_cfl_number_options,
    upwind_value_options?
  }

slope_options =
   (
      ## Control the upper and lower slopes of the NVD limiter
      element slopes {
         ## Defaults to Sweby, 1984 limiter (= 1.0) if unselected
         element lower {
            real
         }?,
         ## Defaults to Sweby, 1984 limiter (= 2.0) if unselected
         element upper {
            real
         }?
      }
   )

upwind_value_options =
   (
      (
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## This method projects the upwind value from a point in the element just
         ## upwind of the node pair straddling the face.  It is otherwise known as 
         ## anisotropic limiting.
         ## This is only available on simplex meshes as it involes a search around
         ## the donor node to find the upwind element.
         element project_upwind_value_from_point {
            attribute replaces { "NDISOT > 0 on simplex meshes" },
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which it was found from.
            element bound_projected_value_locally {
               empty
            }?,
            ## Store the locations of the elements where the upwind values
            ## are projected from for each node pair.
            ## This inserts an integer csr matrix into state so is memory expensive but
            ## saves a significant amount of time (searching around the neighbouring elements).
            ## This is unsafe for moving meshes but should be ok for adaptive meshes.
            element store_upwind_elements {
               attribute replaces { "ABS(NDISOT) >= 1000" },
               ## Store the quadrature locations within the elements
               ## where the upwind values
               ## are projected from for each node pair.
               ## This inserts a real block csr matrix into state so is even more memory
               ## expensive than just storing the upwind elements and
               ## only saves a comparitively
               ## marginal amount of time (as actually searching the
               ## neighbouring elements is the
               ## slowest bit, finding the quadrature is relatively easy).
               element store_upwind_quadrature {
                  attribute replaces { "ABS(NDISOT) >= 1000" },
                  empty
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Projects the value of the advected variable from the downwind or donor node
         ## using the interpolated gradient at the donor node in the
         ## direction of the vector
         ## connecting the node pair straddling the face.
         ## This is available on all meshes (except if bounding the values).
         element project_upwind_value_from_gradient {
            (
               ## Select which node to project from:
               ## Project from the downwind node (Jasak et al., 1999) so that:
               ## upwind_value = downwind_value - 2*gradient.vector
               element project_from_downwind_value {
                  comment
               }|
               ## Select which node to project from:
               ## Project from the donor node so that:
               ## upwind_value = donor_value - gradient.vector
               element project_from_donor_value {
                  comment
               }
            ),
            ## When the donor node is on a domain boundary reflect the projection
            ## back into the mesh.
            element reflect_off_domain_boundaries {
               empty
            }?,
            ## Constrain the projected value to be between the min and max of the
            ## element values which surround it.
            ## This is only available on simplex meshes as it involes a search around
            ## the donor node to find the upwind element.
            element bound_projected_value_locally {
               ## Store the locations of the elements closest to the project value.
               ## This inserts an integer csr matrix into state so is
               ## memory expensive but
               ## saves a significant amount of time (searching around
               ## the neighbouring elements).
               ## This is unsafe for moving meshes but should be ok for adaptive meshes.
               element store_upwind_elements {
                  comment
               }?
            }?
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the maximum or minimum of the neighbouring
         ## nodes depending on the local slope of the donor and downwind values.
         ## Otherwise known as isotropic limiting.
         ## This is available on all meshes.
         element locally_bound_upwind_value {
            attribute replaces { "all cube elements, NDISOT < 0 on simplex elements" },
            empty
         }|
         ## Select the method to be used for calculating the upwind value.
         ## If not selected will default to project_upwind_value_from_point for
         ## simplex element meshes and to a locally_bound_upwind_value for cube
         ## element meshes.
         ##
         ## Chooses an upwind value by selecting the value at the node most directy
         ## upwind from the vector connecting the donor and downwind nodes.
         ## This is available on all meshes.
         element pseudo_structured_upwind_value {
            empty
         }
      )
   )

field_based_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         ##
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## Select the Courant Number definition to be used.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

cv_face_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses a control volume definition of the CFL Number
         ## that incorporates the MaterialDensity.
         ## Requires a MaterialDensity field in this material_phase!
         element courant_number {
            attribute name { "CVMaterialDensityCFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
            empty
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the Courant Number definition to be used in the slope of
         ## the NVD diagram upper bound.
         element courant_number {
            attribute name { string },
            empty
         }
      )
   )

timestep_cfl_number_options =
   (
      (
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the finite element approximation of the CFL Number.
         element courant_number {
            attribute name { "CFLNumber" },
              ## Select the mesh on which you wish to evaluate the CFLNumber.
              velocity_mesh_choice
         }|
         ## Select the Courant Number definition to be used for adaptive timestepping.
         ## This uses the control volume definition of the CFL Number.
         element courant_number {
            attribute name { "ControlVolumeCFLNumber" },
              ## Select the mesh on which you wish to evaluate the ControlVolumeCFLNumber.
              velocity_mesh_choice
         }
      )
   )

mixing_stats =
   (
      ## Enable to include in the .stat file the fractions of the
      ## scalar field contained in
      ## bins specified by the user. This allows mixing of the field to be quantified.
      ## Replaces and expands upon the old heaviside.dat file
      element include_mixing_stats{
         attribute name { xsd:string },
         attribute replaces { "heaviside.dat file" },
         (
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            ##
            ## NOTE: continuous_galerkin only works with linear tets
            ##
            ## NOTE: continuous_galerkin is not fully validated yet
            element continuous_galerkin {
               ## if select normalise the volume fractions will be
               ## divided by the total volume of the domain
               element normalise {
                  empty
               }?
            }|
            ## Select whether to evaluate the volume fraction over the finite element
            ## (continuous galerkin) or within the control volume (control_volumes).
            element control_volumes {
               ## if select normalise the volume fractions will be divided by the total volume of the domain  
               element normalise {
                  empty
               }?
            }
         ),
         ## The values of the bounds of the bins 
         ## e.g. the values 0 1 2 3 will return 4 bins 
         ## and the fraction of the field in each bin with,
         ## 0<=field<1, 1<=field<2, 2<=field<3, 3<=field, 
         ## will be calculated. 
         element mixing_bin_bounds { 
            real_vector 
         },
         ## Define the tolerance beneath the specified bins that should be included.
         ## Defaults to zero at machine tolerance (epsilon(0.0)) if not selected.
         element tolerance {
            real
         }?
      }
   )

cv_stats =
   (
      ## Include statistics evaluated on the control volume mesh.
      element include_cv_stats {
         empty
      }
   )

# Options for inclusion of calculations of surface integrals in the .stat file   
surface_integral_stats_base.surface_integral =
   (
      attribute name { xsd:string },
      ## Surface IDs defining the surface over which to integrate. If disabled, integrates over the whole surface.
      element surface_ids {
         integer_vector
      }?,
      ## Enable to normalise the integral by dividing by the surface area
      element normalise {
         comment
      }?
   )
surface_integral_stats_scalar =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  value: Integrates the field
      ##  gradient_normal: Integrates the normal component of the gradient of the field
      element surface_integral {
         surface_integral_stats_scalar.surface_integral
      }
   )
surface_integral_stats_scalar.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_scalar.surface_integral &=
   (
      attribute type { "value" | "gradient_normal" }
   )
surface_integral_stats_vector =
   (
      ## Surface integral calculations. The following integral types are available:
      ##  normal: Integrates the normal component of the field
      element surface_integral {
         surface_integral_stats_vector.surface_integral
      }
   )
surface_integral_stats_vector.surface_integral = surface_integral_stats_base.surface_integral
surface_integral_stats_vector.surface_integral &=
   (
      attribute type { "normal" }
   )

velocity_equation_choice =
   (
      ## Select the equation used to solve for velocity.
      ## LinearMomentum is the norm and works for all discretisation types.
      element equation {
         attribute name { "LinearMomentum" }
      }|
      ## Select the equation used to solve for velocity.
      ## Boussinesq only works for continuous_galerkin and discontinuous_galerkin.
      element equation {
         attribute name { "Boussinesq" }
      }|
      ## Select the equation used to solve for velocity.
      ## Drainage only works for continuous_galerkin and discontinuous_galerkin.
      element equation {
         attribute name { "Drainage" }
      }
   )

scalar_equation_choice =
   (
      (
         ## Select the equation used to solve for this field.
         ## Advection Diffusion is the norm for scalar fields.
         ## Works for all discretisation types.
         element equation { 
            attribute name { "AdvectionDiffusion" }
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Conservation of Mass equation - requires the selection of a Density field.
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         element equation { 
            attribute name { "ConservationOfMass" },
            (
               ## Select density to use in the Conservation of Mass Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Conservation of Mass Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Conservation of Mass Equation
               element density {
                  attribute name { string }
               }
            )
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Reduced Conservation of Mass equation - requires the selection of a Density field.
         ##
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         ##
         ## This equation is very similar to a standard conservation of mass equation
         ## except that the time discretisation uses only a single time level of density.
         ## This enables consistency between the
         ## MaterialVolumeFraction (ReducedConservationOfMass) and
         ## MaterialDensity (Advection) equations in compressible multimaterial simulations.
         element equation { 
            attribute name { "ReducedConservationOfMass" },
            (
               ## Select density to use in the Reduced Conservation of Mass Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Reduced Conservation of Mass Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Reduced Conservation of Mass Equation
               element density {
                  attribute name { string }
               }
            )
         }|
         ## ***UNDER TESTING***
         ##
         ## Select the equation used to solve for this field.
         ## Internal Energy equation - requires the selection of a Density field.
         ## ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
         ## DIFFUSIVITY, SOURCE OR ABSORPTION.
         ## Solve the internal energy equation for this field.
         ## Requires pressure and velocity fields to be present.
         ## Uses a nonconservative time discretisation.
         element equation {
            attribute name { "InternalEnergy" },
            (
               ## Select density to use in the Internal Energy Equation
               ## Use the MaterialDensity - useful for multimaterial simulations
               ## Clearly this requires a MaterialDensity field to be present
               ## Whatever field is selected must be present.
               element density {
                  attribute name { "MaterialDensity" }
               }|
               ## Select density to use in the Internal Energy Equation
               ## Use the bulk Density
               ## Clearly this requires a Density field to be present
               ## Whatever field is selected must be present.
               element density {
                  attribute name { "Density" }
               }|
               ## Select density to use in the Internal Energy Equation
               ## Whatever field is selected must be present.
               element density {
                  attribute name { string }
               }
            )
         }|
         ## Option to solve for electrical potential from
         ## electrokinetic, electrochemical or electrothermal sources 
         element equation { 
            attribute name { "ElectricalPotential" }
         }
      )
   )

forcing =
  (
    ## Add forcing from ocean data
    ## If you enable this you MUST enable the /geometry/ocean_boundaries option too
    element ocean_forcing{
        ## The netCDF data file downloaded from ERA-40 reanalysis
        element input_file {
           attribute file_name {xsd:string} 
        },
        element mesh_choice {
            velocity_mesh_choice
        },
        element surface_stress {
            empty
        }?,
        element temperature_flux {
            empty
        }?,
        element salinity_flux {
            empty
        }?,
        element solar_radiation {
            empty
        }?,
        ## Adding a latitude and longitude here (specified as two real numbers)
        ## will obtain data from the forcing file at that location. The
        ## mesh is not translated nor is the mesh put on the sphere, instead the
        ## specified lat/long is translated into cartesian coordinates and this is simply
        ## added to the surface mesh node coordinates when fluxes are calculated.
        element position {
            real_vector,
            ## Turning on this option will cause all nodes on the surface mesh to
            ## experience the same forcing, regardless of position. Only really
            ## useful for psuedo-1D simulations.
            element single_location {
                empty
            }?
        }?,
        ## Check this option to use an external data set for the t(0)
        ## and in/out boundary conditions
        element external_data_boundary_conditions {
            ## Path of the file containing the external data set
            element input_file {
                attribute file_name {xsd:string} 
            }
        }?,
        ## Ouput some extra diagnostic fields for the momentum, temperature and salinity fluxes
        element output_fluxes_diagnostics {
            element vector_field {
                attribute rank { "1" },
                attribute name { "MomentumFlux" },
                (
                    element diagnostic {
                        internal_algorithm,
                        velocity_mesh_choice,
                        diagnostic_scalar_field
                    }|
                    element aliased {
                        generic_aliased_field
                    }
                )
            }?, 
            element scalar_field {
                attribute rank { "0" },
                attribute name { "HeatFlux" },
                (
                    element diagnostic {
                        internal_algorithm,
                        velocity_mesh_choice,
                        diagnostic_scalar_field
                    }|
                    element aliased {
                        generic_aliased_field
                    }
                )
            }?,            
            element scalar_field {
                attribute rank { "0" },
                attribute name { "SalinityFlux" },
                (
                    element diagnostic {
                        internal_algorithm,
                        velocity_mesh_choice,
                        diagnostic_scalar_field
                    }|
                    element aliased {
                        generic_aliased_field
                    }
                )
            }?,
            element scalar_field {
                attribute rank { "0" },
                attribute name { "PhotosyntheticRadiationDownward" },
                (
                    element diagnostic {
                        internal_algorithm,
                        velocity_mesh_choice,
                        diagnostic_scalar_field
                    }|
                    element aliased {
                        generic_aliased_field
                    }
                )
            }?
        }?
    }
  )

biology =
   (
      ## Model of biological processes in the ocean.
      element ocean_biology{
         ## A simple model of phytoplankton, zooplankton, general nutrient and detritus. 
         element pznd {
            (
               ## Python code specifying the source and sink relationships 
               ## between the biological tracers. This is usually achieved by 
               ## importing fluidity.ocean_biology and calling a scheme from there. 
               element source_and_sink_algorithm {
                  python_code
               }|
               ## Do not calculate sources and sinks. 
               ## This option is generally only useful for testing. 
               element disable_sources_and_sinks {
                  empty
               }
             ),
#            ## Phytoplankton
#            element scalar_field {
#               attribute rank { "0" },
#               attribute name { "Phytoplankton" },
#               (
#                  element prognostic {
#                     velocity_mesh_choice,
#                     prognostic_scalar_field
#                  }|
#                  element prescribed {
#                     velocity_mesh_choice,
#                     prescribed_scalar_field
#                  }
#               )
#            },
#            ## Zooplankton
#            element scalar_field {
#               attribute rank { "0" },
#               attribute name { "Zooplankton" },
#               (
#                  element prognostic {
#                     velocity_mesh_choice,
#                     prognostic_scalar_field
#                  }|
#                  element prescribed {
#                     velocity_mesh_choice,
#                     prescribed_scalar_field
#                  }
#               )
#            },
#            ## Nutrient
#            element scalar_field {
#               attribute rank { "0" },
#               attribute name { "Nutrient" },
#               (
#                  element prognostic {
#                     velocity_mesh_choice,
#                     prognostic_scalar_field
#                  }|
#                  element prescribed {
#                     velocity_mesh_choice,
#                     prescribed_scalar_field
#                  }
#               )
#            },
#            ## Detritus
#            element scalar_field {
#               attribute rank { "0" },
#               attribute name { "Detritus" },
#               (
#                  element prognostic {
#                     velocity_mesh_choice,
#                     prognostic_scalar_field
#                  }|
#                  element prescribed {
#                     velocity_mesh_choice,
#                     prescribed_scalar_field
#                  }
#               )
#            },
            ## Photosynthetically Active Radiation (PAR)
            element scalar_field {
               attribute rank { "0" },
               attribute name { "PhotosyntheticRadiation" },
               (
                  element prognostic {
                     velocity_mesh_choice,
                     prognostic_photosynthetic_radiation
                  }|
                  element prescribed {
                     velocity_mesh_choice,
                     prescribed_scalar_field
                  }
               )
            }
         }
      }
   )


prognostic_photosynthetic_radiation =
   (
      ## PAR equation.
      element equation { 
         attribute name { "PhotosyntheticRadiation" }
      },
      ## Spatial discretisation options
      element spatial_discretisation {
         (
            ## Discontinuous galerkin formulation. You can also use this
            ## formulation with a continuous field in which case a simple
            ## galerkin formulation will result. 
            element discontinuous_galerkin {
               empty
            }
         )
      },
      (
         ## Solver
         element solver {
            linear_solver_options_asym
         }
      ),
      # Alas, no initial_condition either, so we'd better not checkpoint it...
      ## Disables checkpointing of this field
      element exclude_from_checkpointing {
        comment
      },
      ## Coefficients of absorption of photosynthetically active
      ## radiation for water and phytoplankton.
      element absorption_coefficients {
         ## Photosynthetically active radiation absorption coefficient for water.
         element water {
            real
         },
         ## Photosynthetically active radiation absorption coefficient for water.
         element phytoplankton {
            real
         }
      },
      ## Boundary conditions
      element boundary_conditions {
         attribute replaces { "boundary, TTPER1 TTPER2 TTPERI" },
         attribute name { string },
         ## Surface id:
         element surface_ids {
            integer_vector
         },
         ## Type
         (
            element type {
               attribute name { "dirichlet" },
               ## Apply the dirichlet bc weakly.  Only available with
               ## discontinuous_galerkin and control_volume
               ## spatial_discretisations.
               ##
               ## If not selected boundary conditions are applied strongly.
               element apply_weakly {
                 empty
               },
               input_choice_real
            }|
            element type {
               attribute name { "neumann" },
               input_choice_real
            }|
            element type {
               attribute name { "robin" },
               element order_zero_coefficient {
                  input_choice_real
               },
               element order_one_coefficient {
                  input_choice_real
               }
            }
         )
      }?,
      prognostic_scalar_output_options,
      prognostic_scalar_stat_options,
      scalar_convergence_options,
      prognostic_detector_options,
      scalar_steady_state_options,
      adaptivity_options_scalar_field,
      ## Set the priority of this field
      ## This determines the order in which scalar_fields are solved for:
      ##  - higher numbers have the highest priority
      ##  - lower numbers (including negative) have the lowest priority
      ##  - default if not set is 0
      element priority {
         integer
      }?
   )

recalculation_options =
   (
      ## Prevent this field from being recalculated at every timestep.
      ## This is cheaper especially if you are enforcing discrete properties on the field.
      element do_not_recalculate {
        empty
      }
   )

discrete_properties_algorithm_scalar =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        ## Update this field using the lagrangian multiplier
        ## calculated in the solenoidal projection of a
        ## scalar field.
        ##
        ## Note this field must be specified as the update field
        ## underneath that vector field too.
        ##
        ## Note also this only really makes sense for coupled
        ## fields like velocity and pressure.
        element solenoidal_lagrange_update {
          empty
        }?
      }
   )

discrete_properties_algorithm_vector =
   (
      ## Select discrete properties to enforce on the field
      ## either after being prescribed or interpolated
      element enforce_discrete_properties {
        solenoidal_options?
      }
   )

solenoidal_options =
    ## Constrained divergence-free projection.
    ## This adds an additional constraint that ensures that the field
    ## is solenoidal, i.e. divergence-free.
    ## This is equivalent in cost to a pressure solve.
    ## This is expensive, and thus best left until
    ## needed.
    ##
    ## Note well: this only makes sense for nondivergent
    ## vector fields, such as incompressible velocity!
    element solenoidal {
      ## Options for the mass matrix of the field being interpolated
      element interpolated_field {
        (
          element continuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            ##
            ## Required when using interpolating continuous fields
            element lump_mass_matrix {
              ## Lump on the submesh.
              ## This only works for simplex meshes and is only
              ## strictly valid on 2d meshes.
              element use_submesh {
                empty
              }?
            }
          }|
          element discontinuous {
            ## Lump the mass matrix for the assembly of the projection matrix
            ## (not for the initial galerkin projection)
            element lump_mass_matrix {
              empty
            }?
          }
        )
      },
      ## Options for the lagrange multiplier
      ##
      ## Must be on a continuous mesh!
      element lagrange_multiplier {
        pressure_mesh_choice,
        element spatial_discretisation {
          (
            element continuous_galerkin {
              ## Remove the stabilisation term from the projection operator.
              ##
              ## Automatic when not using P1P1.
              element remove_stabilisation_term {
                empty
              }?,
              ## Integrate the divergence operator by parts.
              ##
              ## Automatic when projecting a discontinuous field
              element integrate_divergence_by_parts {
                empty
              }?
            }|
            element control_volumes {
              empty
            }
          )
        },
        element reference_node {
          integer
        }?,
        (
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { "Pressure" },
            empty
          }|
          ## Update a scalar field using the lagrange multiplier from
          ## the divergence free projection of this field.  The selected
          ## scalar field must have solenoidal selected in its interpolation
          ## options too and it must be on the same mesh as used for the
          ## solenoidal projection above.
          ##
          ## Note well: this only really makes sense for scalar fields linked to nondivergent
          ## vector fields, such as pressure to incompressible velocity!                  
          element update_scalar_field {
            attribute name { string },
            empty
          }
        )?,
        ## Solver options for the linear solve.
        ## This method requires the inversion of a projection matrix.
        element solver {
          linear_solver_options_sym
        }
      }
    }

represcribe_before_interpolation =
    ## Represcribe the field before interpolation.
    ##
    ## This means the interpolation will not be conservative from the previous mesh so be careful what you're trying to achieve!
    element represcribe_before_interpolation {
      empty
    } 
