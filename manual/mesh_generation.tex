\chapter{Mesh generation}\label{chap:meshes}
\index{mesh!generation}
\index{grid|see{mesh}}

This chapter describes how to create a mesh for your \fluidity simulation. There
are many tools available, both free and commercial, that are capable to generating
unstrucutred meshes that are stuiable for use with \fluidity. Here, we restrict ourselves
to the mesh generation capabilities built into \fluidity and the associated script and
tools, mentioning only briefly some of the more common tools also available.

\section{The triangle format}\label{sect:triangle_format}
\index{mesh!file formats}

The main input file format for \fluidity meshes is the \emph{triangle} format.
The triangle format is a ASCII file format originally designed for 2D
triangle meshes, but it can be easily extended to different dimensions and
more complex geometries.  \fluidity\ supports an version of the triangle format
which supports 1D, 2D and 3D meshes.  Following table shows the supported
combinations of element dimension and geometry.

\begin{tabular}{ l l l }
\textbf{Dimension} & \textbf{Geometry} & \textbf{Number of vertices per element} \\ \hline
1D & Line & 2\\ 
2D & Triangles &  3 \\ 
2D & Quadrilateral\footnote{Limitation: at the moment, the grid must be rectangular} & 4 \\
3D & Tetrahedra & 4 \\ 
3D & Hexahedra\footnote{Limitation: at the moment, the grid must be cuboidal} & 8 \\
\end{tabular}

A complete triangle mesh consists of three files: one file defining the
nodes of the mesh, one file describing the elements (for example triangles
in 2D) and one file defining the boundary parts of the mesh.

The triangle file format is very simple. Since the data is stored in ASCII,
every text editor can be used to edit the files.  Lines starting with \# will
be interpreted as a comment by \fluidity.  The filename should end with
either .node, .ele, .bound, .edge or .face.  The structure of these files
will now be explained:

\begin{description}
\item[.node file]
This file holds the coordinates of the nodes. The file structure is:

First line
\begin{lstlisting}: 
<total number of vertices> <dimension (must be 1,2 or 3)> 0 0
\end{lstlisting}
Remaining lines
\begin{lstlisting}
<vertex number> <x> [<y> <z>]
\end{lstlisting} 
where x, y and z are the coordinates.

Vertices must be numbered consecutively, starting from one. 

\item[.ele file] Saves the elements of the mesh. The file structure is:
\index{region ID}

First line:
\begin{lstlisting}
 <total number of elements> <nodes per element>  1
\end{lstlisting}
Remaining lines:
\begin{lstlisting} 
<element number> <node> <node> <node> ... <region id>
\end{lstlisting}  
The elements must be numbered consecutively, starting from one. Nodes are
indices into the corresponding .node file. For example in case of describing
a 2D triangle mesh, the first three nodes are the corner vertices. The
region ID can be used by \fluidity\ to set conditions on different parts of
the mesh, see chapter \ref{sect:region_ids}.

\item[.bound file] This file is only generated for one-dimensional meshes.
  It records the boundary points and assigns surface IDs to them. The file
  structure is:\index{surface ID}

First line:
\begin{lstlisting}
 <total number of boundary points> 1
\end{lstlisting}
Remaining lines:
\begin{lstlisting} 
<boundary point number> <node> <surface id>
\end{lstlisting}  
The boundary points must be numbered consecutively, starting from one. Nodes
are indices into the corresponding .node file. The surface ID is used by
\fluidity\ to specify parts of the surface where different boundary
conditions will be applied, see section \ref{sect:surface_ids}.

\item[.edge file] This file is only generated for two-dimensional meshes.
  It records the edges and assigns surface IDs to part of the mesh surface.
  The file structure is:

First line:
\begin{lstlisting}
 <total number of edges> 1
\end{lstlisting}
Remaining lines:
\begin{lstlisting} 
<edge number> <node> <node> ... <surface id>
\end{lstlisting}  
The edges must be numbered consecutively, starting from one. Nodes are
indices into the corresponding .node file. The surface ID is used by
\fluidity\ to specify parts of the surface where different boundary
conditions will be applied, see section \ref{sect:surface_ids}.


\item[.face file] This file is only generated for three-dimensional meshes.
  It records the faces and assigns surface IDs to part of the mesh surface. The
  file structure is:

First line:
\begin{lstlisting}
 <total number of faces> 1
\end{lstlisting}
Remaining lines:
\begin{lstlisting} 
<face number> <node> <node> <node> ... <surface id>
\end{lstlisting}  
The faces must be numbered consecutively, starting from one. Nodes are
indices into the corresponding .node file. The surface ID is used by
\fluidity\ to specify parts of the surface where different boundary
conditions will be applied, see section \ref{sect:surface_ids}.
\end{description}

To clarify the file format the, a simple 1D example is shown: 
The following .node file defines 6 equidistant nodes from 0.0 to 5.0
\begin{lstlisting}
# example.node
6 1 0 0
1 0.0
2 1.0
3 2.0
4 3.0
5 4.0
6 5.0
\end{lstlisting}
The .ele file connects these nodes to 5 lines. Two regions will be defined with the IDs 1 and 2.
\begin{lstlisting}
# example.ele
5 2 1
1 1 2 1
2 2 3 1
3 3 4 1
4 4 5 2
5 5 6 2
\end{lstlisting}
Finally, the .bound file tags the very left and very right nodes as boundary
points an assigns the surface IDs 1 and 2 to them.
\begin{lstlisting}
# example.bound
2 1
1 1 1
2 6 2
\end{lstlisting}

\subsection{Surface IDs}\label{sect:surface_ids}
\index{surface ID}
Numbers can be assigned to label particular surfaces in order to set boundary conditions or other parameters. This number can then be used to specify which surface a particular boundary condition should be applied to in ICOM.

\subsection{Region IDs}\label{sect:region_ids}
\index{region ID}
These are similar to surface IDs. In general, any region (a line, surface or volume) can be labelled.

\section{Mesh types}
\subsection{Extruded meshes}
\label{sect:extruded_meshes}
\index{mesh!mesh types!extruded}

Given a 2D mesh file in triangle format, \fluidity can extrude this mesh to create a layered three dimensional mesh 
on which simulations can be performed. This is achieved by checking the extrude option under 
option{\ldots/from mesh}. After checking this option, the user must specify a bottom\_depth and 
a sizing\_function (which specifies the separation between layers). These distances can 
currently be entered as a constant, a generic\_function, a python function or by a NetCDF 
file (\website). Optionally, the user can then set the surface id given to the top and bottom surfaces. 

As well as extruding 2D meshes (where only the $x$ and $y$ coordinates are specified in the triangle file),
given a pseudo 2D mesh on a spherical shell, \fluidity can perform and extrusion in the radial 
direction. To perform such an extrusion simply enable the options as noted above and additionally 
check the \option{/geometry/spherical\_earth option}. With this option enabled fluidity will then perform the 
specified extrusion towards the center of the sphere.

\subsection{Periodic meshes}
\index{mesh!mesh types!periodic} 
\index{periodic domain} 
\label{mesh!mesh types!periodic} 
Periodic meshes are those that are ``virtually'' connected in one or more directions. To make a periodic
mesh you must first create a triangle file where the edges that are periodic
can be mapped exactly by a simple transformation. For example, if the mesh
is periodic in the X-direction, the two edges must have nodes at exactly the
same height on each side. This can be easily accomplished using the
\lstinline[language=Bash]+create_aligned_mesh+ script in the scripts folder.

Alternatively, if you require a more complex periodic mesh with some structure between the periodic 
boundaries you can create one using \lstinline[language=Bash]{gmsh}. This can be done by 
setting up the periodic boundaries by using extrude and then deleting the 'internal' mesh (\website)

\subsubsection{Running a parallel periodic extruded mesh}
\index{parallel!extruded mesh}
%\ref{mesh!extruded}
Running a periodic extruded mesh (section ??) in parallel, requires a number of steps to be taken in order to provide flredecomp (required to make the periodic mesh) with a 2D periodic mesh:

\begin{itemize}
\item Make the periodic 2D flml from the periodic 2plus1 flml
\begin{lstlisting}[language=bash]
 `\fluiditysourcepath'/scripts/make_periodic_2D_flml foo.flml
\end{lstlisting}
\item Periodise the new 2D flml
\begin{lstlisting}[language=bash]
 `\fluiditysourcepath'/periodise foo_2D.flml
\end{lstlisting}
\item Flredecomp the periodised 2D flml
\begin{lstlisting}[language=bash]
mpiexec -n 4 `\fluiditysourcepath'/bin/flredecomp \
    -i 1 -o 4 foo_2D_periodised foo_2D_periodised_flredecomp
\end{lstlisting}
\item Periodise the 2plus1 flml
\begin{lstlisting}[language=bash]
 `\fluiditysourcepath'/periodise foo.flml
\end{lstlisting}
\item Replace the mesh file in foo.flml with the one created in flml\_2D.flml
\item Run the parallel flml as before
\begin{lstlisting}[language=bash]
mpiexec -n [number of processors] \
   `\fluiditysourcepath'/bin/fluidity [options] foo_periodised.flml
\end{lstlisting}
\end{itemize}

\subsection{Setting field values}\label{Sect:setting_field_values}
\index{field!values}
\index{initial conditions!setting}
Field values must be specified by the user in two circumstances: the initial
value of most prognostic fields and the value throughout the simulation of
all prescribed fields. 

The initial value of prognostic fields is set with the
\option{\ldots/prognostic/initial\_condition} option while the value of
prescribed fields is set with the \option{\ldots/prescribed/value} option.

\section{Meshing tools}
\index{mesh!meshing tools}

There are a number of meshing tools in both the scripts and tools directories.

\subsection{interval}
This is a 1D mesh generator and is in the scripts directory. To use simply type:


\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/scripts/interval [options] left right name 
\end{lstlisting}

Where left and right define the range of the line. It has a number of user defined input options:

\begin{itemize}
\item - -dx = constant interval spacing
\item - -variable\_dx = interval spacing defined with a python function
\item - -region\_ids = python function defining the region id at each point
\item - -reverse = reverse order of mesh
\end{itemize}

\subsection{gmsh2triangle}
\index{mesh!meshing tools!gmsh2triangle}
Converting msh files to triangle format. The \lstinline[language=Bash]{gmsh2triangle} script in the scripts
directory converts msh files to triangle format, which is supported by \fluidity.
If you are generating a 2D mesh, the default behaviour is to still
output 3 dimensional positions. If you require 2d positions in this case (most
people will) then you need to supply the - -2d option to gmsh2triangle.

\lstinline[language=Bash]{gmsh2triangle} stores the entire gmsh mesh in memory before writing it out to
triangle file. For very large meshes this is likely to be impractical,
and instead the \lstinline[language=Bash]{gmsh2triangle\_large script}
should be used. This stores a minimal
amount of data in memory at any one time (it works ``out-of-core''), but
is slower for small files as it requires the input .msh file to be read multiple
times.

\lstinline[language=Bash]{gmsh2triangle\_large} is used via:

\begin{lstlisting}[language = Bash]
gmsh2triangle_large input
\end{lstlisting}

where \lstinline[language = Bash]*input* is the input .msh file.

The \lstinline[language = Bash]+--2d+ flag can be used to instruct gmsh2triangle\_large
to process a 2D input .msh file. Otherwise, 3D input is assumed.

\subsection{triangle2vtu}
\index{mesh!meshing tools!triangle2vtu}
This converts triangle format files in to vtu format. It is in the fluidity tools directory and is used with:

\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/tools/triangle2vtu foo
\end{lstlisting}

Where foo is the triangle file base name (\ie foo.node etc.)

\section{Decomposing meshes for parallel}
\label{decomp_meshes_parallel}
\index{parallel!mesh decomposition}

The first step in running a \fluidity\ set-up in parallel is to create the software
used to decompose the initial mesh into multiple parts. This can be made using:
\begin{lstlisting}[language=bash]
make fltools
\end{lstlisting}
inside your \fluidity\ folder. The following binaries will then be created in the bin/ directory (see section \ref{sect:fltools}).
%You can then decompose the initial mesh the following command
%\begin{lstlisting}[language=bash]
%fluidity path /bin/fldecomp -n [PARTS] [BASENAME]
%\end{lstlisting}

\subsection{fldecomp}
\index{mesh!meshing tools!fldecomp}
This function is used to decompose a mesh into multiple regions, one per process. In order to run fldecomp, if your mesh files have the base name foo and you want to decompose into four parts, type:
\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/bin/fldecomp -n 4 foo
\end{lstlisting}

This will create partition triangle meshes together with halo files. 

%In your fluidity directory type:
%\begin{lstlisting}[language = Bash]
%make fltools
%\end{lstlisting}
%Navigate back to the directory containing your mesh files. In order to run fldecomp, if your mesh files are called square.geo etc and you want to decompose into four parts, type:
%\begin{lstlisting}[language = Bash]
%fludity path /bin/fldecomp -n 4 square
%\end{lstlisting}

\subsection{flredecomp}
\index{mesh!meshing tools!flredecomp}
\label{mesh!meshing tools!flredecomp}
This is sililar to fldecomp but it runs in parallel. To use simply type, where the decomposed file has the
name foo\_flredecomp.flml:

\begin{lstlisting}[language=bash]
mpiexec -n 4 `\fluiditysourcepath'/bin/flredecomp \
    -i 1 -o 4 foo foo_flredecomp
\end{lstlisting}

Where:

\begin{lstlisting}[language=bash]
mpiexec -n [target number of processors] \
   `\fluiditysourcepath'/bin/flredecomp -i [input number of processors] \
        -o [target number of processors] [input flml] [output flml]
\end{lstlisting}

The output of running flredecomp is a series of mesh and vtu files as well as the new flml; in this case foo\_flredecomp.flml.

%\subsubsection{Decomposing a periodic mesh}
\subsection{periodise}
\index{mesh!meshing tools!periodise}
%\index{Zoltan}\index{parallel!periodic domains}
%Running a periodic mesh in parallel is relatively straight forward. To begin with, fluidity must be compiled with Zoltan. To check if the Zoltan libaries are installed type:

%\begin{lstlisting}[language=bash]
%dpkg -l libzoltan*
%\end{lstlisting}

%If the libaries are not present install them with:

%\begin{lstlisting}[language=bash]
%sudo apt-get install libzoltan-dev
%\end{lstlisting}

%Then configure fluidity with zoltan:

%\begin{lstlisting}[language=bash]
%./configure --with-zoltan
%\end{lstlisting}

To be able to run a periodic mesh in parallel you have to use two tools (these tools are built as part of the fltools build target (see section \ref{sect:fltools})):

\begin{itemize}
\item periodise
\item flredecomp (\ref{mesh!meshing tools!flredecomp})
\end{itemize}

The input to periodise is your flml (in this case foo.flml), which contains the mapping for the periodic boundary as described above. Run using the command:

\begin{lstlisting}[language=bash]
`\fluiditysourcepath'/bin/periodise foo.flml
\end{lstlisting}

The output is a new flml called  foo\_periodised.flml and the periodic meshes. Then run flredecomp (section \ref{mesh!meshing tools!flredecomp}) to decompose the mesh for the number of processors required. It is this flml that you use to run a periodic parallel mesh. Therefore, as previously:

\begin{lstlisting}[language=bash]
mpiexec -n [number of processors] \
   `\fluiditysourcepath'/bin/fluidity [options] foo_periodised_flredecomp.flml
\end{lstlisting}

\section{Pseudo-meshing}

The tool pseudo\_mesh enables the generation of a mesh of equal local resolution
to some prescribed input mesh. This is sometimes useful for the purposes of
interpolation comparison. pseudo\_mesh achieves this by computing an adaptivity
metric (see section \ref{sec:meshes_and_metrics}) derived from the input mesh
via a polar decomposition of the
elemental Jacobian \citep{micheletti2006}, and supplying this to the mesh adaptivity libraries
(see section \ref{sec:adaptive_remeshing_technology}).

pseudo\_mesh is not built by default as part of the \fluidity\ tools package. To
build the tool type:

\begin{lstlisting}[language = Bash]
cd tools
make ../bin/pseudo_mesh
\end{lstlisting}

pseudo\_mesh is used via:

\begin{lstlisting}[language = Bash]
pseudo_mesh [-thv] input_basename
\end{lstlisting}

where \lstinline[language = Bash]*input_basename* is the base name of an input
triangle file. If the \lstinline[language = Bash]*-t* flag is supplied then
then the metric used to form the output mesh is limited to target the element
count of the input mesh.

psuedo\_mesh is parallelised, and accepts the following flags:

\begin{center}
  \begin{tabular}{| l | l |}
    \hline
    Flag & Function \\
    \hline
    -h   & Display help \\
    -t   & Limit the metric used to form the output mesh to target the \\
         & element count of the input mesh \\
    -v   & Verbose mode \\
    \hline
  \end{tabular}
\end{center}

\section{Mesh verification}

The tool checkmesh can be used to form a number of verification tests on a mesh
in triangle mesh format. This tool is build as part of the fltools build target
(see section \ref{sect:fltools}), and is used via:

\begin{lstlisting}[language = Bash]
checkmesh input_basename
\end{lstlisting}

where \lstinline[language = Bash]*input_basename* is the base name of an input
triangle file. checkmesh tests for:

\begin{enumerate}
  \item Degenerate volume elements;
  \item Inverted tetrahedra;
  \item Degenerate surface elements;
  \item\label{item:mesh_tangling} Mesh tangling.
\end{enumerate}

Test \ref{item:mesh_tangling} is performed by testing for any mesh self-intersections
via mesh intersection (see section \ref{sec:supermeshing}).

checkmesh is parallelised. If running in parallel, it should be launched on a number
of processes equal to that in the mesh decomposition. In parallel checkmesh output
is written to checkmesh.log-\[process\] and checkmesh.err-\[process\] log files.

\begin{example}
\begin{lstlisting}[language = Bash]
Checking volume elements for tangling ...
 In intersection_finder
 In advancing_front_intersection_finder
 Exiting advancing_front_intersection_finder
 Exiting intersection_finder
Tangled volume element found: 
Element: 1
Coordinates:
  0.10000000000000000E+001  0.00000000000000000E+000
  0.11666666666700001E+001  0.00000000000000000E+000
  0.83867056794499995E+000  0.54463903501499999E+000
Numbering:
           1
          14
           2
\end{lstlisting}
\caption{checkmesh reporting a mesh tangling error.}
\end{example}

\section{Non-\fluidity\ tools}

In addition to the tools and capabilities of \fluidity, there are numerous
tools and softare packages available for mesh generation. Here, we describe 
two of the tools used by the group.

\subsection{Terreno}
\index{mesh!generation!Terreno}
\index{Terreno}

Terreno uses a 2D anisotropic mesh optimisation algorithm to explicitly optimise for 
element quality and bathymetric approximation while minimising the number of mesh
elements created. The shoreline used in the mesh generation process is the result 
of a polyline approximation algorithm that where the minimum length of the resulting 
edges is considered as well as the distance an edge is from a vertex on the original 
shoreline segment being approximated. The underlying philosophy is that meshing and 
approximation should be error driven and should minimise user intervention. The 
latter point is two pronged: usability is paramount and the user should not need 
to be an expert in mesh generation to generate high quality meshes for their ocean 
model; fundamentally there must be clearly defined objectives to the mesh generation 
process to ensure reproducibility of results. The result is an unstructured mesh, 
which may be anisotropic, which focuses resolution where it is required to optimally 
approximate the bathymetry of the domain. The criterion to judge the quality of the 
mesh is defined in terms of clearly defined objectives. An important feature of the 
approach is that it facilitates multi-objective mesh optimisation. This allows one to 
simultaneously optimise the approximation to other variables in addition to the 
bathymetry on the same mesh, such as back-scatter data from soundings, material 
properties or climatology data. 

\website.

\subsection{Gmsh}
\index{mesh!generation!gmsh}
\index{gmsh}

Gmsh is a 3D finite element grid generator with a build-in CAD engine and post-processor.
Its design goal is to provide a fast, light and user-friendly meshing tool with parametric
input and advanced visualization capabilities. Gmsh is built around four modules: geometry, 
mesh, solver and post-processing. The specification of any input to these modules is done
either interactively using the graphical user interface or in ASCII text files using Gmsh's
own scripting language. 

For more information see the Gmsh website: http://geuz.org/gmsh/ or the AMCG website.

