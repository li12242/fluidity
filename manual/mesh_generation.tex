\chapter{Mesh generation}\label{chap:meshes}
\index{mesh!generation}
\index{grid|see{mesh}}

This chapter describes how to create a mesh for your \fluidity\ simulation. There
are many tools available, both free and proprietary, that are capable of generating
unstructured meshes that are suitable for use with \fluidity. Here, we restrict ourselves
to the mesh generation capabilities built into \fluidity\ and the associated script and
tools, mentioning only briefly some of the more common tools also available.

\section{Mesh data}

A mesh describes the computational domain in which a simulation takes
place. Regardless of the mesh file format in use, the information conveyed
is essentially the same.

\subsection{Node location}

The locations of the element vertices are recorded. Usually, these have the
same dimension as the topological dimension of the mesh elements. \fluidity\
does not currently support configurations such as shells in which the node
location dimension differs from the element topology dimension.

\subsection{Element topology}

The mesh is composed of elements. In one dimension these will be intervals
with each interval joining two nodes. In two dimensions, triangles or
quadrilaterals are supported with the elements joining three or four nodes
respectively. In three dimensions, the elements can be tetrahedra or
hexahedra and will join four or eight nodes.

The element topology will store the indices of the nodes which make up
each of the elements in the mesh.

\subsection{Facets}

Facets form the surface of elements. In one dimension, the facets of an
element are its bounding nodes. In two dimensions, the facets are the edge
intervals while the facets of a three-dimensional tetrahedral element are
triangles and those of a hexahedral element are quadrilaterals. External
mesh formats tend to only supply facet topology information for facets on
the surface of each domain. For each facet specified, the node indices of
that facet will be given. These surface facets are used in combination with
surface IDs to specify the regions over which boundary conditions should be
applied.

\subsection{Surface IDs}\label{sect:surface_ids}
\index{surface ID}
Numbers can be assigned to label particular facets (boundary nodes, edges or
faces in 1, 2 or 3 dimensions respectively) in order to set
boundary conditions or other parameters. This number can then be used to
specify which surface a particular boundary condition should be applied to
in \fluidity. 

\subsection{Region IDs}\label{sect:region_ids}
\index{region ID} These are analogous to surface IDs, however they are
associated with elements rather than facets. Region IDs may be used in
\fluidity\ to specify different initial conditions or material properties to
different parts of the domain.



\section{The triangle format}\label{sect:triangle_format}
\index{mesh!file formats}

The main input file format for \fluidity\ meshes is the \emph{triangle} format.
The triangle format is a ASCII file format originally designed for 2D
triangle meshes, but it can be easily extended to different dimensions and
more complex geometries.  \fluidity\ supports an version of the triangle format
which supports 1D, 2D and 3D meshes.  Following table shows the supported
combinations of element dimension and geometry.

\begin{tabular}{ l l l }
\textbf{Dimension} & \textbf{Geometry} & \textbf{Number of vertices per element} \\ \hline
1D & Line & 2\\ 
2D & Triangles &  3 \\ 
2D & Quadrilateral\footnote{Limitation: at the moment, the domain must be rectangular} & 4 \\
3D & Tetrahedra & 4 \\ 
3D & Hexahedra\footnote{Limitation: at the moment, the domain must be a cuboid} & 8 \\
\end{tabular}

A complete triangle mesh consists of three files: one file defining the
nodes of the mesh, one file describing the elements (for example triangles
in 2D) and one file defining the boundary parts of the mesh.

The triangle file format is very simple. Since the data is stored in ASCII,
every text editor can be used to edit the files.  Lines starting with \# will
be interpreted as a comment by \fluidity.  The filename should end with
either .node, .ele, .bound, .edge or .face.  The structure of these files
will now be explained:

\begin{description}
\item[.node file]
This file holds the coordinates of the nodes. The file structure is:

First line
\begin{lstlisting}: 
<total number of vertices> <dimension (must be 1,2 or 3)> 0 0
\end{lstlisting}
Remaining lines
\begin{lstlisting}
<vertex number> <x> [<y> [<z>]]
\end{lstlisting} 
where x, y and z are the coordinates.

Vertices must be numbered consecutively, starting from one. 

\item[.ele file] Saves the elements of the mesh. The file structure is:
\index{region ID}

First line:
\begin{lstlisting}
 <total number of elements> <nodes per element>  1
\end{lstlisting}
Remaining lines:
\begin{lstlisting} 
<element number> <node> <node> <node> ... <region id>
\end{lstlisting}  
The elements must be numbered consecutively, starting from one. Nodes are
indices into the corresponding .node file. For example in case of describing
a 2D triangle mesh, the first three nodes are the corner vertices. The
region ID can be used by \fluidity\ to set conditions on different parts of
the mesh, see section \ref{sect:region_ids}.

\item[.bound file] This file is only generated for one-dimensional meshes.
  It records the boundary points and assigns surface IDs to them. The file
  structure is:\index{surface ID}

First line:
\begin{lstlisting}
 <total number of boundary points> 1
\end{lstlisting}
Remaining lines:
\begin{lstlisting} 
<boundary point number> <node> <surface id>
\end{lstlisting}  
The boundary points must be numbered consecutively, starting from one. Nodes
are indices into the corresponding .node file. The surface ID is used by
\fluidity\ to specify parts of the surface where different boundary
conditions will be applied, see section \ref{sect:surface_ids}.

\item[.edge file] This file is only generated for two-dimensional meshes.
  It records the edges and assigns surface IDs to part of the mesh surface.
  The file structure is:

First line:
\begin{lstlisting}
 <total number of edges> 1
\end{lstlisting}
Remaining lines:
\begin{lstlisting} 
<edge number> <node> <node> ... <surface id>
\end{lstlisting}  
The edges must be numbered consecutively, starting from one. Nodes are
indices into the corresponding .node file. The surface ID is used by
\fluidity\ to specify parts of the surface where different boundary
conditions will be applied, see section \ref{sect:surface_ids}.


\item[.face file] This file is only generated for three-dimensional meshes.
  It records the faces and assigns surface IDs to part of the mesh surface. The
  file structure is:

First line:
\begin{lstlisting}
 <total number of faces> 1
\end{lstlisting}
Remaining lines:
\begin{lstlisting} 
<face number> <node> <node> <node> ... <surface id>
\end{lstlisting}  
The faces must be numbered consecutively, starting from one. Nodes are
indices into the corresponding .node file. The surface ID is used by
\fluidity\ to specify parts of the surface where different boundary
conditions will be applied, see section \ref{sect:surface_ids}.
\end{description}

To clarify the file format the, a simple 1D example is shown: 
The following .node file defines 6 equidistant nodes from 0.0 to 5.0
\begin{lstlisting}
# example.node
6 1 0 0
1 0.0
2 1.0
3 2.0
4 3.0
5 4.0
6 5.0
\end{lstlisting}
The .ele file connects these nodes to 5 lines. Two regions will be defined with the IDs 1 and 2.
\begin{lstlisting}
# example.ele
5 2 1
1 1 2 1
2 2 3 1
3 3 4 1
4 4 5 2
5 5 6 2
\end{lstlisting}
Finally, the .bound file tags the very left and very right nodes as boundary
points an assigns the surface IDs 1 and 2 to them.
\begin{lstlisting}
# example.bound
2 1
1 1 1
2 6 2
\end{lstlisting}

\section{The Gmsh format}\label{sect:gmsh_format}


\fluidity\ also contains built-in support for the Gmsh format. Gmsh is a mesh
generator freely available on the World Wide Web
(\url{http://geuz.org/gmsh/}) and is included in
Linux distributions such as Ubuntu. 

Unlike triangle files, Gmsh meshes are contained within one file, which have
the extension \lstinline[language=bash]+.msh+. The file contents may
be either binary or ASCII.

\subsection{Using Gmsh files with \fluidity}\label{sect:using_gmsh}

\fluidity\ needs to be told to expect a Gmsh file. This is achieved by
setting the \onlypdf\linebreak\option{/geometry/mesh/from\_file/format}\ option.  \fluidity\
will now look for a file with the extension \lstinline[language=bash]+.msh+ when it runs.

For parallel simulations, you must use \lstinline[language=bash]+fldecomp+ to decompose a Gmsh
mesh into sub-meshes for each process. Here, only binary Gmsh files can be
used - see section \ref{mesh!meshing tools!fldecomp}\ for details.

\subsection{Gmsh file format}\label{sect:gmsh_file_format}

This section briefly describes the Gmsh format. For more
information, please read the official Gmsh documentation
(\url{http://geuz.org/gmsh/doc/texinfo/gmsh.pdf}).
Typically, Gmsh files used in \fluidity\ contain three parts: a header, a
section for nodes, and one for elements. These are explained in more detail
below.



\subsubsection*{The header}\label{sect:gmsh_header_section}
This contains Gmsh file version information, and indicates whether the main data is in ASCII or binary format. This will typically look like:
\begin{lstlisting}
$MeshFormat
2.1 0 8
[Extra data here in binary mode]
$EndMeshFormat
\end{lstlisting}

From the listing above we can tell that:
\begin{itemize}
\item the Gmsh format version is 2.1
\item it is in ASCII, as indicated by the 0 (1=binary)
\item the byte size of double precision is 8
\end{itemize}
In addition, in binary mode the integer 1 is written as 4 raw bytes, to check that the endianness of the Gmsh file and the system are the same (\textit{you will rarely have to worry about this})



\subsubsection*{The nodes section}\label{sect:gmsh_nodes_section}

The next section contains node data, viz:
\begin{lstlisting}
$Nodes
number_of_nodes
[node data]
$EndNodes
\end{lstlisting}

The \lstinline+[node data]+ part contains the listing of nodes, with ID,
followed by $x$, $y$, and $z$ coordinates. This part
will be in binary when binary mode has been selected. Note that even with 2D
problems, there will be a zeroed \textit{z} coordinate.



\subsubsection*{The elements section}\label{sect:gmsh_elements_section}

The elements section contains information on both facets and regular
elements. It also varies between binary and ASCII formats. The ASCII version
is:

\begin{lstlisting}
$Elements
element1_id element_type number_of_tags tag_list node_number_list
element2_id ...
...
...
$EndElements
\end{lstlisting}
\textit{Tags} are integer properties ascribed to the element. In \fluidity,
we are only concerned with the first one, the physical ID. This can mean one
of two things:

\begin{itemize}
\item A region ID - in the case of elements
\item A surface ID - in the case of facets
\end{itemize}

Since Gmsh doesn't explicitly label facets or regular elements as such,
internally \fluidity\ works this out from type: eg, if there a mesh consists
of tetrahedra and triangles, then triangles must be the facets.

\section{Mesh types}
\subsection{Extruded meshes}
\label{sect:extruded_meshes}
\index{mesh!extruded}

Given a 1D or 2D mesh file in triangle format, \fluidity\ can extrude this
mesh to create a layered 2D or 3D mesh, on which simulations can be
performed. The extrusion is specified in the .flml file and is documented in
section \ref{Sect:extruded}.

\subsection{Periodic meshes}
\index{mesh!periodic} 
\index{periodic domain} 
\label{mesh!mesh types!periodic} 
Periodic meshes are those that are ``virtually'' connected in one or more directions. To make a periodic
mesh you must first create a triangle file where the edges that are periodic
can be mapped exactly by a simple transformation. For example, if the mesh
is periodic in the $x$-direction, the two edges must have nodes at exactly the
same height on each side. This can be easily accomplished using the
\lstinline[language=Bash]+create_aligned_mesh+ script in the scripts folder.

Alternatively, if you require a more complex periodic mesh with some structure between the periodic 
boundaries you can create one using \lstinline[language=Bash]{gmsh}. This can be achieved by 
setting up the periodic boundaries by using extrude and then deleting the 'internal' mesh.

The use of periodic domains requires additional configuration options. See
section \ref{Sect:periodic}.

\section{Meshing tools}
\index{mesh!meshing tools}

There are a number of meshing tools in both the scripts and tools directories.

\subsection{interval}
\index{mesh!meshing tools!interval}
This is a 1D mesh generator and is in the scripts directory. To use simply type:


\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/scripts/interval [options] left right name 
\end{lstlisting}

where left and right define the range of the line. It has a number of user defined input options:


\begin{center}
  \begin{tabular}{lp{.6\textwidth}}
    \hline
    \lstinline+--dx+ & constant interval spacing\\
    \lstinline+--variable_dx+ & interval spacing defined with a python function\\
    \lstinline+--region_ids+ & python function defining the region ID at each point\\
    \lstinline+--reverse+ & reverse order of mesh\\
    \hline
  \end{tabular}
\end{center}



\subsection{gmsh2triangle}
\index{mesh!meshing tools!gmsh2triangle}

This script converts Gmsh mesh files into triangle format. Its use is now
deprecated in favour of directly reading Gmsh files into \fluidity. See
section \ref{sect:gmsh_format}.

\lstinline[language=Bash]{gmsh2triangle} stores the entire gmsh mesh in memory before writing it out to
triangle file. For very large meshes this is likely to be impractical,
and instead the \lstinline[language=Bash]{gmsh2triangle_large} script
should be used. This stores a minimal
amount of data in memory at any one time (it works ``out-of-core''), but
is slower for small files as it requires the input .msh file to be read multiple
times.

\lstinline[language=Bash]{gmsh2triangle[_large]} is used via:

\begin{lstlisting}[language = Bash]
gmsh2triangle[_large] input
\end{lstlisting}

where \lstinline[language = Bash]*input* is the input .msh file.

The \lstinline[language = Bash]+--2d+ flag can be used to instruct \lstinline+gmsh2triangle[_large]+
to process a 2D input .msh file. Otherwise, 3D input is assumed.

\subsection{triangle2vtu}
\index{mesh!meshing tools!triangle2vtu}
This converts triangle format files in to vtu format. It is in the fluidity tools directory and is used with:

\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/tools/triangle2vtu foo
\end{lstlisting}

Where \lstinline+foo+ is the triangle file base name (\lstinline+foo.node+ etc.)

\section{Decomposing meshes for parallel}
\label{decomp_meshes_parallel}
\index{parallel!mesh decomposition}

The first step in running a \fluidity\ set-up in parallel is to create the software
used to decompose the initial mesh into multiple parts. This can be made using:
\begin{lstlisting}[language=bash]
make fltools
\end{lstlisting}
inside your \fluidity\ folder. The following binaries will then be created in the \lstinline+bin/+ directory (see section \ref{sect:fltools}).
%You can then decompose the initial mesh the following command
%\begin{lstlisting}[language=bash]
%fluidity path /bin/fldecomp -n [PARTS] [BASENAME]
%\end{lstlisting}



\subsection{fldecomp}
\index{mesh!meshing tools!fldecomp}
\label{mesh!meshing tools!fldecomp}
This program is used to decompose a mesh into multiple regions, one per
process. In order to run fldecomp, if your mesh files have the base name
\lstinline{foo}\ and you want to decompose into four parts, type:
\begin{lstlisting}[language = Bash]
`\fluiditysourcepath'/bin/fldecomp -n 4 -m mesh_format mesh_file
\end{lstlisting}

Where:
\begin{center}
  \begin{tabular}{lp{.8\textwidth}}
    \lstinline+mesh_file+ & is the base name of your mesh file(s). For
    example, \lstinline+foo+ for \lstinline+foo.msh+ with Gmsh format, or
    \lstinline+foo.face/node/ele+ with triangle format.\\
    \lstinline+mesh_format+ & is the format of the mesh file you wish to
    decompose. It can take two values: \lstinline+gmsh+ or
    \lstinline+triangle+. If you omit the \lstinline+-m+ option,
    \lstinline+fldecomp+ will default to \lstinline+triangle+.
  \end{tabular}
\end{center}

For performance reasons, \lstinline[language=Bash]{fldecomp} supports only
binary Gmsh files. These are generated by passing the \lstinline{-bin}\
argument to Gmsh, for example:

\begin{lstlisting}[language=bash]
gmsh -3 -bin project.geo
\end{lstlisting}

This creates a 3D binary Gmsh mesh called \lstinline{project.msh} from the geometry file.



\subsection{flredecomp}
\index{mesh!meshing tools!flredecomp}
\label{mesh!meshing tools!flredecomp}
This is similar to fldecomp but runs in parallel. It is invoked as follows:
\begin{lstlisting}[language=bash]
mpiexec -n [target number of processors] \
   `\fluiditysourcepath'/bin/flredecomp \
        -i [input number of processors] \
        -o [target number of processors] [input flml] [output flml]
\end{lstlisting}

For example, to decompose the serial file \lstinline+foo.flml+
into four parts, type:

\begin{lstlisting}[language=bash]
mpiexec -n 4 `\fluiditysourcepath'/bin/flredecomp \
    -i 1 -o 4 foo foo_flredecomp
\end{lstlisting}

The output of running flredecomp is a series of mesh and vtu files as well
as the new flml; in this case \lstinline+foo_flredecomp.flml+.

%\subsubsection{Decomposing a periodic mesh}
\subsection{periodise}
\index{mesh!meshing tools!periodise}

To be able to run \fluidity\ on a periodic mesh in parallel you have to use
two tools (these tools are built as part of the fltools build target (see
section \ref{sect:fltools})):

\begin{itemize}
\item periodise
\item flredecomp (\ref{mesh!meshing tools!flredecomp})
\end{itemize}

The input to periodise is your flml (in this case
\lstinline{foo.flml}). This flml file should already contain the mapping for
the periodic boundary as described in section
\ref{Sect:periodic}. Periodise is run with the command:

\begin{lstlisting}[language=bash]
`\fluiditysourcepath'/bin/periodise foo.flml
\end{lstlisting}

The output is a new flml called \lstinline+foo_periodised.flml+ and the
periodic meshes. Next run flredecomp (section \ref{mesh!meshing
  tools!flredecomp}) to decompose the mesh for the number of processors
required. The flml output by flredecomp is then used to execute the actual simulation:

\begin{lstlisting}[language=bash]
mpiexec -n [number of processors] \
   `\fluiditysourcepath'/bin/fluidity [options] \
   foo_periodised_flredecomp.flml
\end{lstlisting}

\subsection{Parallel periodic extruded meshes}
\index{parallel!extruded mesh}
%\ref{mesh!extruded}
When using a periodic extruded mesh (section \ref{sect:extrudedperiodic}) in parallel, a number
of steps are required:

\begin{itemize}
\item Make the periodic 2D flml from the periodic 2plus1 flml
\begin{lstlisting}[language=bash]
 `\fluiditysourcepath'/scripts/make_periodic_2D_flml foo.flml
\end{lstlisting}
\item Periodise the new 2D flml
\begin{lstlisting}[language=bash]
 `\fluiditysourcepath'/periodise foo_2D.flml
\end{lstlisting}
\item Flredecomp the periodised 2D flml
\begin{lstlisting}[language=bash]
mpiexec -n 4 `\fluiditysourcepath'/bin/flredecomp \
    -i 1 -o 4 foo_2D_periodised foo_2D_periodised_flredecomp
\end{lstlisting}
\item Periodise the 2plus1 flml
\begin{lstlisting}[language=bash]
 `\fluiditysourcepath'/periodise foo.flml
\end{lstlisting}
\item Replace the mesh file in foo.flml with the one created in flml\_2D.flml
\item Run the parallel flml as in the usual manner.
\begin{lstlisting}[language=bash]
mpiexec -n [number of processors] \
   `\fluiditysourcepath'/bin/fluidity [options] foo_periodised.flml
\end{lstlisting}
\end{itemize}


\section{Pseudo-meshing}

The tool pseudo\_mesh enables the generation of a mesh of equal local resolution
to some prescribed input mesh. This is sometimes useful for the purposes of
interpolation comparison. pseudo\_mesh achieves this by computing an adaptivity
metric (see section \ref{sec:meshes_and_metrics}) derived from the input mesh
via a polar decomposition of the
elemental Jacobian \citep{micheletti2006}, and supplying this to the mesh adaptivity libraries
(see section \ref{sec:adaptive_remeshing_technology}).

pseudo\_mesh is not built by default as part of the \fluidity\ tools package. To
build the tool type:

\begin{lstlisting}[language = Bash]
cd tools
make ../bin/pseudo_mesh
\end{lstlisting}

pseudo\_mesh is invoked as:

\begin{lstlisting}[language = Bash]
pseudo_mesh [-thv] input_basename
\end{lstlisting}

where \lstinline[language = Bash]*input_basename* is the base name of an input
triangle file. If the \lstinline[language = Bash]*-t* flag is supplied then
then the metric used to form the output mesh is limited to target the element
count of the input mesh.

psuedo\_mesh is parallelised, and accepts the following options:

\begin{center}
  \begin{tabular}{lp{.6\textwidth}}
    \hline
 %   Flag & Function \\
 %   \hline
    \lstinline+-h+   & Display help \\
    \lstinline+-t+   & Limit the metric used to form the output mesh to
    target the element count of the input mesh \\
    \lstinline+-v+   & Verbose mode \\
    \hline
  \end{tabular}
\end{center}

\section{Mesh verification}
\index{mesh!verification}

The tool checkmesh can be used to form a number of verification tests on a mesh
in triangle mesh format. This tool is build as part of the fltools build target
(see section \ref{sect:fltools}), and is invoked as:

\begin{lstlisting}[language = Bash]
checkmesh input_basename
\end{lstlisting}

where \lstinline[language = Bash]*input_basename* is the base name of an input
triangle file. checkmesh tests for:

\begin{enumerate}
  \item Degenerate volume elements;
  \item Inverted tetrahedra;
  \item Degenerate surface elements;
  \item\label{item:mesh_tangling} Mesh tangling.
\end{enumerate}

% Test \ref{item:mesh_tangling} is performed by testing for any mesh self-intersections
% via mesh intersection (see section \ref{sec:supermeshing}).

checkmesh is parallelised. If running in parallel, it should be launched on
a number of processes equal to that in the mesh decomposition. In parallel
checkmesh output is written to \onlypdf\linebreak \lstinline+checkmesh.log-[process]+
and \lstinline+checkmesh.err-[process]+ log files.

\begin{example}
\begin{lstlisting}[language = Bash,keywordstyle=]
Checking volume elements for tangling ...
 In intersection_finder
 In advancing_front_intersection_finder
 Exiting advancing_front_intersection_finder
 Exiting intersection_finder
Tangled volume element found: 
Element: 1
Coordinates:
  0.10000000000000000E+001  0.00000000000000000E+000
  0.11666666666700001E+001  0.00000000000000000E+000
  0.83867056794499995E+000  0.54463903501499999E+000
Numbering:
           1
          14
           2
\end{lstlisting}
\caption{checkmesh reporting a mesh tangling error.}
\end{example}

\section{Non-\fluidity\ tools}

In addition to the tools and capabilities of \fluidity, there are numerous
tools and software packages available for mesh generation. Here, we describe 
two of the tools commonly used.

\subsection{Terreno}
\index{mesh!meshing tools!Terreno}
\index{Terreno}

Terreno uses a 2D anisotropic mesh optimisation algorithm to explicitly optimise for 
element quality and bathymetric approximation while minimising the number of mesh
elements created. The shoreline used in the mesh generation process is the result 
of a polyline approximation algorithm that where the minimum length of the resulting 
edges is considered as well as the distance an edge is from a vertex on the original 
shoreline segment being approximated. The underlying philosophy is that meshing and 
approximation should be error driven and should minimise user intervention. The 
latter point is two pronged: usability is paramount and the user should not need 
to be an expert in mesh generation to generate high quality meshes for their ocean 
model; fundamentally there must be clearly defined objectives to the mesh generation 
process to ensure reproducibility of results. The result is an unstructured mesh, 
which may be anisotropic, which focuses resolution where it is required to optimally 
approximate the bathymetry of the domain. The criterion to judge the quality of the 
mesh is defined in terms of clearly defined objectives. An important feature of the 
approach is that it facilitates multi-objective mesh optimisation. This allows one to 
simultaneously optimise the approximation to other variables in addition to the 
bathymetry on the same mesh, such as back-scatter data from soundings, material 
properties or climatology data. 

See the \href{http://amcg.ese.ic.ac.uk/terreno}{Terreno website}\ for more information.

\subsection{Gmsh}
\index{mesh!meshing tools!gmsh}
\index{gmsh}

Gmsh is a 3D finite element mesh generator with a build-in CAD engine and post-processor.
Its design goal is to provide a fast, light and user-friendly meshing tool with parametric
input and advanced visualisation capabilities. Gmsh is built around four modules: geometry, 
mesh, solver and post-processing. The specification of any input to these modules is done
either interactively using the graphical user interface or in ASCII text files using Gmsh's
own scripting language. 

For more information see the \href{http://geuz.org/gmsh/}{Gmsh website}\ or the \href{http://amcg.ese.ic.ac.uk}{AMCG
website}. An online manual is available at \href{http://geuz.org/gmsh/doc/texinfo/gmsh.html}{geuz.org/gmsh/doc/texinfo/gmsh.html}.

\subsection{Importing contours from bathymetric data into Gmsh}
\index{mesh!generation!gmsh!entering! bathymetry! data! into! fluidity! using! Gmsh}
\index{Entering bathymetry data into fluidity using Gmsh}

\subsubsection{Introduction}
\index{Entering bathymetry data into fluidity using Gmsh}
\index{Gmsh}
\index{mesh!generation!gmsh}
\index{Introduction}

Gmsh can be used to create a mesh of a `real' ocean domain for use with \fluidity. Several steps must be followed
to create an ocean mesh compatible with \fluidity:

\begin{itemize}

\item Data is usually given as a list of longitude/latitude/depth co-ordinates, however, if the data 
contains additional information such as national ordinance co-ordinates or data source information e.t.c. 
the data must be pre-processed to remove these.

\item Once the data is in the correct format, three columns containing longitude, latitude and depth, respectively, 
it must then be converted to a netCDF file using GMT (Generic Mapping Tools). Contours from this netCDF will be
extracted for use within Gmsh and later this netCDF file will be used by \fluidity to generate bathymetry
(see section \ref{sect:extruded_meshes}).

\item GMT (Generic Mapping Tools) is then be used to extract the desired shoreline contours from the netCDF file. 

\item The contours must then be imported into GMSH in order to create a mesh.

\item Finally, the mesh can be entered in fluidity.

\end{itemize}

Details of these steps are given below.

\subsubsection{Pre-processing}
\index{Entering bathymetry data into fluidity using GMSH}
\index{Gmsh}
\index{mesh!generation!gmsh}
\index{gmsh}

Horizontal co-ordinates of bathymetric data can come in many different forms: 
longitude/latitude, Ordinance Survey eastings/northings, Universal Mercator Transverse 
co-ordinates, etc. and sometimes more then one of these systems are given. However, 
in generating a mesh for use with \fluidity,
GMT (Generic Mapping Tools, available from: http://gmt.soest.hawaii.edu/ ) is used, which requires 
that the data is columnized in the format: longitude latitude depth. As such, the first step 
required is to convert the data into this format.

\subsubsection*{Example}
\index{Pre-processing}
\index{Entering bathymetry data into fluidity using GMSH}
\index{Gmsh}
\index{mesh!generation!gmsh}
\index{gmsh}

An example of data requiring pre-processing is data obtained for the Mersey Estuary. The raw data is in the form:
\begin{lstlisting}[language = Bash]
Longitude    Latitude   Easting   Northing  Depth Source 
-2.93932242,53.31273731,337425.00,379975.00,15.64,dtm_sj37ne_xyz 
-2.93856211,53.31229379,337475.00,379925.00,15.47,dtm_sj37ne_xyz 
-2.93857197,53.31274321,337475.00,379975.00,14.96,dtm_sj37ne_xyz 
-2.93780182,53.31185026,337525.00,379875.00,15.44,dtm_sj37ne_xyz 
-2.93781167,53.31229969,337525.00,379925.00,16.74,dtm_sj37ne_xyz 
-2.93782152,53.31274912,337525.00,379975.00,15.48,dtm_sj37ne_xyz 
-2.93703170,53.31095731,337575.00,379775.00,16.62,dtm_sj37ne_xyz 
-2.93704155,53.31140673,337575.00,379825.00,14.64,dtm_sj37ne_xyz 
-2.93705139,53.31185616,337575.00,379875.00,14.23,dtm_sj37ne_xyz
etc.
\end{lstlisting}


Thus the Easting, Northing and Source columns need to be removed. As such, the following program
was run on the data file, producing three columns: longitude, latitude and depth.

\begin{lstlisting}[language = Bash]
 Program Mersey_geo 

  Implicit None 

  INTEGER, PARAMETER     :: kr=kind(.0d0) 
  REAL(kr), PARAMETER    :: pi=3.141592653589793238_kr, two=2.0_kr,&
  twopi=two*pi, zero=0.0_kr 
  REAL(kr), DIMENSION(:), ALLOCATABLE :: lon,lat, Easting, Northing, depth 
  INTEGER  :: data_points, i 

  ! Variables for the sphere 
  REAL(kr), PARAMETER :: RE=6378100.0_kr, dtheta=9.0_kr, dphi=9.0_kr 
  REAL(kr), PARAMETER :: theta0=45.0_kr, phi0=45.0_kr 
  REAL(kr) :: theta, phi 

  OPEN (1,FILE='dtm_50m_xyz+.txt',STATUS='OLD') 
  OPEN (2,FILE='Mersey50m.xyz',STATUS='Replace') 
  REWIND (1) 
  
  data_points=43345 

  Allocate (lon(data_points),lat(data_points), Easting(data_points),&
  Northing(data_points), depth(data_points)) 

  Do i=1,data_points 
    READ(1,*) lon(i),lat(i), Easting(i), Northing(i), depth(i) 
  End Do 

  Do i=1,data_points 

    WRITE (2,*) lon(i),' ',lat(i),' ',depth(i) 

  End Do 

  CLOSE (1) 
  CLOSE (2) 

End Program Mersey_geo 
\end{lstlisting}

For data in the netCDF format that requires pre-processing, the netCDF Operator package will be of use. See
\href{http://nco.sourceforge.net/}{nco.sourceforge.net} for details. 

\subsubsection{Making a netCDF file using GMT}
\index{Entering bathymetry data into fluidity using GMSH}
\index{Gmsh}
\index{mesh!generation!gmsh}
\index{gmsh}

Once the data is in the correct form, GMT is used to grid the bathymetry data for input into 
fluidity. To do this, use the following program (note that “module load 
gmt” must first be typed into the terminal):

\begin{lstlisting}[language = Bash]
#!/bin/bash -x 

infile=$1 

gmtset D_FORMAT %14.10f 

# Bounding box 
bbox=`minmax -I0.5m \${}infile` 

\end{lstlisting}
\begin{lstlisting}[language = Bash]
# Resolution of final grid, (in kilometers) 
resolution=-I0.05k 

# Search radius used in nearest-neighbour interpolation 
search_radius=-S0.005k 

cp $infile raw.xyz 
grdmask raw.xyz -Ginfile_mask.grd -N0/NaN/NaN $resolution $bbox $search_radius   
#-N0/NaN/NaN give depth values for points outside, on the border and inside 
the grid, respectively
grd2xyz infile_mask.grd | grep -v nan >> raw.xyz 

# Block average soundings data to prevent aliasing 
blockmode $bbox $resolution raw.xyz > xyz 
     
# Use the nearest neighbour technique to grid data. Could also 
# use surface here and then mask out underdetermined regions 
surface $bbox $resolution -T0.75 xyz -Goutfile.grd 
\end{lstlisting}

This produces a grid with a 50m resolution (to change the resolution just change the number after 
resolution=-I ). To visualize the data, use the mayavi data visualizer. Before doing this, 
the .grd file must be converted into the vtu file type which mayavi can read. As such the following 
command must be entered into the terminal:

\begin{lstlisting}
				grd2vtu outfile.grd
\end{lstlisting}

then to visualize the data:
\begin{lstlisting}		
				mayavi -d outfile.vtu 
\end{lstlisting}

To display the map when mayavi opens, click on “Visualize”, then “Modules” and finally
“SurfaceMap”. A box then opens named “Configure SurfaceMap”, click on “Show Pipeline”, then 
“Actor (vtkOpenGLActor)” and then SetScale and change the last number from 1.0 to something 
small, e.g. 0.0001. Click Apply and then Done. This change is made as the first two co-ordinates 
are in latitude/longitude, while the last is in metres. Close the two boxes and click on +Z 
on the main Mayavi screen. The bathymetry data will then appear. It is useful to do this in order 
to check that the data has been correctly gridded.

\subsubsection{Extracting the contours and importing the bathymetry into GMSH}
\index{Making the mesh}
\index{Entering bathymetry data into fluidity using GMSH}
\index{Gmsh}
\index{mesh!generation!gmsh}
\index{gmsh}

Once the contour files have been extracted, a GMSH file can be automatically generated by 
running the following program. This program will extract a specified contour from the 
netCDF file, to be used as the shoreline, enter the shoreline into GMSH, with a plane 
surface, physical line and physical surface. It is also possbile to extract additional contours, 
i.e. to use as attractors to increase/decrease resolution in certain regions. 
When this program is run, it prompts the user to enter several 
pieces of information into the terminal. These include: the name of the netCDF file; 
the contour to be extracted as the shoreline; whether or not other contours are desired and 
if so, how many and  which ones; the name of the .geo file which the program will write to 
(note, this must be created before running the program); the characteristic length of 
the mesh (if an island is too small it will be meshed over, causing fluidity to fail) 
and whether or not an open boundary is desired. If an open boundary is required, the line 
to be split and the point numbers at which to split the line must be entered.

\begin{lstlisting}[language = Bash]
Program AutomatedGMSHmeshgenerator

!A program to create a coastline in GMSH. The user must enter the name
of the netCDF file; whether or not other shorelines are to be 
extracted, and if so how many and which ones; the name of the .geo file;
the "resolution" i.e. how big an island has to be in order to be 
recognized (based on the characteristic mesh length) and whether or not 
an open boundary is desired. The program then writes a new file containing
GMT commands for extracting the shoreline. If more contours are desired
the file is overwritten so as to extract the new contours. The program next
opens the geo file and writes the code needed to make an empty sphere in GMSH. 
It then opens each contour file in turn, counts the line numbers 
(i.e. the number of data points) and calculates the are of the "island".
For files above the resolution threshold it opens them again, and performs 
a stereographic projection for GMSH. It then writes the points into 
the empty GMSH file in the format GMSH uses, and creates a line 
around them. After all the files have been done the program writes a 
physical line containing all of these lines, line loops around all of 
these lines, a plane surface containing these line loops and a 
physical surface containing the plane surface into the GMSH file. 
Finally, the program opens the files for the other contours, and writes 
the new points lines into the .geo file, without including these lines 
in the plane surface or physical objects.

  Implicit None


  INTEGER, PARAMETER     :: kr=kind(.0d0)
  REAL(kr), PARAMETER    :: pi=3.141592653589793238_kr
  REAL(kr), PARAMETER :: degtorad=pi/180.0_kr, Rmap=1
  INTEGER  :: z, h, j, t, status, N, I, S, P1, P2, &
  line, intpatcharea, b, MANY
  REAL, DIMENSION(:), ALLOCATABLE :: lon,lat,depth
  REAL :: temp, patcharea, R
  REAL, DIMENSION(:), ALLOCATABLE :: x, y, w, u, v, xnew, ynew, znew, latnew, lonnew
  CHARACTER(50) :: filename, geofile, A, bathfile, contour, A1, NewC
  LOGICAL :: ex

  PRINT *, 'Whats the name of the bathymetry file?'
  READ (5,*) bathfile
  PRINT *, 'What contour do you want to extract?'
  READ (5,*) contour
  OPEN (1,FILE='contourextractGMT.sh',STATUS='REPLACE')
  WRITE (UNIT=1,FMT='(A)')'#!/bin/bash -x'
  WRITE (1,*)''
  WRITE (1,*)'region=-R-5.49167/-5.05833/56.3333/56.5667'
  WRITE (1,*)'interval=-I0.01k'
  WRITE (1,*)'colours=-Ccolours.cpt'
  WRITE (1,*)'file=', bathfile
  WRITE (1,*)'PROJ=-JQ0/15c'
  WRITE (1,*)'gmtset ANNOT_FONT_PRIMARY=Times-Roman'
  WRITE (1,*)'gmtset ANNOT_FONT_SECONDARY=Times-Roman'
  WRITE (1,*)'gmtset ANNOT_FONT_SIZE_PRIMARY=16'
  WRITE (1,*)'gmtset LABEL_FONT=Times-Roman'
  WRITE (1,*)'gmtset LABEL_FONT_SIZE=16'
  WRITE (1,*)'gmtset HEADER_FONT=Times-Roman'
  WRITE (1,*)'gmtset HEADER_FONT_SIZE=12'
  WRITE (1,*)'gmtset HEADER_OFFSET=0.1c'
  WRITE (1,*)'gmtset DEGREE_SYMBOL=degree'
  WRITE (1,*)'gmtset PLOT_DEGREE_FORMAT=F'
  WRITE (UNIT=1,FMT='(A)')'cat > contours.dat << EOF'
  WRITE (1,*)contour
  WRITE (UNIT=1,FMT='(A)')'EOF'
  WRITE (1,*)'makecpt -C0-10-colbar.cpt -T-150/0.0/10.0 > colours.cpt'
  WRITE (1,*)'PSFILE=output_file.ps'
  WRITE (1,*)'grdimage $file $PROJ -P -B1a4/1a4 -Xc -Yc $colours -V -K > $PSFILE'
  WRITE (1,*)"psscale -D7.5c/-1c/14c/0.4ch $colours -B'10.0:Bathymetry:' -K -O -V >> $PSFILE"
  WRITE (1,*)'grdcontour -Ccontours.dat $PROJ -DContour -O -K -V $file >> $PSFILE'
  WRITE (1,*)'pscoast $PROJ $region -A50 -N1 -Dh -W0.5p -V -K -O >> $PSFILE'
  CLOSE (1)
  CALL System ('./contourextractGMT.sh')
  PRINT *, 'Do you want to add any other contours for bathymetry purposes (y/n)?'
  READ (5,*) A1
  If (A1=='y') Then
   PRINT *, 'How many?'
   READ(5,*) MANY
   Do t=1, MANY
    PRINT *, 'Which one?'
    READ (5,*) NewC
    OPEN (1,FILE='contourextractGMT.sh',STATUS='REPLACE')
    WRITE (UNIT=1,FMT='(A)')'#!/bin/bash -x'
    WRITE (1,*)''
    WRITE (1,*)'region=-R-5.49167/-5.05833/56.3333/56.5667'
    WRITE (1,*)'interval=-I0.01k'
    WRITE (1,*)'colours=-Ccolours.cpt'
    WRITE (1,*)'file=', bathfile
    WRITE (1,*)'PROJ=-JQ0/15c'
    WRITE (1,*)'gmtset ANNOT_FONT_PRIMARY=Times-Roman'
    WRITE (1,*)'gmtset ANNOT_FONT_SECONDARY=Times-Roman'
    WRITE (1,*)'gmtset ANNOT_FONT_SIZE_PRIMARY=16'
    WRITE (1,*)'gmtset LABEL_FONT=Times-Roman'
    WRITE (1,*)'gmtset LABEL_FONT_SIZE=16'
    WRITE (1,*)'gmtset HEADER_FONT=Times-Roman'
    WRITE (1,*)'gmtset HEADER_FONT_SIZE=12'
    WRITE (1,*)'gmtset HEADER_OFFSET=0.1c'
    WRITE (1,*)'gmtset DEGREE_SYMBOL=degree'
    WRITE (1,*)'gmtset PLOT_DEGREE_FORMAT=F'
    WRITE (UNIT=1,FMT='(A)')'cat > contours.dat << EOF'
    WRITE (1,*)NewC
    WRITE (UNIT=1,FMT='(A)')'EOF'
    WRITE (1,*)'makecpt -C0-10-colbar.cpt -T-150/0.0/10.0 > colours.cpt'
    WRITE (1,*)'PSFILE=output_file.ps'
    WRITE (1,*)'grdimage $file $PROJ -P -B1a4/1a4 -Xc -Yc $colours -V -K > $PSFILE'
    WRITE (1,*)"psscale -D7.5c/-1c/14c/0.4ch $colours -B'10.0:Bathymetry:' -K -O -V >> $PSFILE"
    WRITE (1,*)'grdcontour -Ccontours.dat $PROJ -DContour -O -K -V $file >> $PSFILE'
    WRITE (1,*)'pscoast $PROJ $region -A50 -N1 -Dh -W0.5p -V -K -O >> $PSFILE'
    CLOSE (1)
    CALL System ('./contourextractGMT.sh')
   End Do
  End If

  PRINT *, 'Whats the name of the .geo file?'
  READ (5,*) geofile
  OPEN (2,FILE=geofile,STATUS='OLD')
  WRITE (2,*) 'IP = newp;'
  WRITE (2,*) 'IL = newl;'
  WRITE (2,*) 'ILL = newll;'
  WRITE (2,*) 'IS = news;'
  WRITE (2,*) 'IFI = newf;'
  WRITE (2,*) 'Point ( IP + 0 ) = {0, 0, 0 };'
  WRITE (2,*) 'Point ( IP + 1 ) = {0, 0,6.37101e+06};'
  WRITE (2,*) 'PolarSphere ( IS + 0 ) = {IP , IP+1};'
!This opens a file and writes the code to create a sphere in GMSH
  N=0
  I=0
  PRINT *, 'What is the Characteristic Length?'
  READ (5,*) R
  PRINT *, 'Do you want an open boundary? (y/n)'
  READ (5,*) A
  If (A=='y') Then
   PRINT *, 'On which line? (Note: IL+0=1, IL+=1=2, etc...)'
   READ (5,*) Line
   PRINT *, 'Between which points? (smaller point number first)'
   READ (5,*) P1, P2
  Else
  End If
  
  b=0
  ex=.true.
  Do while (ex .eqv. .true.)
    If (b<=9) Then
     WRITE (filename, '(A,A,A,I1,A )') 'Contour_',trim(contour),'_',b, '_i.xyz'
    ElseIf (b<100 .AND. b>=10) Then
     WRITE (filename, '(A,A,A,I2,A )') 'Contour_',trim(contour),'_',b, '_i.xyz'
    Else 
     WRITE (filename, '(A,A,A,I3,A )') 'Contour_',trim(contour),'_',b, '_i.xyz'
    EndIf
    INQUIRE (FILE=filename, EXIST=ex)   
    If (ex .eqv. .true.) Then
     b=b+1
    End If
  End Do

  Do  h=0,b-1
   If (h<=9) Then
    WRITE (filename, '(A,A,A,I1,A )') 'Contour_',trim(contour),'_',h, '_i.xyz'
   ElseIf (h<100 .AND. h>=10) Then
    WRITE (filename, '(A,A,A,I2,A )') 'Contour_',trim(contour),'_',h, '_i.xyz'
   Else 
    WRITE (filename, '(A,A,A,I3,A )') 'Contour_',trim(contour),'_',h, '_i.xyz'
   EndIf
!Add another if for higher values for h
   OPEN (3,FILE=filename,STATUS='OLD', IOSTAT=status)
!This tells the program the names of the files
   z = 0

   Do while (status==0)
    READ(3,*, IOSTAT=status) temp, temp, temp
    If (status==0) Then
      z=z+1
    End If
   End Do   
   Close(3)
!This counts the number of lines in the file
   
   OPEN (3,FILE=filename,STATUS='OLD')
   REWIND(3)
   Allocate(lon(z),lat(z),depth(z), xnew(z), ynew(z), znew(z) &
   , latnew(z), lonnew(z))
   patcharea=0.0

   Do j= 1,z
    READ(3,*) lon(j), lat(j),depth(j)
    latnew(j)=lat(j)*degtorad
    lonnew(j)=lon(j)*degtorad
    xnew(j)=(6.37101e+06)*sin(pi/2.0-latnew(j))*cos(lonnew(j))
    ynew(j)=(6.37101e+06)*sin(pi/2.0-latnew(j))*sin(lonnew(j))
    znew(j)=(6.37101e+06)*cos(pi/2.0-latnew(j))     
   End Do

   Do   j=1, z-1
    patcharea=patcharea+(xnew(j)*(ynew(j+1)-ynew(j))&
    -ynew(j)*(xnew(j+1)-xnew(j)))*6.37101e+06/(6.37101e+06+znew(j))
   End Do

   patcharea=patcharea+(xnew(z)*(ynew(1)-ynew(z))&
   -ynew(z)*(xnew(1)-xnew(z))*6.37101e+06)/(6.37101e+06+znew(z))
   patcharea=abs(patcharea)
   Deallocate(lat,lon, depth, xnew, ynew, znew, latnew, lonnew)
   Close (3)

   If (patcharea>(R**2.0/2.0)) Then
!This is the resolution. In this case, any file with less than 6 points is 
ignored, though the number of lines in the file is added to the running total
    OPEN (3,FILE=filename,STATUS='OLD')
    REWIND(3)
    
    Allocate(lon(z),lat(z),depth(z),x(z), &
    y(z),w(z),u(z),v(z))

    Do j= 1,z
      READ(3,*) lon(j),lat(j),depth(j)
    End Do

    Do j=1,z 
      x(j) = -Rmap*cos(lat(j)*degtorad)*cos(lon(j)*degtorad)
      y(j) = -Rmap*cos(lat(j)*degtorad)*sin(lon(j)*degtorad)
      w(j) = Rmap*sin(lat(j)*degtorad)
      u(j) = ((Rmap) / (Rmap+(w(j))))*x(j)
      v(j) = ((Rmap) / (Rmap+(w(j))))*y(j)
    End Do
!This is the stereographic projection system used in GMSH
  
    Do j=1,z
      WRITE (2,*) 'Point(IP+',N+j+1,')=','{',u(j),',',v(j),', 0 };'
    End Do
!This is how points are written in GMSH

    WRITE (2,*) 'BSpline(IL +',I, ') = {', N+3, ':', N+z+1, ',', N+3,'};'
!This is how lines are written in GMSH
    Deallocate (lon,lat,depth,x,y,w,u,v)
    CLOSE (3)  
   ElseIf (patcharea.LE.(R**2.0/2.0)) Then
   End If

   If (status<0 .AND. patcharea>(R**2.0/2.0)) Then
    N=N+z
    I=I+1
   ElseIf (status<0 .AND. patcharea<(R**2.0/2.0)) Then
   End If
  End Do
 
  If (A=='n') Then
   WRITE (2,*) 'Physical Line (',I+1,') = {' 
   Do H = 0, I-1
    If (H<I-1) Then
     WRITE (2,*) H, ','
    Else
     Write (2,*) H
    End If
   End Do
   Write (2, *) '};'
!This writes a Physical Line containing all of the Lines
   Do H = I, 2*I-1
    WRITE (2,*) 'Line Loop(',H+2,')={',H-I+1,'};'
   End Do
!Line Loops are needed for a Plane Surface
   WRITE (2,*) 'Plane Surface (',2*I+2,') = {'
   Do H = I+2, 2*I+1
    If (H<2*I+1) Then
     WRITE (2,*) H, ','
    Else
     Write (2,*) H
    End If
   End Do
   WRITE (2, *) '};'
   WRITE (2,*) 'Physical Surface(',2*I+3,') = {', 2*I+2,'};'
  Else
   WRITE (2,*) 'Split Line(',Line,') {',P1,',', P2, '};'
   WRITE(2,*) 'Delete { '
   WRITE(2,*) 'Line{',I+1,'};'
   WRITE(2,*) '}'
   WRITE (2,*) 'BSpline(',I+3,')={',P1,',',P2,'};'
!This is the line for the open boundary
   WRITE (2,*) 'Physical Line (',I+4,') = {' 
   Do H = 1, I
     WRITE (2,*) H, ','
   End Do
   WRITE (2,*) I+2
   WRITE (2, *) '};'
   WRITE (2,*) 'Physical Line (',I+5,')={',I+3,'};'
! We now have 2 separate physical lines: 1 with the open boundary and one 
with the closed boundary
   WRITE(2,*) 'Line Loop(',I+6,') ={',I+2, ',', I+3,'};'
   Do H = I-1, 2*I-3
    WRITE (2,*) 'Line Loop(',H+8,')={',H-I+3,'};'
   End Do
   WRITE (2,*) 'Plane Surface (',2*I+6,') = {'
   WRITE(2,*) I+6,','
   Do H = I+7, 2*I+5
    If (H<2*I+5) Then
     WRITE (2,*) H, ','
    Else
     WRITE (2,*) H
    End If
   End Do
   WRITE (2, *) '};'
   WRITE (2,*) 'Physical Surface(',2*I+7,') = {', 2*I+6,'};'
  End If
 
  If (A1=='y') Then
   b=0
   ex=.true.
   Do while (ex .eqv. .true.)
    If (b<=9) Then
     WRITE (filename, '(A,A,A,I1,A )') 'Contour_',trim(NewC),'_',b, '_i.xyz'
    ElseIf (b<100 .AND. b>=10) Then
     WRITE (filename, '(A,A,A,I2,A )') 'Contour_',trim(NewC),'_',b, '_i.xyz'
    Else 
     WRITE (filename, '(A,A,A,I3,A )') 'Contour_',trim(NewC),'_',b, '_i.xyz'
    EndIf
    INQUIRE (FILE=filename, EXIST=ex)   
    If (ex .eqv. .true.) Then
     b=b+1
    End If
   End Do

   Do  h=0,b-1
    If (h<=9) Then
     WRITE (filename, '(A,A,A,I1,A )') 'Contour_',trim(NewC),'_',h, '_i.xyz'
     ElseIf (h<100 .AND. h>=10) Then
     WRITE (filename, '(A,A,A,I2,A )') 'Contour_',trim(NewC),'_',h, '_i.xyz'
    Else 
     WRITE (filename, '(A,A,A,I3,A )') 'Contour_',trim(NewC),'_',h, '_i.xyz'
    EndIf

    OPEN (3,FILE=filename,STATUS='OLD', IOSTAT=status)
    z = 0

    Do while (status==0)
     READ(3,*, IOSTAT=status) temp, temp, temp
     If (status==0) Then
       z=z+1
     End If
    End Do   
    Close(3)
   
    OPEN (3,FILE=filename,STATUS='OLD')
    REWIND(3)
    Allocate(lon(z),lat(z),depth(z), x(z), y(z), u(z), w(z) &
    , v(z))
       
    Do j= 1,z
      READ(3,*) lon(j),lat(j),depth(j)
    End Do

    Do j=1,z
      x(j) = -Rmap*cos(lat(j)*degtorad)*cos(lon(j)*degtorad)
      y(j) = -Rmap*cos(lat(j)*degtorad)*sin(lon(j)*degtorad)
      w(j) = Rmap*sin(lat(j)*degtorad)
      u(j) = ((Rmap) / (Rmap+(w(j))))*x(j)
      v(j) = ((Rmap) / (Rmap+(w(j))))*y(j)
    End Do
  
    Do j=1,z
      WRITE (2,*) 'Point(IP+',N+j+1,')=','{',u(j),',',v(j),', 0 };'
    End Do
    WRITE (2,*) 'BSpline(IL +',I, ') = {', N+3, ':', N+z+1, ',', N+3,'};'
    Deallocate (lon,lat,depth,x,y,w,u,v)
    Close(3)

    N=N+z 
    I=I+1
   End Do
  End If
  Close(2)
  PRINT *, 'Enjoy- its been a pleasure ;)'

End Program AutomatedGMSHmeshgenerator
\end{lstlisting}

The characteristic length the user desires may be unknown when first creating a mesh. If so, enter 0 into the terminal, 
then when the mesh has been created to the users satisfaction, re-run the program using the minimum characteristic length 
and then remake the mesh.

\subsubsection{Making the mesh}
\index{Making the mesh}
\index{Entering bathymetry data into fluidity using GMSH}
\index{Gmsh}
\index{mesh!generation!gmsh}
\index{gmsh}

To make the mesh, open the .geo file, scroll down to the bottom of the file and copy:

\begin{lstlisting}[language = Bash]
Field [ IFI + 0]  = Attractor; 
Field [ IFI + 0].NodesList  = { IP + 2 : IP + n}; 
Field[2] = Restrict; 
Delete Field [2]; 
Field[2] = MathEval; 
Field[2].F = "250"; 
Background Field = 2; 
\end{lstlisting}

Next, open the file in GMSH. Click on Geometry and scroll down to “Mesh”. Click on 1-D, then 2-D (note: doing 
this produces a better mesh than simply clicking 2-D). If the mesh is the wrong size (i.e. it is too coarse, or 
GMSH crashes when making it), open Mesh again, and click on “Define”, then “Fields” and then MathEval in the new box.
Under “Options”, change the number to be higher or lower, depending on the problem encountered, and click “Apply”.  Go back to the
main Mesh menu and press 1-D and 2-D again. This can take some trial and error, but finding a good ball-park number
shouldn't take too long. 

If more resolution is required in a specific area, click on “New”, then “Attractor”. In the box next to “NodesList”, enter 
the point numbers of points close to the desired area (1 or 2 is enough). If resolution is required close to a line or surface, 
type in the line or surface number into “LineList” or “SurfaceList”. 

Click on New again, then “Threshold”. Enter numbers for “LcMax” (the largest element size), and “LcMin” (the smallest mesh size) 
“DistMax” (the distance away from from the nodes/lines/surfaces at which the element size is given by LcMax) and “Distmin” 
(the distance away from the node/line/surface to which the element size is given by LcMin). Next to “IField”, enter 3 
(to specify that the new Attractor field is being used). Tick the “Set as background field” box and press “Apply”. Again, 
reload the mesh, look at the results and modify the Threshold numbers until satisfied. Finally, click “Save” on the Mesh menu.

Note: A plug-in is currently under development with the aim of creating a mesh whose resolution is proportional to the local bathymetry.

\subsubsection{Entering the mesh into fluidity}
\index{Entering bathymetry data into fluidity using GMSH}
\index{Gmsh}
\index{mesh!generation!gmsh}
\index{gmsh}

After the mesh file has been generated, move the .msh and the outfile.grd files into a new folder in Fluidity. Type:
\begin{lstlisting}[language = Bash]
	 ../../scripts/gmsh2triangle file.msh
\end{lstlisting}

Open the newly created file.node. Change the second number on the first line from a 3 to a 2 (this is owing to the fact that
the mesh has three position coordinates but is topologically a 2-D object). Finally, create a new .flml file setting the bottom depth
to be read from the .grd file.

\subsubsection{Troubleshooting}
\index{Entering bathymetry data into fluidity using GMSH}
\index{Gmsh}
\index{mesh!generation!gmsh}
\index{gmsh}

Some common problems encountered when generating an ocean mesh are listed below.

\begin{itemize}

\item Check the signs of the data. For example, check if the depth is positive instead of negative.

\item If there are random spikes when visualizing the data try reducing the resolution used in the GMT griding commands. The spikes
may be points for which there is no data which GMT is setting to 0.

\item Bathymetry data may be missing close to the shoreline (e.g. no data above -10m). To modify this, use g3data to extract a 
coastline from a map (e.g. an OS map), and add the co-ordinates to the file entered into GMT. There will still be gaps in the 
information that GMT will attempt to cover, but  this will usually give a relatively accurate representation.

\item If the data comes in .grd format the first few steps can be skipped and the contours can be directly extracted.

\item Due to GMSHs stereographic co-ordinate projection system, if the south pole is not contained by an island when creating a global 
mesh, GMSH will mesh the islands/continents and not the oceans. To correct this, rotate the co-ordinates of the all the 
points so that the south pole is contained by an island and then generate the mesh. Once the mesh has been created, copy and paste the node 
coordinates in the .msh file into a new file, perform a rotation back to the original orientation, then copy the rotated node locations back into the .msh file.

\end{itemize}


