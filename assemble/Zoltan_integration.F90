#include "fdebug.h"
#include "confdefs.h"

module zoltan_integration

#ifdef HAVE_ZOLTAN
! these 5 need to be on top and in this order, so as not to confuse silly old intel compiler 
  use quadrature
  use elements
  use sparse_tools
  use fields
  use state_module

  use field_options
  use mpi_interfaces
  use halos
  use parallel_fields
  use sparsity_patterns_meshes
  use vtk_interfaces
  use zoltan
  use linked_lists
  use global_parameters, only: real_size, OPTION_PATH_LEN, topology_mesh_name, no_active_processes
  use data_structures
  use populate_state_module
  use reserve_state_module
  use boundary_conditions_from_options
  use boundary_conditions
  use metric_tools
  use c_interfaces
  use surface_id_interleaving
  use halos_ownership
  use memory_diagnostics
  use detector_data_types
  use detector_tools
  use pickers
  use diagnostic_variables
  use hadapt_advancing_front
  use parallel_tools
  use fields_halos

! adding to use the ele_owner function
  use halos_derivation
  
  use zoltan_global_variables
  use zoltan_callbacks
  use zoltan_detectors

  implicit none

  ! Module-level so that the Zoltan callback functions can access it
  type(mesh_type), save :: zz_mesh
  type(vector_field), save :: zz_positions
  type(mesh_type), save :: tmp_mesh
  integer :: tmp_mesh_nhalos
  type(csr_sparsity), pointer :: zz_sparsity_two
  type(halo_type), pointer :: zz_ele_halo 
  type(detector_linked_list), target, save :: unpacked_detectors_list, to_pack_detectors_list
  type(vector_field), save :: new_positions

  type(integer_hash_table), save :: nodes_we_are_sending ! in old local numbers
  type(integer_set), save :: nodes_we_are_keeping ! in old local numbers
  type(integer_hash_table), save :: universal_to_new_local_numbering, universal_to_old_local_numbering
  type(integer_set), save :: new_nodes

  type(integer_set), save :: new_elements
  type(integer_set), dimension(:), allocatable :: new_nelist
  

  integer, parameter :: integer_size = bit_size(0_zoltan_int)/8
  integer(zoltan_int), dimension(:), pointer :: my_import_procs => null(), my_import_global_ids => null()
  integer(zoltan_int) :: my_num_import

  type(integer_set), dimension(:), allocatable :: receives
  type(state_type), dimension(:), allocatable :: source_states, target_states
  
  type(integer_hash_table), save :: uen_to_new_local_numbering, uen_to_old_local_numbering, old_local_numbering_to_uen

  type(integer_set), dimension(:), allocatable :: old_snelist, new_snelist
  type(integer_hash_table) :: universal_surface_number_to_surface_id
  type(integer_hash_table) :: universal_surface_number_to_element_owner
  type(integer_set), save :: new_surface_elements
  
  logical, save :: preserve_mesh_regions
  type(integer_hash_table) :: universal_element_number_to_region_id

  logical, save :: preserve_columns=.false.
  integer, dimension(:), allocatable, save :: universal_columns
  type(integer_hash_table), save :: universal_to_new_local_numbering_m1d

  type(scalar_field), save :: node_quality
  integer, save :: max_coplanar_id, max_size, num_dets_to_transfer

  ! Global variables for storing detector data
  integer :: ndims, ndata_per_det
  integer, dimension(:), allocatable :: ndets_in_ele
 
  public :: zoltan_drive
  private

  contains


  ! Here is how we pack nodal positions for phase one migration:
  ! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  ! | position | sz of lv-1 nnlist | lv-1 nnlist | sz of lv-2 nnlist | lv-2 nnlist | owners of level-2 nnlist | sz of nelist | nelist | sz of snelist | snelist | snelist ids | containing element of snelist |
  ! ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  subroutine zoltan_cb_pack_node_sizes(data, num_gid_entries,  num_lid_entries, num_ids, global_ids, local_ids, sizes, ierr) 
    integer(zoltan_int), dimension(*), intent(in) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries, num_lid_entries, num_ids
    integer(zoltan_int), intent(in), dimension(*) :: global_ids,  local_ids
    integer(zoltan_int), intent(out), dimension(*) :: sizes 
    integer(zoltan_int), intent(out) :: ierr  

    integer :: i, node
    character (len = OPTION_PATH_LEN) :: filename

    ewrite(1,*) "In zoltan_cb_pack_node_sizes"
    do i=1,num_ids
      node = local_ids(i)
      sizes(i) = zz_positions%dim * real_size + &
                1 * integer_size + row_length(zoltan_global_zz_sparsity_one, node) * integer_size + &
                1 * integer_size + row_length(zz_sparsity_two, node) * integer_size * 2 + &
                1 * integer_size + row_length(zoltan_global_zz_nelist, node) * integer_size + &
                1 * integer_size + key_count(old_snelist(node)) * integer_size * 3
      if(preserve_mesh_regions) then
        sizes(i) = sizes(i) + row_length(zoltan_global_zz_nelist, node) * integer_size
      end if
      if(preserve_columns) then
        sizes(i) = sizes(i) + integer_size
      end if
    end do

    if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/zoltan_debug/dump_node_sizes")) then
       write(filename, '(A,I0,A)') 'node_sizes_', getrank(),'.dat'
       open(666, file = filename)
       do i=1,num_ids
          write(666,*) sizes(i)
       end do
       close(666)
    end if

    ierr = ZOLTAN_OK
  end subroutine zoltan_cb_pack_node_sizes

  subroutine zoltan_cb_pack_nodes(data, num_gid_entries, num_lid_entries, num_ids, global_ids, local_ids, dest, sizes, idx, buf, ierr)  
    integer(zoltan_int), dimension(*), intent(in) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries, num_lid_entries, num_ids 
    integer(zoltan_int), intent(in), dimension(*) :: global_ids 
    integer(zoltan_int), intent(in), dimension(*) :: local_ids 
    integer(zoltan_int), intent(in), dimension(*) :: dest
    integer(zoltan_int), intent(in), dimension(*) :: sizes 
    integer(zoltan_int), intent(in), dimension(*) :: idx 
    integer(zoltan_int), intent(out), dimension(*) :: buf 
    integer(zoltan_int), intent(out) :: ierr

    integer :: i, j, node, ratio, head

    ewrite(1,*) "In zoltan_cb_pack_nodes"
    ratio = real_size / integer_size
    assert(int(float(real_size) / float(integer_size)) == ratio) ! that ratio really is an int

    do i=1,num_ids
      head = idx(i)
      node = local_ids(i)
      assert(halo_universal_number(zoltan_global_zz_halo, node) == global_ids(i))
      do j=1,zz_positions%dim
        buf(head:head+ratio-1) = transfer(node_val(zz_positions, j, node), buf(head:head+ratio-1))
        head = head + ratio
      end do
      
      if(preserve_columns) then
        buf(head) = universal_columns(node)
        head = head + 1
      end if
      
      buf(head) = row_length(zoltan_global_zz_sparsity_one, node)
      head = head + 1

      buf(head:head+row_length(zoltan_global_zz_sparsity_one, node)-1) = halo_universal_number(zoltan_global_zz_halo, row_m_ptr(zoltan_global_zz_sparsity_one, node))
      head = head + row_length(zoltan_global_zz_sparsity_one, node)

      buf(head) = row_length(zz_sparsity_two, node)
      head = head + 1

      buf(head:head+row_length(zz_sparsity_two, node)-1) = halo_universal_number(zoltan_global_zz_halo, row_m_ptr(zz_sparsity_two, node))
      head = head + row_length(zz_sparsity_two, node)

      buf(head:head+row_length(zz_sparsity_two, node)-1) = halo_node_owners(zoltan_global_zz_halo, row_m_ptr(zz_sparsity_two, node))
      head = head + row_length(zz_sparsity_two, node)

      buf(head) = row_length(zoltan_global_zz_nelist, node)
      head = head + 1

      buf(head:head+row_length(zoltan_global_zz_nelist,node)-1) = halo_universal_number(zz_ele_halo, row_m_ptr(zoltan_global_zz_nelist, node))
      head = head + row_length(zoltan_global_zz_nelist, node)

      if(preserve_mesh_regions) then
        ! put in the region_ids in the same amount of space as the nelist - this is complete overkill!
        buf(head:head+row_length(zoltan_global_zz_nelist,node)-1) = fetch(universal_element_number_to_region_id, halo_universal_number(zz_ele_halo, row_m_ptr(zoltan_global_zz_nelist, node)))
        head = head + row_length(zoltan_global_zz_nelist, node)
      end if

      buf(head) = key_count(old_snelist(node))
      head = head + 1
      buf(head:head + key_count(old_snelist(node)) - 1) = set2vector(old_snelist(node))
      head = head + key_count(old_snelist(node))
      buf(head:head + key_count(old_snelist(node)) - 1) = fetch(universal_surface_number_to_surface_id, set2vector(old_snelist(node)))
      head = head + key_count(old_snelist(node))
      buf(head:head + key_count(old_snelist(node)) - 1) = fetch(universal_surface_number_to_element_owner, set2vector(old_snelist(node)))
      head = head + key_count(old_snelist(node))

      !assert(head == idx(i) + (sizes(i)/integer_size) - 1)
    end do
    ierr = ZOLTAN_OK
  end subroutine zoltan_cb_pack_nodes

  subroutine zoltan_cb_unpack_nodes(data, num_gid_entries, num_ids, global_ids, sizes, idx, buf, ierr)
    integer(zoltan_int), dimension(*), intent(inout) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries 
    integer(zoltan_int), intent(in) :: num_ids 
    integer(zoltan_int), intent(in), dimension(*) :: global_ids
    integer(zoltan_int), intent(in), dimension(*) :: sizes 
    integer(zoltan_int), intent(in), dimension(*) :: idx 
    integer(zoltan_int), intent(in), dimension(*), target :: buf 
    integer(zoltan_int), intent(out) :: ierr  

    integer :: i, ratio, head, sz, j
    type(integer_set) :: new_nodes_we_have_recorded, new_nodes_we_still_need, halo_nodes_we_currently_own
    type(mesh_type) :: new_mesh
    integer, dimension(:), pointer :: neighbours
    logical :: changed
    integer :: old_local_number, new_local_number, universal_number
    real, dimension(zz_positions%dim) :: new_coord
    type(integer_hash_table) :: universal_number_to_old_owner
    integer :: old_owner, new_owner
    integer, dimension(:), pointer :: current_buf
    integer :: rank

    ewrite(1,*) "In zoltan_cb_unpack_nodes"
    ! assert new linear mesh and positions not allocated
    assert(.not. associated(new_mesh%refcount))
    assert(.not. associated(new_positions%refcount))
    rank = getrank()

    ! Figure out the nodes we are going to know about
    call allocate(new_nodes)

    ! All the nodes we currently have and still own, in universal numbering
    do i=1,key_count(nodes_we_are_keeping)
      old_local_number = fetch(nodes_we_are_keeping, i)
      call insert(new_nodes, halo_universal_number(zoltan_global_zz_halo, old_local_number), changed=changed)
    end do

    ! All the nodes we are receiving from other people and are going to own
    do i=1,num_ids
      call insert(new_nodes, global_ids(i))
    end do

    call allocate(universal_number_to_old_owner)
    call allocate(halo_nodes_we_currently_own)

    ! All the halos of (the nodes we currently have and still own), in universal numbering
    do i=1,key_count(nodes_we_are_keeping)
      neighbours => row_m_ptr(zz_sparsity_two, fetch(nodes_we_are_keeping, i))
      do j=1,size(neighbours)
        universal_number = halo_universal_number(zoltan_global_zz_halo, neighbours(j))
        call insert(new_nodes, universal_number, changed=changed)
        if (changed) then ! so it is a halo node
          old_owner = halo_node_owner(zoltan_global_zz_halo, neighbours(j)) - 1
          assert(old_owner < getnprocs())
          if (old_owner == rank) then
            call insert(halo_nodes_we_currently_own, neighbours(j))
          end if
          call insert(universal_number_to_old_owner, universal_number, old_owner)
        end if
      end do
    end do

    ! We need to process these too -- nodes we own now, but will
    ! not own later, and will become our halo nodes.
    do i=1,key_count(halo_nodes_we_currently_own)
      old_local_number = fetch(halo_nodes_we_currently_own, i)
      universal_number = halo_universal_number(zoltan_global_zz_halo, old_local_number)
      call insert(new_nodes, universal_number)
    end do

    ! All the other nodes that will form the halo of the new nodes we are receiving 
    ratio = real_size / integer_size
    do i=1,num_ids
      current_buf => buf(idx(i):idx(i) + sizes(i)/integer_size)
      head = ratio * zz_positions%dim + 1
      if(preserve_columns) then
        head = head + 1
      end if
      ! current_buf(head) is the size of the level-1 nnlist, which we want to skip over for now
      ! we will however sum up the sizes so that we can allocate the csr sparsity later
      head = head + current_buf(head) + 1
      ! now current_buf(head) is the size of the level-2 nnlist, which we want to process
      ! and we will also sum up the sizes so that we can allocate the csr sparsity later
      sz = current_buf(head)
      do j=1,sz
        universal_number = current_buf(head + j)
        old_owner = current_buf(head + j + sz) - 1
        assert(old_owner < getnprocs())
        call insert(new_nodes, universal_number) ! the sparsity for a node includes itself
        call insert(universal_number_to_old_owner, universal_number, old_owner)
      end do
    end do

    ! Now new_nodes implicitly defines a mapping
    ! between 1 .. key_count(new_nodes) [these are the new local node numbers]
    ! and the universal node numbers of the nodes.
    ! We're going to invert that to create the hash table of universal node numbers -> local node numbers
    ! to facilitate the transfer of field information later.
    call invert_set(new_nodes, universal_to_new_local_numbering)

    ! allocate the new objects
    ! We know the number of nodes, but not the number of elements .. hmm.
    ! We will allocate it with 0 elements for now, and work it out when we
    ! invert the nnlist to compute an enlist later.
    call allocate(new_mesh, key_count(new_nodes), 0, zz_mesh%shape, trim(zz_mesh%name))
    new_mesh%option_path = zz_mesh%option_path
    if(preserve_columns) then
      allocate(new_mesh%columns(key_count(new_nodes)))
    end if
    call allocate(new_positions, zz_positions%dim, new_mesh, trim(zz_positions%name))
    new_positions%option_path = zz_positions%option_path
    call deallocate(new_mesh)
    allocate(new_snelist(key_count(new_nodes)))
    call allocate(new_snelist)

    ! aaaand unpack, recording which universal ids we have received
    ! so that we can figure out which ones we haven't received yet
    ! so that we can ask their old owner to send on the new details
    ! a) build a set of the nodes we have recorded
    ! b) from that, build a set of the nodes we haven't yet recorded
    ! c) figure out who owns those nodes, so we can build the import list for zoltan

    allocate(new_nelist(key_count(new_nodes)))
    do i=1,key_count(new_nodes)
      call allocate(new_nelist(i))
    end do
    call allocate(new_elements)
    call allocate(new_surface_elements)

    call allocate(new_nodes_we_have_recorded)
    ! Nodes we are keeping
    do i=1,key_count(nodes_we_are_keeping)
      old_local_number = fetch(nodes_we_are_keeping, i)
      universal_number = halo_universal_number(zoltan_global_zz_halo, old_local_number)
      new_local_number = fetch(universal_to_new_local_numbering, universal_number)
      call insert(new_nodes_we_have_recorded, universal_number)
      call set(new_positions, new_local_number, node_val(zz_positions, old_local_number))

      if(preserve_columns) then
        new_positions%mesh%columns(new_local_number) = fetch(universal_to_new_local_numbering_m1d, &
                                                             universal_columns(old_local_number))
      end if

      ! Record the nelist information
      neighbours => row_m_ptr(zoltan_global_zz_nelist, old_local_number)
      do j=1,size(neighbours)
        call insert(new_nelist(new_local_number), halo_universal_number(zz_ele_halo, neighbours(j)))
        call insert(new_elements, halo_universal_number(zz_ele_halo, neighbours(j)))
        ! don't need to do anything to universal_element_number_to_region_id because we already have it
      end do

      ! and record the snelist information
      do j=1,key_count(old_snelist(old_local_number))
        call insert(new_snelist(new_local_number), fetch(old_snelist(old_local_number), j))
        call insert(new_surface_elements, fetch(old_snelist(old_local_number), j))
        ! we don't need to add anything to the universal_surface_number_to_surface_id because we already have it
      end do
    end do

    ! Set the positions and nelist of halo_nodes_we_currently_own
    do i=1,key_count(halo_nodes_we_currently_own)
      old_local_number = fetch(halo_nodes_we_currently_own, i)
      universal_number = halo_universal_number(zoltan_global_zz_halo, old_local_number)
      new_local_number = fetch(universal_to_new_local_numbering, universal_number)
      call set(new_positions, new_local_number, node_val(zz_positions, old_local_number))

      if(preserve_columns) then
        new_positions%mesh%columns(new_local_number) = fetch(universal_to_new_local_numbering_m1d, &
                                                             universal_columns(old_local_number))
      end if

      neighbours => row_m_ptr(zoltan_global_zz_nelist, old_local_number)
      do j=1,size(neighbours)
        call insert(new_nelist(new_local_number), halo_universal_number(zz_ele_halo, neighbours(j)))
        call insert(new_elements, halo_universal_number(zz_ele_halo, neighbours(j)))
        ! don't need to do anything to universal_element_number_to_region_id because we already have it
      end do

      call insert(new_nodes_we_have_recorded, universal_number)

      new_owner = fetch(nodes_we_are_sending, old_local_number)
      call insert(receives(new_owner+1), universal_number)

      ! and record the snelist information
      do j=1,key_count(old_snelist(old_local_number))
        call insert(new_snelist(new_local_number), fetch(old_snelist(old_local_number), j))
        call insert(new_surface_elements, fetch(old_snelist(old_local_number), j))
      end do
    end do
    call deallocate(halo_nodes_we_currently_own)

    ! Nodes we are gaining
    do i=1,num_ids
      call insert(new_nodes_we_have_recorded, global_ids(i))
      new_local_number = fetch(universal_to_new_local_numbering, global_ids(i))
      new_coord = 0
      head = idx(i)
      do j=1,zz_positions%dim
        new_coord(j) = transfer(buf(head:head+ratio-1), new_coord(j))
        head = head + ratio
      end do
      call set(new_positions, new_local_number, new_coord)

      if(preserve_columns) then
        new_positions%mesh%columns(new_local_number) = fetch(universal_to_new_local_numbering_m1d, buf(head)) 
        head = head + 1
      end if

      ! Record the nelist information
      sz = buf(head) ! level-1 nnlist
      head = head + sz + 1
      sz = buf(head) ! level-2 nnlist
      head = head + 2*sz + 1
      sz = buf(head) ! nelist
      do j=1,sz
        call insert(new_nelist(new_local_number), buf(head + j))
        call insert(new_elements, buf(head + j))
        if(preserve_mesh_regions) then
          call insert(universal_element_number_to_region_id, buf(head + j), buf(head + j + sz))
        end if
      end do
      if(preserve_mesh_regions) then
        head = head + 2*sz + 1
      else
        head = head + sz + 1
      end if

      ! And record the snelist information
      sz = buf(head)
      do j=1,sz
        call insert(new_snelist(new_local_number), buf(head + j))
        call insert(universal_surface_number_to_surface_id, buf(head + j), buf(head + j + sz))
        call insert(universal_surface_number_to_element_owner, buf(head + j), buf(head + j + 2*sz))
        call insert(new_surface_elements, buf(head + j))
      end do
      head = head + 3*sz + 1
    end do

    ! At this point, there might still be nodes that we have not yet recorded but
    ! we own, so we can fill them in now.
    call allocate(new_nodes_we_still_need)
    do i=1,key_count(new_nodes)
      universal_number = fetch(new_nodes, i)
      if (has_value(new_nodes_we_have_recorded, universal_number)) cycle

      old_owner = fetch(universal_number_to_old_owner, universal_number)
      if (old_owner == rank) then
        call insert(new_nodes_we_have_recorded, universal_number)
        old_local_number = fetch(universal_to_old_local_numbering, universal_number)
        new_local_number = fetch(universal_to_new_local_numbering, universal_number)
        call set(new_positions, new_local_number, node_val(zz_positions, old_local_number))

        if(preserve_columns) then
          new_positions%mesh%columns(new_local_number) = fetch(universal_to_new_local_numbering_m1d, &
                                                               universal_columns(old_local_number))
        end if

        ! Record the nelist information
        neighbours => row_m_ptr(zoltan_global_zz_nelist, old_local_number)
        do j=1,size(neighbours)
          call insert(new_nelist(new_local_number), halo_universal_number(zz_ele_halo, neighbours(j)))
          call insert(new_elements, halo_universal_number(zz_ele_halo, neighbours(j)))
          ! don't need to do anything to universal_element_number_to_region_id because we already have it
        end do

        ! and record the snelist information
        do j=1,key_count(old_snelist(old_local_number))
          call insert(new_snelist(new_local_number), fetch(old_snelist(old_local_number), j))
          call insert(new_surface_elements, fetch(old_snelist(old_local_number), j))
          ! we don't need to add anything to the universal_surface_number_to_surface_id because we already have it
        end do

        ! and record the node in the receives
        new_owner = fetch(nodes_we_are_sending, old_local_number)
        call insert(receives(new_owner+1), universal_number)
      else
        call insert(new_nodes_we_still_need, universal_number)
      end if
    end do

    ! And build the import list ...
    my_num_import = key_count(new_nodes_we_still_need)
    allocate(my_import_procs(my_num_import))
    allocate(my_import_global_ids(my_num_import))
    do i=1,my_num_import
      universal_number = fetch(new_nodes_we_still_need, i)
      my_import_global_ids(i) = universal_number
      my_import_procs(i) = fetch(universal_number_to_old_owner, universal_number)
      assert(my_import_procs(i) /= rank)
    end do

    call deallocate(new_nodes_we_have_recorded)
    call deallocate(new_nodes_we_still_need)
    call deallocate(universal_number_to_old_owner)

    ierr = ZOLTAN_OK
  end subroutine zoltan_cb_unpack_nodes

  ! Here is how we pack halo nodes for phase two migration:
  ! -----------------------------------------------------------------------------------------------------------------------------------------------------
  ! | position | new owner | size of nelist | nelist | size of snelist | snelist | surface ids | the containing volume element for each surface element |
  ! -----------------------------------------------------------------------------------------------------------------------------------------------------
  subroutine zoltan_cb_pack_halo_node_sizes(data, num_gid_entries,  num_lid_entries, num_ids, global_ids, local_ids, sizes, ierr) 
    integer(zoltan_int), dimension(*), intent(in) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries, num_lid_entries, num_ids
    integer(zoltan_int), intent(in), dimension(*) :: global_ids,  local_ids
    integer(zoltan_int), intent(out), dimension(*) :: sizes 
    integer(zoltan_int), intent(out) :: ierr  

    integer :: i, node
    character (len = OPTION_PATH_LEN) :: filename

    ewrite(1,*) "In zoltan_cb_pack_halo_node_sizes"

    do i=1,num_ids
      node = fetch(universal_to_old_local_numbering, global_ids(i))
      sizes(i) = zz_positions%dim * real_size + &
                2 * integer_size + row_length(zoltan_global_zz_nelist, node) * integer_size + &
                1 * integer_size + key_count(old_snelist(node)) * 3 * integer_size
      if(preserve_mesh_regions) then
        sizes(i) = sizes(i) + row_length(zoltan_global_zz_nelist, node) * integer_size 
      end if
      if(preserve_columns) then
        sizes(i) = sizes(i) + integer_size
      end if
    end do

    if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/zoltan_debug/dump_halo_node_sizes")) then
       write(filename, '(A,I0,A)') 'halo_node_sizes_', getrank(),'.dat'
       open(666, file = filename)
       do i=1,num_ids
          write(666,*) sizes(i)
       end do
       close(666)
    end if

    ierr = ZOLTAN_OK
  end subroutine zoltan_cb_pack_halo_node_sizes

  subroutine zoltan_cb_pack_halo_nodes(data, num_gid_entries, num_lid_entries, num_ids, global_ids, local_ids, dest, sizes, idx, buf, ierr)  
    integer(zoltan_int), dimension(*), intent(in) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries, num_lid_entries, num_ids 
    integer(zoltan_int), intent(in), dimension(*) :: global_ids 
    integer(zoltan_int), intent(in), dimension(*) :: local_ids 
    integer(zoltan_int), intent(in), dimension(*) :: dest
    integer(zoltan_int), intent(in), dimension(*) :: sizes 
    integer(zoltan_int), intent(in), dimension(*) :: idx 
    integer(zoltan_int), intent(out), dimension(*), target :: buf 
    integer(zoltan_int), intent(out) :: ierr

    integer :: i, j, node, ratio, head, new_owner, rank
    integer, dimension(:), pointer :: current_buf

    ewrite(1,*) "In zoltan_cb_pack_halo_nodes"
    ratio = real_size / integer_size
    rank = getrank()

    do i=1,num_ids
      current_buf => buf(idx(i):idx(i)+sizes(i)/integer_size)
      head = 1
      node = fetch(universal_to_old_local_numbering, global_ids(i))
      do j=1,zz_positions%dim
        current_buf(head:head+ratio-1) = transfer(node_val(zz_positions, j, node), current_buf(head:head+ratio-1))
        head = head + ratio
      end do
      
      if(preserve_columns) then
        current_buf(head) = universal_columns(node)
        head = head + 1
      end if
      
      ! Now compute the new owner
      if (has_key(nodes_we_are_sending, node)) then
        new_owner = fetch(nodes_we_are_sending, node)
      else
        new_owner = rank
      end if

      current_buf(head) = new_owner
      head = head + 1

      current_buf(head) = row_length(zoltan_global_zz_nelist, node)
      head = head + 1

      current_buf(head:head+row_length(zoltan_global_zz_nelist, node)-1) = halo_universal_number(zz_ele_halo, row_m_ptr(zoltan_global_zz_nelist, node))
      head = head + row_length(zoltan_global_zz_nelist, node)

      if(preserve_mesh_regions) then
        ! put in the region_ids in the same amount of space as the nelist - this is complete overkill!
        current_buf(head:head+row_length(zoltan_global_zz_nelist, node)-1) = fetch(universal_element_number_to_region_id, halo_universal_number(zz_ele_halo, row_m_ptr(zoltan_global_zz_nelist, node)))
        head = head + row_length(zoltan_global_zz_nelist, node)
      end if

      current_buf(head) = key_count(old_snelist(node))
      head = head + 1
      current_buf(head:head+key_count(old_snelist(node))-1) = set2vector(old_snelist(node))
      head = head + key_count(old_snelist(node))
      current_buf(head:head+key_count(old_snelist(node))-1) = fetch(universal_surface_number_to_surface_id, set2vector(old_snelist(node)))
      head = head + key_count(old_snelist(node))
      current_buf(head:head+key_count(old_snelist(node))-1) = fetch(universal_surface_number_to_element_owner, set2vector(old_snelist(node)))
      head = head + key_count(old_snelist(node))

      !assert(head == (sizes(i)/integer_size)+1)
    end do
    ierr = ZOLTAN_OK
  end subroutine zoltan_cb_pack_halo_nodes

  subroutine zoltan_cb_unpack_halo_nodes(data, num_gid_entries, num_ids, global_ids, sizes, idx, buf, ierr)
    integer(zoltan_int), dimension(*), intent(inout) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries 
    integer(zoltan_int), intent(in) :: num_ids 
    integer(zoltan_int), intent(in), dimension(*) :: global_ids
    integer(zoltan_int), intent(in), dimension(*) :: sizes 
    integer(zoltan_int), intent(in), dimension(*) :: idx 
    integer(zoltan_int), intent(in), dimension(*), target :: buf 
    integer(zoltan_int), intent(out) :: ierr  

    integer :: i, j
    real, dimension(zz_positions%dim) :: new_coord
    integer :: head
    integer :: ratio
    integer :: new_local_number, new_owner, sz

    ewrite(1,*) "In zoltan_cb_unpack_halo_nodes"

    ratio = real_size/integer_size

    do i=1,num_ids
      new_local_number = fetch(universal_to_new_local_numbering, global_ids(i))
      new_coord = 0
      head = idx(i)
      do j=1,zz_positions%dim
        new_coord(j) = transfer(buf(head:head+ratio-1), new_coord(j))
        head = head + ratio
      end do
      call set(new_positions, new_local_number, new_coord)
      
      if(preserve_columns) then
        new_positions%mesh%columns(new_local_number) = fetch(universal_to_new_local_numbering_m1d, buf(head))
        head = head + 1
      end if

      new_owner = buf(head)
      head = head + 1

      ! record the nelist information
      sz = buf(head)
      do j=1,sz
        call insert(new_nelist(new_local_number), buf(head + j))
        call insert(new_elements, buf(head + j))
        if(preserve_mesh_regions) then
          call insert(universal_element_number_to_region_id, buf(head + j), buf(head + j + sz))
        end if
      end do
      if(preserve_mesh_regions) then
        head = head + 2*sz + 1
      else
        head = head + sz + 1
      end if
      
      ! and record who owns this in the halo
      call insert(receives(new_owner+1), global_ids(i))

      ! and record the snelist information
      sz = buf(head)
      do j=1,sz
        call insert(new_snelist(new_local_number), buf(head + j))
        call insert(universal_surface_number_to_surface_id, buf(head + j), buf(head + j + sz))
        call insert(universal_surface_number_to_element_owner, buf(head + j), buf(head + j + 2*sz))
        call insert(new_surface_elements, buf(head + j))
      end do
      head = head + 3*sz + 1
    end do

    ierr = ZOLTAN_OK
  end subroutine zoltan_cb_unpack_halo_nodes

  subroutine populate_detector_arrays(num_ids, global_ids)
    ! Plan is to first count how many detectors are in each element we're sending
    ! While doing this if we find a detector which will need to be sent, we remove
    ! it from detectors_list and add it to the end of the to_pack_detectors_list
    ! It's important it goes on the end of this list as we're relying on the 
    ! counting being done in the same order as we'll do the packing

    integer(zoltan_int), intent(in) :: num_ids 
    integer(zoltan_int), intent(in), dimension(*) :: global_ids
    
    integer :: i, j
    integer :: old_universal_element_number, old_local_element_number, new_local_element_number
    integer :: new_ele_owner
    
    type(detector_type), pointer :: detector => null(), detector_to_move => null()
    
    integer :: original_detector_list_length
    
    ewrite(1,*) "In populate_detector_arrays"
    
    ewrite(3,*) "Length of detector list BEFORE populating arrays: ", detector_list%length
    
    assert(num_ids == size(ndets_in_ele))
    
    ! loop over all the elements we're interested in
    do i=1, num_ids
       
       ! work out some details about the current element
       old_universal_element_number = global_ids(i)
       old_local_element_number = fetch(uen_to_old_local_numbering, old_universal_element_number)
       
       if (has_key(uen_to_new_local_numbering, old_universal_element_number)) then
          new_local_element_number = fetch(uen_to_new_local_numbering, old_universal_element_number)
          new_ele_owner = ele_owner(new_local_element_number, tmp_mesh, tmp_mesh%halos(tmp_mesh_nhalos))
       else
          new_ele_owner = -1
       end if
       
       if (new_ele_owner == getprocno()) then
          ndets_in_ele(i) = 0
       else
          ! start at the beginning of the detector list
          detector => detector_list%firstnode
          
          original_detector_list_length = detector_list%length
          
          ! search through all the detectors on this processor
          do j=1, original_detector_list_length
             ! check whether detector is in this element
             if (detector%element == old_local_element_number) then
                ! increment the number of detectors in that element
                ndets_in_ele(i) = ndets_in_ele(i) + 1
                
                detector_to_move => detector
                detector => detector%next

                ! Update detector%element to be universal element number
                ! so we can unpack to new element number
                detector_to_move%element = old_universal_element_number
               
                ! remove the detector from detector_list
                call remove_det_from_current_det_list(detector_list, detector_to_move)

                ! add detector to list of detectors we need to pack
                call insert(to_pack_detectors_list, detector_to_move)

                ewrite(3,*) "Detector ", detector_to_move%id_number, "(ID) removed from detector_list and added to to_pack_detectors_list."

                detector_to_move => null()

             end if
          end do
          assert(detector_list%length == (original_detector_list_length - ndets_in_ele(i)))
       end if
       
    end do

    assert(sum(ndets_in_ele(:)) == to_pack_detectors_list%length)
    
    ewrite(3,*) "Length of detector list AFTER populating arrays: ", detector_list%length
    
    ewrite(1,*) "Exiting populate_detector_arrays"
    
  end subroutine populate_detector_arrays

  subroutine zoltan_cb_pack_field_sizes(data, num_gid_entries,  num_lid_entries, num_ids, global_ids, local_ids, sizes, ierr) 
    integer(zoltan_int), dimension(*), intent(in) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries, num_lid_entries, num_ids
    integer(zoltan_int), intent(in), dimension(*) :: global_ids,  local_ids
    integer(zoltan_int), intent(out), dimension(*) :: sizes 
    integer(zoltan_int), intent(out) :: ierr  
    
    type(scalar_field), pointer :: sfield
    type(vector_field), pointer :: vfield
    type(tensor_field), pointer :: tfield
    integer :: state_no, field_no, sz, i
    character (len = OPTION_PATH_LEN) :: filename
    
    ewrite(1,*) "In zoltan_cb_pack_field_sizes"
    
    ! if there are some detectors on this process
    if (detector_list%length .GT. 0) then
       ! create two arrays, one with the number of detectors in each element to be transferred
       ! and one with the data for the detectors being transferred
       call populate_detector_arrays(num_ids, global_ids)
    end if
        
    ! The person doing this for mixed meshes in a few years time: this is one of the things
    ! you need to change. Make it look at the loc for each element.
    
    sz = 0
    
    do state_no=1,size(source_states)
       
       do field_no=1,scalar_field_count(source_states(state_no))
          sfield => extract_scalar_field(source_states(state_no), field_no)
          sz = sz + ele_loc(sfield, 1)
       end do
       
       do field_no=1,vector_field_count(source_states(state_no))
          vfield => extract_vector_field(source_states(state_no), field_no)
          sz = sz + ele_loc(vfield, 1) * vfield%dim
       end do
       
       do field_no=1,tensor_field_count(source_states(state_no))
          tfield => extract_tensor_field(source_states(state_no), field_no)
          sz = sz + ele_loc(tfield, 1) * product(tfield%dim)
       end do
       
    end do
    
    
    do i=1,num_ids    
       ! fields data + number of detectors in element + detector data +
       ! reserve space for sz scalar values and for sending old unns of the linear mesh
       sizes(i) = (sz * real_size) + real_size + (ndets_in_ele(i) * ndata_per_det * real_size) &
            + ele_loc(zz_mesh, 1) * integer_size
    end do
    
    if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/zoltan_debug/dump_field_sizes")) then
       write(filename, '(A,I0,A)') 'field_sizes_', getrank(),'.dat'
       open(666, file = filename)
       do i=1,num_ids
          write(666,*) sizes(i)
       end do
       close(666)
    end if
    
    ierr = ZOLTAN_OK
    
  end subroutine zoltan_cb_pack_field_sizes
  
  subroutine zoltan_cb_pack_fields(data, num_gid_entries, num_lid_entries, num_ids, global_ids, local_ids, dest, sizes, idx, buf, ierr)  
    integer(zoltan_int), dimension(*), intent(in) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries, num_lid_entries, num_ids 
    integer(zoltan_int), intent(in), dimension(*) :: global_ids 
    integer(zoltan_int), intent(in), dimension(*) :: local_ids 
    integer(zoltan_int), intent(in), dimension(*) :: dest
    integer(zoltan_int), intent(in), dimension(*) :: sizes 
    integer(zoltan_int), intent(in), dimension(*) :: idx 
    integer(zoltan_int), intent(out), dimension(*), target :: buf 
    integer(zoltan_int), intent(out) :: ierr
    
    real, dimension(:), allocatable :: rbuf ! easier to write reals to real memory
    integer :: rhead, i, j, state_no, field_no, loc, sz
    type(scalar_field), pointer :: sfield
    type(vector_field), pointer :: vfield
    type(tensor_field), pointer :: tfield
    integer :: old_universal_element_number, old_local_element_number, dataSize

    type(detector_type), pointer :: detector => null(), detector_to_delete => null()    

    ewrite(1,*) "In zoltan_cb_pack_fields"
    
    ewrite(3,*) "Length of detector list BEFORE packing fields: ", detector_list%length
    
    if(to_pack_detectors_list%length /= 0) then
       detector => to_pack_detectors_list%firstnode
    end if

    do i=1,num_ids
       
       ! work back number of scalar values 'sz' from the formula above in zoltan_cb_pack_field_sizes
       sz = (sizes(i) - ele_loc(zz_mesh, old_local_element_number) * integer_size) / real_size
       allocate(rbuf(sz))
       
       old_universal_element_number = global_ids(i)
       old_local_element_number = fetch(uen_to_old_local_numbering, old_universal_element_number)
       
       rhead = 1
       
       do state_no=1,size(source_states)
          do field_no=1,scalar_field_count(source_states(state_no))
             sfield => extract_scalar_field(source_states(state_no), field_no)
             loc = ele_loc(sfield, old_local_element_number)
             rbuf(rhead:rhead + loc - 1) = ele_val(sfield, old_local_element_number)
             rhead = rhead + loc
          end do
          
          do field_no=1,vector_field_count(source_states(state_no))
             vfield => extract_vector_field(source_states(state_no), field_no)
             if (index(vfield%name,"Coordinate")==len_trim(vfield%name)-9) cycle
             loc = ele_loc(vfield, old_local_element_number)
             rbuf(rhead:rhead + loc*vfield%dim - 1) = reshape(ele_val(vfield, old_local_element_number), (/loc*vfield%dim/))
             rhead = rhead + loc * vfield%dim
          end do
          
          do field_no=1,tensor_field_count(source_states(state_no))
             tfield => extract_tensor_field(source_states(state_no), field_no)
             loc = ele_loc(tfield, old_local_element_number)
             rbuf(rhead:rhead + loc*product(tfield%dim) - 1) &
                  = reshape(ele_val(tfield, old_local_element_number), (/ loc*product(tfield%dim) /))
             rhead = rhead + loc * product(tfield%dim)
          end do
          
       end do
       
       ! packing the number of detectors in the element
       rbuf(rhead) = ndets_in_ele(i)
       rhead = rhead + 1

       ! packing the detectors in that element
       do j=1,ndets_in_ele(i)
          
          ewrite(3,*) "Packing detector ", detector%id_number, "(ID) into rbuf for old_universal_element_number: ", old_universal_element_number

          ! pack the detector
          call pack_detector(detector, rbuf(rhead:rhead+ndata_per_det-1), &
               ndims, ndata_per_det)

          ! keep a pointer to the detector to delete
          detector_to_delete => detector
          ! move on our iterating pointer so it's not left on a deleted node
          detector => detector%next
          
          ! remove the detector we just packed from the to_pack list
          call remove_det_from_current_det_list(to_pack_detectors_list, detector_to_delete)          

          ! deallocate the memory of the packed detector
          call deallocate(detector_to_delete)

          rhead = rhead + ndata_per_det
       end do
       
       assert(rhead==sz+1)
       
       ! At the start, write the old unns of this element
       loc = ele_loc(zz_mesh, old_local_element_number)
       buf(idx(i):idx(i) + loc -1) = halo_universal_number(zoltan_global_zz_halo, ele_nodes(zz_mesh, old_local_element_number))
       
       ! Determine the size of the real data in integer_size units
       dataSize = sz * real_size / integer_size
       assert( dataSize==size(transfer(rbuf, buf(idx(i):idx(i)+1))) )
       ! Now we know the size, we can copy in the right amount of data.
       buf(idx(i) + loc:idx(i) + loc + dataSize - 1) = transfer(rbuf, buf(idx(i):idx(i)+1))
       
       deallocate(rbuf)
       
    end do
    
    assert(to_pack_detectors_list%length == 0)

    ewrite(3,*) "Length of detector list AFTER packing fields: ", detector_list%length
    
    ewrite(1,*) "Exiting zoltan_cb_pack_fields"
    
    ierr = ZOLTAN_OK
    
  end subroutine zoltan_cb_pack_fields
  
  subroutine zoltan_cb_unpack_fields(data, num_gid_entries, num_ids, global_ids, sizes, idx, buf, ierr)
    integer(zoltan_int), dimension(*), intent(inout) :: data 
    integer(zoltan_int), intent(in) :: num_gid_entries 
    integer(zoltan_int), intent(in) :: num_ids 
    integer(zoltan_int), intent(in), dimension(*) :: global_ids
    integer(zoltan_int), intent(in), dimension(*) :: sizes 
    integer(zoltan_int), intent(in), dimension(*) :: idx 
    integer(zoltan_int), intent(in), dimension(*), target :: buf 
    integer(zoltan_int), intent(out) :: ierr  
    
    type(element_type), pointer :: eshape
    type(scalar_field), pointer :: sfield
    type(vector_field), pointer :: vfield
    type(tensor_field), pointer :: tfield
    real, dimension(:), allocatable :: rbuf ! easier to read reals 
    integer, dimension(:), pointer :: nodes
    integer, dimension(1:ele_loc(new_positions,1)):: vertex_order
    integer :: rhead, i, state_no, field_no, loc, sz, dataSize
    integer :: old_universal_element_number, new_local_element_number
    integer :: ndetectors_in_ele, det, new_ele_owner
    type(detector_type), pointer :: detector => null()
    type(element_type), pointer :: shape => null()
    
    ewrite(1,*) "In zoltan_cb_unpack_fields"
    
    ewrite(3,*) "Length of detector list BEFORE unpacking fields: ", detector_list%length
    
    do i=1,num_ids
       
       old_universal_element_number = global_ids(i)
       new_local_element_number = fetch(uen_to_new_local_numbering, old_universal_element_number)
       
       loc = ele_loc(new_positions, new_local_element_number)
       ! work out the order of the send data, using the unns of the vertices in the send order
       ! this returns the local (within the element) node numbers of the vertices in send order
       vertex_order = local_vertex_order(buf(idx(i):idx(i) + loc -1), ele_nodes(new_positions, new_local_element_number))
       
       ! work back number of scalar values 'sz' from the formula above in zoltan_cb_pack_field_sizes
       sz = (sizes(i) - ele_loc(zz_mesh, new_local_element_number) * integer_size) / real_size
       allocate(rbuf(sz))
       ! Determine the size of the real data in integer_size units
       dataSize = sz * real_size / integer_size
       rbuf = transfer(buf(idx(i) + loc:idx(i) + loc + dataSize - 1), rbuf, sz)
       
       rhead = 1
       
       do state_no=1, size(target_states)
          
          do field_no=1,scalar_field_count(target_states(state_no))
             sfield => extract_scalar_field(target_states(state_no), field_no)
             eshape => ele_shape(sfield, new_local_element_number)
             nodes => ele_nodes(sfield, new_local_element_number)
             loc = size(nodes)
             call set(sfield, nodes(ele_local_num(vertex_order, eshape%numbering)), &
                  rbuf(rhead:rhead + loc - 1))
             rhead = rhead + loc
          end do
          
          do field_no=1,vector_field_count(target_states(state_no))
             vfield => extract_vector_field(target_states(state_no), field_no)
             if (index(vfield%name,"Coordinate")==len_trim(vfield%name)-9) cycle
             eshape => ele_shape(vfield, new_local_element_number)
             nodes => ele_nodes(vfield, new_local_element_number)
             loc = size(nodes)
             call set(vfield, nodes(ele_local_num(vertex_order, eshape%numbering)), &
                  reshape(rbuf(rhead:rhead + loc*vfield%dim - 1), (/vfield%dim, loc/)))
             rhead = rhead + loc * vfield%dim
          end do
          
          do field_no=1,tensor_field_count(target_states(state_no))
             tfield => extract_tensor_field(target_states(state_no), field_no)
             eshape => ele_shape(tfield, new_local_element_number)
             nodes => ele_nodes(tfield, new_local_element_number)
             loc = size(nodes)
             call set(tfield, nodes(ele_local_num(vertex_order, eshape%numbering)), &
                  reshape(rbuf(rhead:rhead + loc*product(tfield%dim) - 1), &
                  (/tfield%dim(1), tfield%dim(2), loc/)))
             rhead = rhead + loc * product(tfield%dim)
          end do
          
       end do
       
       ndetectors_in_ele = rbuf(rhead)
       rhead = rhead + 1
       
       ! check if there are any detectors associated with this element
       if(ndetectors_in_ele .GT. 0) then
          
          do det=1,ndetectors_in_ele
             
             old_universal_element_number = rbuf(rhead)
             
             ewrite(3,*) "Unpacking detector from rbuf for old_universal_element_number: ", old_universal_element_number
             
             if (has_key(uen_to_new_local_numbering, old_universal_element_number)) then
                new_local_element_number = fetch(uen_to_new_local_numbering, old_universal_element_number)
                new_ele_owner = ele_owner(new_local_element_number, tmp_mesh, tmp_mesh%halos(tmp_mesh_nhalos))
                
                if (new_ele_owner == getprocno()) then
                   
                   ! allocate a detector
                   shape=>ele_shape(new_positions,1)
                   call allocate(detector, ndims, local_coord_count(shape))
                   ewrite(3,*) "Successfully allocated a new detector."

                   ! unpack detector information 
                   call unpack_detector(detector, rbuf(rhead:rhead+ndata_per_det-1), &
                        ndims, ndata_per_det)
                   detector%element = new_local_element_number

                   ! update other detector data
                   call update_detector(detector, new_positions)

                   ewrite(3,*) "Unpacking ", detector%id_number, "(ID)"
                   ewrite(3,*) detector%id_number, "(ID) being given new local element number: ", new_local_element_number

                   call insert(unpacked_detectors_list, detector)
                   detector => null()
                   
                end if
             end if
             
             rhead = rhead + ndata_per_det
             
          end do
          
       end if
       
       assert(rhead==sz+1)
       
       deallocate(rbuf)
       
    end do
    
    ewrite(3,*) "Length of detector list AFTER unpacking fields: ", detector_list%length
    ewrite(3,*) "Length of unpacked_detectors_list to be merged in AFTER unpacking fields: ", unpacked_detectors_list%length
    
    ewrite(1,*) "Exiting zoltan_cb_unpack_fields"
    
    ierr = ZOLTAN_OK
    
  end subroutine zoltan_cb_unpack_fields
  
  function local_vertex_order(old_unns, new_gnns)
    ! little auxilary function that works out the ordering of the send data
    ! (which uses the old element ordering) in terms of new local (within the element)
    ! node numbers of the vertices
    ! old_unns are the unns of the vertices in the old ordering
    ! new_gnss are the global (within the local domain) node numbers in the new ordering
    integer, dimension(:), intent(in):: old_unns, new_gnns
    integer, dimension(size(old_unns)):: local_vertex_order
    integer:: i, j, gnn
    
    do i=1, size(old_unns)
      gnn = fetch(universal_to_new_local_numbering, old_unns(i))
      do j=1, size(new_gnns)
        if (new_gnns(j)==gnn) exit
      end do
      if (j>size(new_gnns)) then
        ! node in element send is not in receiving element
        ewrite(0,*) i, gnn
        ewrite(0,*) old_unns
        ewrite(0,*) new_gnns
        FLAbort("In zoltan redistribution: something went wrong in element reconstruction")
      end if
      local_vertex_order(i) = j
    end do
    
  end function local_vertex_order
  
  subroutine zoltan_drive(states, iteration, max_adapt_iteration, metric, full_metric, initialise_fields, &
    ignore_extrusion)
    type(state_type), dimension(:), intent(inout), target :: states
    integer, intent(in) :: iteration
    integer, intent(in) :: max_adapt_iteration
    ! the metric is the metric we base the quality functions on
    type(tensor_field), intent(inout), optional :: metric
    ! the full_metric is the metric we need to interpolate
    type(tensor_field), intent(inout), optional :: full_metric
    ! if present and true: don't bother redistributing fields that can be reinitialised
    logical, intent(in), optional :: initialise_fields
    ! if present and true: only redistribute horizontal meshes and fields thereon
    logical, intent(in), optional :: ignore_extrusion

    type(zoltan_struct), pointer :: zz

    logical :: changes
    integer(zoltan_int) :: num_gid_entries, num_lid_entries
    integer(zoltan_int), dimension(:), pointer :: p1_export_global_ids => null()
    integer(zoltan_int), dimension(:), pointer :: p1_export_local_ids => null()
    integer(zoltan_int), dimension(:), pointer :: p1_export_procs => null()
    integer(zoltan_int) :: p1_num_import, p1_num_export
    integer(zoltan_int), dimension(:), pointer :: p1_import_global_ids => null()
    integer(zoltan_int), dimension(:), pointer :: p1_import_local_ids => null()
    integer(zoltan_int), dimension(:), pointer :: p1_import_procs => null()
    integer, save :: dumpno = 0

    type(tensor_field) :: new_metric
    
    integer(zoltan_int), dimension(:), pointer :: p1_export_local_ids_full => null()
    integer(zoltan_int), dimension(:), pointer :: p1_export_procs_full => null()
    integer(zoltan_int) :: p1_num_export_full
    type(vector_field) :: new_positions_m1d

    ewrite(1,*) "In zoltan_drive"

    zoltan_global_migrate_extruded_mesh = option_count('/geometry/mesh/from_mesh/extrude') > 0 &
      .and. .not. present_and_true(ignore_extrusion)

    call setup_module_variables(states, iteration, max_adapt_iteration, zz)
    
    call setup_quality_module_variables(states, metric) ! this needs to be called after setup_module_variables
                                        ! (but only on the 2d mesh with 2+1d adaptivity)

    call set_zoltan_parameters(iteration, max_adapt_iteration, zz)

    call zoltan_load_balance(zz, changes, num_gid_entries, num_lid_entries, &
       & p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs, & 
       & p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs)


    if (changes .eqv. .false.) then
      ewrite(1,*) "Zoltan decided no change was necessary, exiting"
      call deallocate_zoltan_lists(p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
           & p1_export_global_ids, p1_export_local_ids, p1_export_procs)
      call cleanup_basic_module_variables(zz)
      call cleanup_quality_module_variables
      dumpno = dumpno + 1
      return
    end if

    if(zoltan_global_migrate_extruded_mesh) then
      call derive_full_export_lists(states, p1_num_export, p1_export_local_ids, p1_export_procs, &
           & p1_num_export_full, p1_export_local_ids_full, p1_export_procs_full)
    end if

    ! The general plan:
    ! Just send the nodes you own, along with a note of their dependencies
    ! The receiving process loops through all its receives and records whom
    ! it needs to receive from (the OLD owner)

    ! It builds an import list from that, then migrates again

    call are_we_keeping_or_sending_nodes(p1_num_export, p1_export_local_ids, p1_export_procs)

    ! Migrate here
    ! for nodes I am going to own
    call zoltan_migration_phase_one(zz, & 
         & p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
         & p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs)
    call deallocate_zoltan_lists(p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
         & p1_export_global_ids, p1_export_local_ids, p1_export_procs)
    ! deal with reconstructing new mesh, positions, etc. for processes who are only exporting
    call deal_with_exporters
    ! for halo nodes those nodes depend on
    call zoltan_migration_phase_two(zz)
    call deallocate_my_lists

    call reconstruct_enlist
    call reconstruct_senlist
    call reconstruct_halo(zz)
    
    if(zoltan_global_migrate_extruded_mesh) then
      new_positions_m1d = new_positions ! save a reference to the horizontal mesh you've just load balanced
      call copy(universal_to_new_local_numbering_m1d, universal_to_new_local_numbering)
      
      call cleanup_basic_module_variables(zz)
      ! don't clean up the quality variables now 
      ! (they'll be deallocated later but we don't need to use them in the vertically_structured section
      ! so we don't need to reallocate them either)
      call cleanup_other_module_variables
      
      call setup_module_variables(states, iteration, max_adapt_iteration, zz, mesh_name = topology_mesh_name)

      call set_zoltan_parameters(iteration, max_adapt_iteration, zz)
      
      call reset_zoltan_lists_full(zz, &
       & p1_num_export_full, p1_export_local_ids_full, p1_export_procs_full, &
       & p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
       & p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs)
      
      ! It builds an import list from that, then migrates again

      call are_we_keeping_or_sending_nodes(p1_num_export, p1_export_local_ids, p1_export_procs)

      ! Migrate here
      ! for nodes I am going to own
      call zoltan_migration_phase_one(zz, & 
       & p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
       & p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs)

      call deallocate_zoltan_lists(p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
           & p1_export_global_ids, p1_export_local_ids, p1_export_procs)

      call deal_with_exporters
      ! for halo nodes those nodes depend on
      call zoltan_migration_phase_two(zz)
      call deallocate_my_lists

      call reconstruct_enlist
      call reconstruct_senlist
      call reconstruct_halo(zz)

      if (.not. verify_consistent_local_element_numbering(new_positions%mesh) ) then
        ewrite(-1,*) "For the extruded mesh, the local element numbering of elements in the halo region" // &
                     "is not consistent with that of the element owner. This is likely" // & 
                     "due to a bug in zoltan. Please report" // &
                     "to the fluidity mailing list"
        FLExit("Need a consistent local element ordering in parallel")
      end if
      
      deallocate(universal_columns)
      call deallocate(universal_to_new_local_numbering_m1d)
    end if

    ! At this point, we now have the balanced linear external mesh.
    ! Get populate_state to allocate the fields and such on this new
    ! mesh.

    call initialise_transfer(zz, states, new_positions_m1d, metric, full_metric, new_metric, initialise_fields, ignore_extrusion)

    ! And now transfer the field data around.
    call transfer_fields(zz)

    call deallocate(new_positions)
    if(zoltan_global_migrate_extruded_mesh) then
      call deallocate(new_positions_m1d)
    end if

    call finalise_transfer(states, metric, full_metric, new_metric)

    call cleanup_basic_module_variables(zz)
    call cleanup_quality_module_variables
    call cleanup_other_module_variables
    
    dumpno = dumpno + 1

    ewrite(1,*) "Exiting zoltan_drive"

  end subroutine zoltan_drive

  subroutine setup_module_variables(states, iteration, max_adapt_iteration, zz, mesh_name)
    type(state_type), dimension(:), intent(inout), target :: states
    integer, intent(in) :: iteration, max_adapt_iteration
    type(zoltan_struct), pointer, intent(out) :: zz
    
    character(len=*), optional :: mesh_name
    integer :: nhalos, stat
    integer, dimension(:), allocatable :: owned_nodes
    integer :: i, j, floc, eloc
    integer, dimension(:), allocatable :: sndgln
    integer :: old_element_number, universal_element_number, face_number, universal_surface_element_number
    integer, dimension(:), allocatable :: interleaved_surface_ids
    
    !call find_mesh_to_adapt(states(1), zz_mesh)
    
    zoltan_global_zoltan_iteration = iteration
    zoltan_global_zoltan_max_adapt_iteration = max_adapt_iteration
    
    zoltan_global_max_edge_weight_on_node => extract_scalar_field(states(1), "MaxEdgeWeightOnNodes", stat) 
    if (stat == 0) then
       zoltan_global_output_edge_weights = .true.
    end if
    
    ! set quality_tolerance
    if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/element_quality_cutoff")) then
       call get_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/element_quality_cutoff", zoltan_global_quality_tolerance)
       ! check that the value is reasonable
       if (zoltan_global_quality_tolerance < 0. .or. zoltan_global_quality_tolerance > 1.) then
          FLExit("element_quality_cutoff should be between 0 and 1. Default is 0.6")
       end if
    else
       zoltan_global_quality_tolerance = 0.6
    end if

    if(present(mesh_name)) then
       zz_mesh = extract_mesh(states(1), trim(mesh_name))
    else
       zz_mesh = get_external_mesh(states)
    end if
    call incref(zz_mesh)
    if (zz_mesh%name=="CoordinateMesh") then
       zz_positions = extract_vector_field(states, "Coordinate")
    else
       zz_positions = extract_vector_field(states, trim(zz_mesh%name)//"Coordinate")
    end if
    call incref(zz_positions)
    
    zoltan_global_zz_nelist => extract_nelist(zz_mesh)
    
    zz => Zoltan_Create(halo_communicator(zz_mesh))
    
    nhalos = halo_count(zz_mesh)
    assert(nhalos == 2)
    zoltan_global_zz_halo => zz_mesh%halos(nhalos)
    
    nhalos = element_halo_count(zz_mesh)
    assert(nhalos >= 1)
    zz_ele_halo => zz_mesh%element_halos(nhalos)
    
    zoltan_global_zz_sparsity_one => get_csr_sparsity_firstorder(states, zz_mesh, zz_mesh)
    zz_sparsity_two => get_csr_sparsity_secondorder(states, zz_mesh, zz_mesh)
    
    allocate(owned_nodes(halo_nowned_nodes(zoltan_global_zz_halo)))
    call allocate(universal_to_old_local_numbering)
    call get_owned_nodes(zoltan_global_zz_halo, owned_nodes)
    do i=1,size(owned_nodes)
       call insert(universal_to_old_local_numbering, halo_universal_number(zoltan_global_zz_halo, owned_nodes(i)), owned_nodes(i))
    end do
    deallocate(owned_nodes)

    call allocate(uen_to_old_local_numbering)
    call allocate(old_local_numbering_to_uen)
    do i=1,ele_count(zz_positions)
       call insert(uen_to_old_local_numbering, halo_universal_number(zz_ele_halo, i), i)
       call insert(old_local_numbering_to_uen, i, halo_universal_number(zz_ele_halo, i))
    end do
    
    allocate(receives(halo_proc_count(zoltan_global_zz_halo)))
    do i=1,size(receives)
       call allocate(receives(i))
    end do

    ! set up old_snelist
    allocate(old_snelist(node_count(zz_positions)))
    call allocate(old_snelist)
    call allocate(universal_surface_number_to_surface_id)
    call allocate(universal_surface_number_to_element_owner)
    allocate(interleaved_surface_ids(surface_element_count(zz_positions)))
    call interleave_surface_ids(zz_mesh, interleaved_surface_ids, max_coplanar_id)

    ! this is another thing that needs to be generalised for mixed meshes
    floc = face_loc(zz_positions, 1)
    eloc = ele_loc(zz_positions, 1)
    allocate(sndgln(surface_element_count(zz_positions) * floc))
    call getsndgln(zz_mesh, sndgln)
    
    do i=1,surface_element_count(zz_positions)
       old_element_number = face_ele(zz_positions, i)
       universal_element_number = halo_universal_number(zz_ele_halo, old_element_number)
       face_number = local_face_number(zz_positions, i)
       universal_surface_element_number = (universal_element_number-1)*eloc + face_number
       
       call insert(universal_surface_number_to_surface_id, universal_surface_element_number, interleaved_surface_ids(i))
       call insert(universal_surface_number_to_element_owner, universal_surface_element_number, universal_element_number)
       
       do j=(i-1)*floc+1,i*floc
          call insert(old_snelist(sndgln(j)), universal_surface_element_number)
       end do
    end do
    
    deallocate(sndgln)
    deallocate(interleaved_surface_ids)
    
    preserve_mesh_regions = associated(zz_mesh%region_ids)
    ! this deals with the case where some processors have no elements
    ! (i.e. when used to flredecomp from 1 to many processors)
    call allor(preserve_mesh_regions) 
    if(preserve_mesh_regions) then
       call allocate(universal_element_number_to_region_id)
       do i = 1, element_count(zz_positions)
          universal_element_number = halo_universal_number(zz_ele_halo, i)
          call insert(universal_element_number_to_region_id, universal_element_number, zz_positions%mesh%region_ids(i))
       end do
    end if
    
  end subroutine setup_module_variables

  subroutine setup_quality_module_variables(states, metric)
    type(state_type), dimension(:), intent(inout), target :: states
    ! the metric is the metric we base the quality functions on
    type(tensor_field), intent(in), optional :: metric
    
    integer :: i, j
    type(mesh_type) :: pwc_mesh
    integer, dimension(:), pointer :: eles
    real :: qual
    type(mesh_type), pointer :: full_mesh
    
    ! And the element quality measure
    if (present(metric)) then
       call element_quality_p0(zz_positions, metric, zoltan_global_element_quality)
    else
       pwc_mesh = piecewise_constant_mesh(zz_mesh, "PWCMesh")
       call allocate(zoltan_global_element_quality, pwc_mesh, "ElementQuality", field_type=FIELD_TYPE_CONSTANT)
       call set(zoltan_global_element_quality, 1.0)
       call deallocate(pwc_mesh)
    end if
    
    call allocate(node_quality, zz_mesh, "NodeQuality")
    call zero(node_quality)
    do i=1,node_count(node_quality)
       eles => row_m_ptr(zoltan_global_zz_nelist, i)  
       qual = 1.0
       do j=1,size(eles)
          qual = min(qual, node_val(zoltan_global_element_quality, eles(j)))
       end do
       call set(node_quality, i, qual)
    end do
    call halo_update(node_quality)

    if(zoltan_global_migrate_extruded_mesh) then
       full_mesh => extract_mesh(states(1), trim(topology_mesh_name))
       call create_columns_sparsity(zoltan_global_columns_sparsity, full_mesh)
    end if
    
  end subroutine setup_quality_module_variables

  subroutine set_zoltan_parameters(iteration, max_adapt_iteration, zz)
    integer, intent(in) :: iteration, max_adapt_iteration
    type(zoltan_struct), pointer, intent(in) :: zz    

    integer(zoltan_int) :: ierr
    character (len = FIELD_NAME_LEN) :: method, graph_checking_level
    
    if (debug_level()>1) then
       ierr = Zoltan_Set_Param(zz, "DEBUG_LEVEL", "1"); assert(ierr == ZOLTAN_OK)
    else         
       ierr = Zoltan_Set_Param(zz, "DEBUG_LEVEL", "0"); assert(ierr == ZOLTAN_OK)
    end if

    if (iteration /= max_adapt_iteration) then
        ! ignore large load imbalances when on intermediate adapt iterations
        ierr = Zoltan_Set_Param(zz, "IMBALANCE_TOL", "1.5"); assert(ierr == ZOLTAN_OK)
    else 
        ierr = Zoltan_Set_Param(zz, "IMBALANCE_TOL", "1.075"); assert(ierr == ZOLTAN_OK)
    end if

    ! If we are not an active process, then let's set the number of local parts to be zero
    if (no_active_processes > 0) then
       if (getprocno() > no_active_processes) then
          ierr = Zoltan_Set_Param(zz, "NUM_LOCAL_PARTS", "0"); assert(ierr == ZOLTAN_OK)
       else
          ierr = Zoltan_Set_Param(zz, "NUM_LOCAL_PARTS", "1"); assert(ierr == ZOLTAN_OK)
       end if
       ierr = Zoltan_set_Param(zz, "NUM_GLOBAL_PARTS", int2str(no_active_processes)); assert(ierr == ZOLTAN_OK)
    end if
    
    if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/partitioner")) then
       
       if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/partitioner/metis"))  then
          ierr = Zoltan_Set_Param(zz, "LB_METHOD", "GRAPH"); assert(ierr == ZOLTAN_OK)
          ierr = Zoltan_Set_Param(zz, "GRAPH_PACKAGE", "PARMETIS"); assert(ierr == ZOLTAN_OK)
          ! turn off graph checking unless debugging, this was filling the error file with Zoltan warnings
          if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/zoltan_debug/graph_checking")) then
             call get_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/zoltan_debug/graph_checking", graph_checking_level)
             ierr = Zoltan_Set_Param(zz, "CHECK_GRAPH", trim(graph_checking_level)); assert(ierr == ZOLTAN_OK)
          else
             ierr = Zoltan_Set_Param(zz, "CHECK_GRAPH", "0"); assert(ierr == ZOLTAN_OK)
          end if
       end if
       
       if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/partitioner/zoltan")) then
          
          call get_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/partitioner/zoltan/method", method)
          
          if (trim(method) == "graph") then
             ierr = Zoltan_Set_Param(zz, "LB_METHOD", "GRAPH"); assert(ierr == ZOLTAN_OK)
             ierr = Zoltan_Set_Param(zz, "GRAPH_PACKAGE", "PHG"); assert(ierr == ZOLTAN_OK)
          else if (trim(method) == "hypergraph") then
             ierr = Zoltan_Set_Param(zz, "LB_METHOD", "HYPERGRAPH"); assert(ierr == ZOLTAN_OK)
             ierr = Zoltan_Set_Param(zz, "HYPERGRAPH_PACKAGE", "PHG"); assert(ierr == ZOLTAN_OK)
          end if
             
       end if
       
       if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/partitioner/scotch")) then
          ierr = Zoltan_Set_Param(zz, "LB_METHOD", "GRAPH"); assert(ierr == ZOLTAN_OK)
          ierr = Zoltan_Set_Param(zz, "GRAPH_PACKAGE", "SCOTCH"); assert(ierr == ZOLTAN_OK)
          ! Probably not going to want graph checking unless debugging
          if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/zoltan_debug/graph_checking")) then
             call get_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/zoltan_debug/graph_checking", graph_checking_level)
             ierr = Zoltan_Set_Param(zz, "CHECK_GRAPH", trim(graph_checking_level)); assert(ierr == ZOLTAN_OK)
          else
             ierr = Zoltan_Set_Param(zz, "CHECK_GRAPH", "0"); assert(ierr == ZOLTAN_OK)
          end if
       end if
       
    else
       ! Use the Zoltan graph partitioner by default
       ierr = Zoltan_Set_Param(zz, "LB_METHOD", "GRAPH"); assert(ierr == ZOLTAN_OK)
       ierr = Zoltan_Set_Param(zz, "GRAPH_PACKAGE", "PHG"); assert(ierr == ZOLTAN_OK)
    end if

    ! Choose the appropriate partitioning method based on the current adapt iteration
    ! Idea is to do repartitioning on intermediate adapts but a clean partition on the last
    ! iteration to produce a load balanced partitioning
    if (iteration == max_adapt_iteration) then
       ierr = Zoltan_Set_Param(zz, "LB_APPROACH", "PARTITION"); assert(ierr == ZOLTAN_OK)
       if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/partitioner/metis"))  then
          ! chosen to match what Sam uses
          ierr = Zoltan_Set_Param(zz, "PARMETIS_METHOD", "PartKway"); assert(ierr == ZOLTAN_OK)
       end if
    else
       ierr = Zoltan_Set_Param(zz, "LB_APPROACH", "REPARTITION"); assert(ierr == ZOLTAN_OK)
       if (have_option("/mesh_adaptivity/hr_adaptivity/zoltan_options/partitioner/metis"))  then
          ! chosen to match what Sam uses
          ierr = Zoltan_Set_Param(zz, "PARMETIS_METHOD", "AdaptiveRepart"); assert(ierr == ZOLTAN_OK)
          ierr = Zoltan_Set_Param(zz, "PARMETIS_ITR", "100000.0"); assert(ierr == ZOLTAN_OK)
       end if
    end if

    ierr = Zoltan_Set_Param(zz, "NUM_GID_ENTRIES", "1"); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Param(zz, "NUM_LID_ENTRIES", "1"); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Param(zz, "OBJ_WEIGHT_DIM", "1"); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Param(zz, "EDGE_WEIGHT_DIM", "1"); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Param(zz, "RETURN_LISTS", "ALL"); assert(ierr == ZOLTAN_OK)
    
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_NUM_OBJ_FN_TYPE, zoltan_cb_owned_node_count);      assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_OBJ_LIST_FN_TYPE, zoltan_cb_get_owned_nodes);      assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_NUM_EDGES_MULTI_FN_TYPE, zoltan_cb_get_num_edges); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_EDGE_LIST_MULTI_FN_TYPE, zoltan_cb_get_edge_list); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_OBJ_SIZE_MULTI_FN_TYPE, zoltan_cb_pack_node_sizes); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_PACK_OBJ_MULTI_FN_TYPE, zoltan_cb_pack_nodes); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_UNPACK_OBJ_MULTI_FN_TYPE, zoltan_cb_unpack_nodes); assert(ierr == ZOLTAN_OK)
    
  end subroutine set_zoltan_parameters

  subroutine deallocate_zoltan_lists(p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
       & p1_export_global_ids, p1_export_local_ids, p1_export_procs)
    
    integer(zoltan_int), dimension(:), pointer, intent(inout) :: p1_import_global_ids
    integer(zoltan_int), dimension(:), pointer, intent(inout) :: p1_import_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(inout) :: p1_import_procs    
    integer(zoltan_int), dimension(:), pointer, intent(inout) :: p1_export_global_ids
    integer(zoltan_int), dimension(:), pointer, intent(inout) :: p1_export_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(inout) :: p1_export_procs

    integer(zoltan_int) :: ierr

    ! deallocates the memory which was allocated in Zoltan
    ierr = Zoltan_LB_Free_Data(p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
         & p1_export_global_ids, p1_export_local_ids, p1_export_procs)
    
    assert(ierr == ZOLTAN_OK)
  end subroutine deallocate_zoltan_lists

  subroutine cleanup_basic_module_variables(zz)
    ! This routine deallocates everything that is guaranteed to be allocated
    ! regardless of whether Zoltan actually wants to change anything or not.
    ! (except for the quality functions)
    type(zoltan_struct), pointer, intent(inout) :: zz    

    call deallocate(universal_surface_number_to_surface_id)
    call deallocate(universal_surface_number_to_element_owner)
    call deallocate(old_snelist)
    deallocate(old_snelist)
    call deallocate(receives)
    deallocate(receives)
    
    call deallocate(universal_to_old_local_numbering)
    call deallocate(uen_to_old_local_numbering)
    call deallocate(old_local_numbering_to_uen)
    
    new_positions%refcount => null()
    
    call deallocate(zz_mesh)
    call deallocate(zz_positions)
    zoltan_global_zz_sparsity_one => null()
    zz_sparsity_two => null()
    zoltan_global_zz_halo => null()
    zz_ele_halo => null()
    call Zoltan_Destroy(zz)
    
    preserve_columns = .false.
  end subroutine cleanup_basic_module_variables
  
  subroutine cleanup_quality_module_variables
    ! This routine deallocates the module quality fields.
    call deallocate(zoltan_global_element_quality)
    call deallocate(node_quality)
    if(zoltan_global_migrate_extruded_mesh) then
       call deallocate(zoltan_global_columns_sparsity)
    end if
  end subroutine cleanup_quality_module_variables

  subroutine cleanup_other_module_variables
    call deallocate(nodes_we_are_sending)
    call deallocate(nodes_we_are_keeping)
    call deallocate(universal_to_new_local_numbering)
    call deallocate(new_nodes)
    call deallocate(uen_to_new_local_numbering)
  end subroutine cleanup_other_module_variables

  subroutine zoltan_load_balance(zz, changes, num_gid_entries, num_lid_entries, &
       & p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
       & p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs)

    type(zoltan_struct), pointer, intent(in) :: zz    
    logical, intent(out) :: changes    
    
    integer(zoltan_int), intent(out) :: num_gid_entries, num_lid_entries
    integer(zoltan_int), intent(out) :: p1_num_import
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_import_global_ids
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_import_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_import_procs
    integer(zoltan_int), intent(out) :: p1_num_export
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_export_global_ids 
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_export_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_export_procs

    
    integer(zoltan_int) :: ierr
    integer :: i, node
      
    ! import_* aren't used because we set RETURN_LISTS to be only EXPORT
    ierr = Zoltan_LB_Balance(zz, changes, num_gid_entries, num_lid_entries, p1_num_import, p1_import_global_ids, &
         &    p1_import_local_ids, p1_import_procs, p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs)
    assert(ierr == ZOLTAN_OK)
    
    do i=1,p1_num_export
       node = p1_export_local_ids(i)
       assert(node_owned(zoltan_global_zz_halo, node))
    end do
  end subroutine zoltan_load_balance

  subroutine derive_full_export_lists(states, p1_num_export, p1_export_local_ids, p1_export_procs, &
       & p1_num_export_full, p1_export_local_ids_full, p1_export_procs_full)
    type(state_type), dimension(:), intent(inout), target :: states
    integer(zoltan_int), intent(in) :: p1_num_export
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_procs

    integer(zoltan_int), intent(out) :: p1_num_export_full    
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_export_local_ids_full
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_export_procs_full

    type(mesh_type), pointer :: full_mesh
    integer :: i, column
    integer, dimension(:), pointer :: column_nodes
    
    integer :: last_full_node
    logical :: lpreserve_columns
    
    ewrite(1,*) 'in derive_full_export_lists'
    
    p1_num_export_full = 0
    do i = 1, p1_num_export
       column = p1_export_local_ids(i)
       p1_num_export_full = p1_num_export_full + row_length(zoltan_global_columns_sparsity, column)
    end do
      
    allocate(p1_export_local_ids_full(p1_num_export_full))
    p1_export_local_ids_full = 0
    allocate(p1_export_procs_full(p1_num_export_full))
    p1_export_procs_full = -1
    
    last_full_node = 1
    do i = 1, p1_num_export
       column = p1_export_local_ids(i)
       column_nodes => row_m_ptr(zoltan_global_columns_sparsity, column)
       
       p1_export_local_ids_full(last_full_node:last_full_node+size(column_nodes)-1) = column_nodes
       p1_export_procs_full(last_full_node:last_full_node+size(column_nodes)-1) = p1_export_procs(i)
       
       last_full_node = last_full_node + size(column_nodes)
    end do
    assert(last_full_node-1==p1_num_export_full)
    assert(all(p1_export_local_ids_full>0))
    assert(all(p1_export_procs_full>-1))
    
    full_mesh => extract_mesh(states(1), trim(topology_mesh_name))
    lpreserve_columns = associated(full_mesh%columns)
    call allor(lpreserve_columns)
    if(lpreserve_columns) then
       allocate(universal_columns(node_count(full_mesh)))
       universal_columns = halo_universal_numbers(zoltan_global_zz_halo, full_mesh%columns)
    end if
    
    ewrite(1,*) 'exiting derive_full_export_lists'
    
  end subroutine derive_full_export_lists

  subroutine reset_zoltan_lists_full(zz, &
       & p1_num_export_full, p1_export_local_ids_full, p1_export_procs_full, &
       & p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
       & p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs)

    type(zoltan_struct), pointer, intent(in) :: zz    

    integer(zoltan_int), intent(in) :: p1_num_export_full
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_local_ids_full
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_procs_full

    integer(zoltan_int), intent(out) :: p1_num_import
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_import_global_ids
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_import_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_import_procs
    integer(zoltan_int), intent(out) :: p1_num_export
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_export_global_ids
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_export_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(out) :: p1_export_procs

    integer :: i, ierr
    
    ewrite(1,*) 'in reset_zoltan_lists_full'
    
    p1_num_export = p1_num_export_full
    
    p1_export_local_ids => p1_export_local_ids_full
    p1_export_procs => p1_export_procs_full
    
    allocate(p1_export_global_ids(p1_num_export))
    p1_export_global_ids = 0
    
    do i=1,p1_num_export
       p1_export_global_ids(i) = halo_universal_number(zoltan_global_zz_halo, p1_export_local_ids(i))
    end do
    assert(all(p1_export_global_ids>0))
    
    p1_num_import = 0
    p1_import_local_ids => null()
    p1_import_procs => null()
    p1_import_global_ids => null()
    
    ierr = Zoltan_Compute_Destinations(zz, &
         & p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs, &
         & p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs)
    assert(ierr == ZOLTAN_OK)
    
    preserve_columns = associated(zz_positions%mesh%columns)
    call allor(preserve_columns)
    
    ewrite(1,*) 'exiting reset_zoltan_lists_full'
    
  end subroutine reset_zoltan_lists_full


  subroutine are_we_keeping_or_sending_nodes(p1_num_export, p1_export_local_ids, p1_export_procs)
    integer(zoltan_int), intent(in) :: p1_num_export
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_procs

    integer :: node, i
    integer, dimension(halo_nowned_nodes(zoltan_global_zz_halo)) :: owned_nodes
    
    call allocate(nodes_we_are_sending)
    call allocate(nodes_we_are_keeping)
    
    do i=1,p1_num_export
       call insert(nodes_we_are_sending, p1_export_local_ids(i), p1_export_procs(i))
    end do
    
    call get_owned_nodes(zoltan_global_zz_halo, owned_nodes)
    do i=1,size(owned_nodes)
       node = owned_nodes(i)
       if (.not. has_key(nodes_we_are_sending, node)) then
          call insert(nodes_we_are_keeping, node)
       end if
    end do
  end subroutine are_we_keeping_or_sending_nodes

  subroutine zoltan_migration_phase_one(zz, &
       & p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
       & p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs)

    type(zoltan_struct), pointer, intent(in) :: zz    

    integer(zoltan_int), intent(in) :: p1_num_import
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_import_global_ids
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_import_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_import_procs
    integer(zoltan_int), intent(in) :: p1_num_export
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_global_ids
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_local_ids
    integer(zoltan_int), dimension(:), pointer, intent(in) :: p1_export_procs


    integer(zoltan_int) :: ierr
    integer(zoltan_int), dimension(:), pointer :: import_to_part, export_to_part
    
    ewrite(1,*) "In zoltan_migration_phase_one; objects to import: ", p1_num_import
    ewrite(1,*) "In zoltan_migration_phase_one; objects to export: ", p1_num_export
    import_to_part => null()
    export_to_part => null()

    ierr = Zoltan_Migrate(zz, p1_num_import, p1_import_global_ids, p1_import_local_ids, p1_import_procs, &
         & import_to_part, p1_num_export, p1_export_global_ids, p1_export_local_ids, p1_export_procs, export_to_part) 
    assert(ierr == ZOLTAN_OK)
  end subroutine zoltan_migration_phase_one

  subroutine deal_with_exporters
    ! The unpack routine is the ones that do most of the heavy lifting
    ! in reconstructing the new mesh, positions, etc.
    ! But they don't get called if a process is only an exporter!
    ! So we need to reconstruct the positions and nelist for the
    ! nodes we own, and mark the request for the halos in the same way.
    ! (The owner of one of our halo nodes might have changed, and we
    ! don't know that, or who owns it, so we have to ask the old owner,
    ! i.e. participate in the phase_two migration).
    integer :: i, j, old_local_number, new_local_number
    integer, dimension(:), pointer :: neighbours
    integer :: universal_number
    type(integer_set) :: halo_nodes_we_need_to_know_about
    type(integer_hash_table) :: universal_number_to_old_owner
    logical :: changed
    integer :: old_owner, new_owner
    type(mesh_type) :: new_mesh
    type(integer_set) :: halo_nodes_we_currently_own
    integer :: rank
    
    if (associated(new_positions%refcount)) return
    ewrite(1,*) "In deal_with_exports"

    call allocate(new_nodes)
    
    ! Need to allocate new_nodes, new_elements, new_positions, new_nelist, universal_to_new_local_numbering
    do i=1,key_count(nodes_we_are_keeping)
       old_local_number = fetch(nodes_we_are_keeping, i)
       call insert(new_nodes, halo_universal_number(zoltan_global_zz_halo, old_local_number), changed=changed)
    end do
    
    call allocate(halo_nodes_we_need_to_know_about)
    call allocate(halo_nodes_we_currently_own)
    call allocate(universal_number_to_old_owner)
    
    rank = getrank()
    
    do i=1,key_count(nodes_we_are_keeping)
       old_local_number = fetch(nodes_we_are_keeping, i)
       neighbours => row_m_ptr(zz_sparsity_two, old_local_number)
       do j=1,size(neighbours)
          universal_number = halo_universal_number(zoltan_global_zz_halo, neighbours(j))
          call insert(new_nodes, universal_number, changed=changed)
          if (changed) then
             old_owner = halo_node_owner(zoltan_global_zz_halo, neighbours(j)) - 1
             if (old_owner == rank) then
                call insert(halo_nodes_we_currently_own, neighbours(j))
             else
                call insert(halo_nodes_we_need_to_know_about, universal_number)
             end if
             call insert(universal_number_to_old_owner, universal_number, old_owner)
          end if
       end do
    end do

    ! We need to process these too -- nodes we own now, but will
    ! not own later, and will become our halo nodes.
    do i=1,key_count(halo_nodes_we_currently_own)
       universal_number = halo_universal_number(zoltan_global_zz_halo, fetch(halo_nodes_we_currently_own, i))
       call insert(new_nodes, universal_number)
    end do

    call invert_set(new_nodes, universal_to_new_local_numbering)
    call allocate(new_mesh, key_count(new_nodes), 0, zz_mesh%shape, trim(zz_mesh%name))
    new_mesh%option_path = zz_mesh%option_path
    if(preserve_columns) then
       allocate(new_mesh%columns(key_count(new_nodes)))
    end if
    call allocate(new_positions, zz_positions%dim, new_mesh, trim(zz_positions%name))
    new_positions%option_path = zz_positions%option_path
    call deallocate(new_mesh)
    allocate(new_snelist(key_count(new_nodes)))
    call allocate(new_snelist)
    call allocate(new_surface_elements)
    
    allocate(new_nelist(key_count(new_nodes)))
    do i=1,key_count(new_nodes)
       call allocate(new_nelist(i))
    end do
    call allocate(new_elements)
    
    do i=1,key_count(nodes_we_are_keeping)
       old_local_number = fetch(nodes_we_are_keeping, i)
       universal_number = halo_universal_number(zoltan_global_zz_halo, old_local_number)
       new_local_number = fetch(universal_to_new_local_numbering, universal_number)
       call set(new_positions, new_local_number, node_val(zz_positions, old_local_number))
       
       if(preserve_columns) then
          new_positions%mesh%columns(new_local_number) = fetch(universal_to_new_local_numbering_m1d, &
               universal_columns(old_local_number))
       end if
       
       neighbours => row_m_ptr(zoltan_global_zz_nelist, old_local_number)
       do j=1,size(neighbours)
          call insert(new_nelist(new_local_number), halo_universal_number(zz_ele_halo, neighbours(j)))
          call insert(new_elements, halo_universal_number(zz_ele_halo, neighbours(j)))
          ! don't need to add anything to universal_element_number_to_region_id because we already have it
       end do

       ! and record the snelist information
       do j=1,key_count(old_snelist(old_local_number))
          call insert(new_snelist(new_local_number), fetch(old_snelist(old_local_number), j))
          call insert(new_surface_elements, fetch(old_snelist(old_local_number), j))
          ! we don't need to add anything to the universal_surface_number_to_surface_id because we already have it
       end do
    end do

    ! Set the positions and nelist of halo_nodes_we_currently_own
    do i=1,key_count(halo_nodes_we_currently_own)
       old_local_number = fetch(halo_nodes_we_currently_own, i)
       universal_number = halo_universal_number(zoltan_global_zz_halo, old_local_number)
       new_local_number = fetch(universal_to_new_local_numbering, universal_number)
       call set(new_positions, new_local_number, node_val(zz_positions, old_local_number))
       
       if(preserve_columns) then
          new_positions%mesh%columns(new_local_number) = fetch(universal_to_new_local_numbering_m1d, &
               universal_columns(old_local_number))
       end if

       neighbours => row_m_ptr(zoltan_global_zz_nelist, old_local_number)
       do j=1,size(neighbours)
          call insert(new_nelist(new_local_number), halo_universal_number(zz_ele_halo, neighbours(j)))
          call insert(new_elements, halo_universal_number(zz_ele_halo, neighbours(j)))
          ! don't need to add anything to universal_element_number_to_region_id because we already have it
       end do

       new_owner = fetch(nodes_we_are_sending, old_local_number)
       call insert(receives(new_owner+1), universal_number)
       
       ! and record the snelist information
       do j=1,key_count(old_snelist(old_local_number))
          call insert(new_snelist(new_local_number), fetch(old_snelist(old_local_number), j))
          call insert(new_surface_elements, fetch(old_snelist(old_local_number), j))
       end do
    end do
    call deallocate(halo_nodes_we_currently_own)
    
    my_num_import = key_count(halo_nodes_we_need_to_know_about)
    allocate(my_import_procs(my_num_import))
    allocate(my_import_global_ids(my_num_import))
    do i=1,my_num_import
       universal_number = fetch(halo_nodes_we_need_to_know_about, i)
       my_import_global_ids(i) = universal_number
       my_import_procs(i) = fetch(universal_number_to_old_owner, universal_number)
       assert(my_import_procs(i) /= getrank())
    end do

    call deallocate(halo_nodes_we_need_to_know_about)
    call deallocate(universal_number_to_old_owner)

  end subroutine deal_with_exporters

  subroutine zoltan_migration_phase_two(zz)
    type(zoltan_struct), pointer, intent(in) :: zz    

    integer(zoltan_int) :: ierr
    integer(zoltan_int), dimension(:), pointer :: import_to_part, export_to_part, export_procs
    integer(zoltan_int), dimension(:), pointer :: export_global_ids, export_local_ids, import_local_ids
    integer(zoltan_int) :: num_export

    ! Register the new callback functions for packing and unpacking
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_OBJ_SIZE_MULTI_FN_TYPE, zoltan_cb_pack_halo_node_sizes); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_PACK_OBJ_MULTI_FN_TYPE, zoltan_cb_pack_halo_nodes); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_UNPACK_OBJ_MULTI_FN_TYPE, zoltan_cb_unpack_halo_nodes); assert(ierr == ZOLTAN_OK)

    import_to_part => null()
    export_to_part => null()
    export_global_ids => null()
    export_local_ids => null()
    export_procs => null()
    num_export = -1

    if (.not. associated(my_import_procs)) then
       ! We have nothing else to receive, but we still need to take part in
       ! the communication. Set num_import to 0
       my_num_import = 0
       allocate(my_import_global_ids(0))
       allocate(my_import_procs(0))
    end if
    ewrite(1,*) "In zoltan_migration_phase_two; objects to import: ", my_num_import
    
    ! We should be able to do:
    ! import_local_ids => null()
    ! from my reading of the Zoltan docs. But it actually doesn't appear to be the case.
    allocate(import_local_ids(my_num_import))
    if (my_num_import > 0) then
       import_local_ids = 666
    end if

    assert(associated(my_import_global_ids))
    assert(associated(import_local_ids))
    assert(associated(my_import_procs))
    assert(all(my_import_procs >= 0))
    assert(all(my_import_procs < getnprocs()))
    ierr = Zoltan_Compute_Destinations(zz, my_num_import, my_import_global_ids, import_local_ids, my_import_procs, &
         & num_export, export_global_ids, export_local_ids, export_procs)
    assert(ierr == ZOLTAN_OK)
    ewrite(1,*) "In zoltan_migration_phase_two; objects to export: ", num_export

    ierr = Zoltan_Migrate(zz, my_num_import, my_import_global_ids, import_local_ids, my_import_procs, &
         & import_to_part, num_export, export_global_ids, export_local_ids, export_procs, export_to_part) 
    assert(ierr == ZOLTAN_OK)

    ierr = Zoltan_LB_Free_Part(export_global_ids, export_local_ids, export_procs, export_to_part)
    assert(ierr == ZOLTAN_OK)
    
    deallocate(import_local_ids)
  end subroutine zoltan_migration_phase_two

  subroutine deallocate_my_lists
    deallocate(my_import_global_ids)
    deallocate(my_import_procs)
  end subroutine deallocate_my_lists

  subroutine reconstruct_enlist
    type(csr_sparsity):: eelist
    type(mesh_type):: temporary_mesh
    type(integer_set), dimension(key_count(new_elements)) :: enlists
    integer :: i, j, k, expected_loc, full_elements, connected_elements
    integer :: universal_number, new_local_number
    type(integer_set) :: new_elements_we_actually_have
    integer, dimension(:), pointer:: neigh
    
    ewrite(1,*) "In reconstruct_enlist"
    
    ! new_elements currently contains the universal numbers of elements
    ! we don't fully have and won't be in the final mesh.
    ! So uen_to_new_local_numbering here is just temporary -- we will
    ! construct the proper version later.
    call invert_set(new_elements, uen_to_new_local_numbering)
    
    do i=1,key_count(new_elements)
       call allocate(enlists(i))
    end do
    
    ! Invert the nelists to give the enlists
    
    do i=1,key_count(new_nodes)
       do j=1,key_count(new_nelist(i))
          universal_number = fetch(new_nelist(i), j)
          new_local_number = fetch(uen_to_new_local_numbering, universal_number)
          call insert(enlists(new_local_number), i)
       end do
    end do

    call deallocate(uen_to_new_local_numbering)
    
    ! Now, some of these will be degenerate, because the halo nodes will refer
    ! to elements we don't know about. We can tell these apart because they
    ! are incomplete.
    
    full_elements = 0
    ! For mixed meshes, this should be the loc of the positions mesh
    ! note we know the universal number -- fetch(new_elements, i)
    ! However, it's constant for now
    expected_loc = zz_mesh%shape%loc
    
    ! First, count how many we have
    do i=1,key_count(new_elements)
       if (key_count(enlists(i)) == expected_loc) then
          full_elements = full_elements + 1
          !        else
          !          write(0,*) "Element ", fetch(new_elements, i), " is degenerate. Dropping .."
       end if
    end do

    ewrite(2,*) "Found ", key_count(new_elements), " possible new elements."
    ewrite(2,*) "Of these, ", full_elements, " are non-degenerate."

    ! Now we construct a temporary mesh of full elements
    ! This mesh is temporary because we also want to drop elements that are not connected
    ! to any other elements
      
    call allocate(temporary_mesh, node_count(new_positions), full_elements, new_positions%mesh%shape, &
         name="TemporaryZoltanMesh")
    j = 1
    do i=1,key_count(new_elements)
       if (key_count(enlists(i)) == expected_loc) then
          call set_ele_nodes(temporary_mesh, j, set2vector(enlists(i)))
          j = j + 1
       end if
    end do
    
    call add_nelist(temporary_mesh)
    call extract_lists(temporary_mesh, eelist=eelist)
    
    connected_elements=0
    do i=1, element_count(temporary_mesh)
       neigh => row_m_ptr(eelist, i)
       if (any(neigh>0)) connected_elements = connected_elements + 1
    end do
    
    ewrite(2,*) "Of the ", full_elements, " full elements, ", connected_elements, " are connected."
    
    call allocate(new_elements_we_actually_have)
    call allocate(uen_to_new_local_numbering)
    new_positions%mesh%elements = connected_elements
    deallocate(new_positions%mesh%ndglno)
    allocate(new_positions%mesh%ndglno(connected_elements * expected_loc))
#ifdef HAVE_MEMORY_STATS
    call register_allocation("mesh_type", "integer", connected_elements * expected_loc, name=new_positions%mesh%name)
#endif
    if(preserve_mesh_regions) then
       allocate(new_positions%mesh%region_ids(connected_elements))
    end if
      
    j = 1 ! index connected full elements (new local element numbering)
    k = 1 ! indexes full elements
    do i=1, key_count(new_elements)
       if (key_count(enlists(i)) == expected_loc) then
          ! only for full elements
          neigh => row_m_ptr(eelist, k)
          if (any(neigh>0)) then
             ! of these only the connected elements
             universal_number = fetch(new_elements, i)
             call set_ele_nodes(new_positions%mesh, j, set2vector(enlists(i)))
             call insert(new_elements_we_actually_have, universal_number)
             call insert(uen_to_new_local_numbering, universal_number, j)
             if(preserve_mesh_regions) then
                new_positions%mesh%region_ids(j) = fetch(universal_element_number_to_region_id, universal_number)
             end if
             j = j + 1
          end if
          k = k + 1
       end if
    end do
        
    assert( k==full_elements+1 )
    assert( j==connected_elements+1 )

    do i=1,size(enlists)
       call deallocate(enlists(i))
    end do
        
    call deallocate(temporary_mesh)
    call deallocate(new_nelist)
    deallocate(new_nelist)
      
    ! New elements is no longer valid, as we have lost the degenerate elements
    call deallocate(new_elements)
    new_elements = new_elements_we_actually_have
    
    call deallocate(universal_element_number_to_region_id)
    
    ! Bingo! Our mesh has an enlist.
    ewrite(1,*) "Exiting reconstruct_enlist"
    
  end subroutine reconstruct_enlist
    
  subroutine reconstruct_senlist
    type(integer_set), dimension(key_count(new_surface_elements)) :: senlists
    integer :: i, j, expected_loc, full_elements
    integer :: universal_number, new_local_number
    type(integer_hash_table) :: universal_surface_element_to_local_numbering
    integer, dimension(:), allocatable, target :: sndgln, surface_ids, element_owners
    type(csr_sparsity), pointer :: nnlist
    
    logical, dimension(key_count(new_surface_elements)) :: keep_surface_element
    integer :: universal_element_number
    
    ewrite(1,*) "In reconstruct_senlist"
    
    ! new_surface_elements currently contains the universal numbers of surface elements
    ! we don't fully have and won't be in the final mesh.
    ! So universal_surface_element_to_local_numbering here is just temporary.
    call invert_set(new_surface_elements, universal_surface_element_to_local_numbering)
    
    do i=1,key_count(new_surface_elements)
       call allocate(senlists(i))
    end do
    
    ! Invert the snelists to give the senlists
    
    do i=1,key_count(new_nodes)
       do j=1,key_count(new_snelist(i))
          universal_number = fetch(new_snelist(i), j)
          new_local_number = fetch(universal_surface_element_to_local_numbering, universal_number)
          call insert(senlists(new_local_number), i)
       end do
    end do
    
    call deallocate(universal_surface_element_to_local_numbering)
    
    ! Now, some of these will be degenerate, because the halo nodes will refer
    ! to elements we don't know about. We can tell these apart because they
    ! are incomplete.
    
    full_elements = 0
    ! For mixed meshes, this should taken from the loc of the positions mesh
    ! However, it's constant for now
    expected_loc = face_loc(zz_mesh, 1)
    
    ! First, count how many we have
    nnlist => extract_nnlist(new_positions%mesh)
    do i=1,key_count(new_surface_elements)
       j = key_count(senlists(i))
       assert(j <= expected_loc)
       if (j == expected_loc) then
          ! We also need to check if we have the parent volume element --
          ! it's possible to get all the information for a face, without having the
          ! corresponding element!
          universal_number = fetch(new_surface_elements, i)
          universal_element_number = fetch(universal_surface_number_to_element_owner, universal_number)
          keep_surface_element(i) = has_key(uen_to_new_local_numbering, universal_element_number)
          if (keep_surface_element(i)) full_elements = full_elements + 1
       else
          keep_surface_element(i) = .false.
          ! write(0,*) "Surface element ", fetch(new_surface_elements, i), " is degenerate. Dropping .."
          ! write(0,*) "Local nodes: ", set2vector(senlists(i))
       end if
    end do

    ewrite(2,*) "Found ", key_count(new_surface_elements), " possible new surface elements."
    ewrite(2,*) "Of these, ", full_elements, " are non-degenerate."

    ! And now fill in the non-degenerate ones
    
    allocate(sndgln(full_elements * expected_loc))
    allocate(surface_ids(full_elements))
    allocate(element_owners(full_elements))
    
    j = 1
    do i=1,key_count(new_surface_elements)
       if (keep_surface_element(i)) then
          universal_number = fetch(new_surface_elements, i)
          sndgln( (j-1)*expected_loc+1 : j*expected_loc ) = set2vector(senlists(i))
          surface_ids(j) = fetch(universal_surface_number_to_surface_id, universal_number)
          universal_element_number = fetch(universal_surface_number_to_element_owner, universal_number)
          element_owners(j) = fetch(uen_to_new_local_numbering, universal_element_number)
          j = j + 1
       end if
    end do
    assert(j == full_elements + 1)

    call add_faces(new_positions%mesh, sndgln=sndgln, boundary_ids=surface_ids, element_owner=element_owners)
    
    do i=1,size(senlists)
       call deallocate(senlists(i))
    end do
    
    ! New elements is no longer valid, as we have lost the degenerate elements
    call deallocate(new_surface_elements)
    call deallocate(universal_surface_number_to_surface_id)
    call deallocate(universal_surface_number_to_element_owner)
    call deallocate(new_snelist)
    deallocate(new_snelist)
    
    deallocate(sndgln)
    deallocate(surface_ids)
    deallocate(element_owners)
    
    call deinterleave_surface_ids(new_positions%mesh, max_coplanar_id)
    
    ! Bingo! Our mesh has an senlist.
    ewrite(1,*) "Exiting reconstruct_senlist"
  end subroutine reconstruct_senlist

  subroutine reconstruct_halo(zz)
    ! At this point, the receives sets have been populated with all
    ! the universal node numbers we need to receive from each process.
    ! So, we are going to use zoltan to invert this to compute
    ! the send list for each process too.
    ! Then we will allocate the l2n halo and set it.
    ! Then we will chop it down to form the l1n halo, the l1e halo, and the
    ! l2e halo. 
    ! Supply the peeps with jeeps, brick apiece, capiche?

    type(zoltan_struct), pointer, intent(in) :: zz    

    integer :: num_import, num_export
    integer, dimension(:), pointer :: import_global_ids, import_local_ids, import_procs
    integer, dimension(:), pointer :: export_global_ids, export_local_ids, export_procs, export_to_part
    integer :: ierr, i, head
    type(integer_set), dimension(size(receives)) :: sends
    integer, dimension(size(receives)) :: nreceives, nsends
    integer, dimension(ele_count(new_positions)) :: ele_renumber_permutation
    integer, dimension(node_count(new_positions)) :: node_renumber_permutation
    integer :: universal_element_number, old_new_local_element_number, new_new_local_element_number
    integer :: universal_node_number, old_new_local_node_number, new_new_local_node_number
    
    integer, dimension(ele_count(new_positions)) :: old_new_region_ids
    
    ewrite(1,*) "In reconstruct_halo"
    
    num_import = 0
    do i=1,size(receives)
       nreceives(i) = key_count(receives(i))
       num_import = num_import + nreceives(i)
    end do
    
    allocate(import_global_ids(num_import))
    allocate(import_local_ids(num_import))
    allocate(import_procs(num_import))
    
    import_local_ids = 666
    head = 1
    do i=1,size(receives)
       import_global_ids(head:head + nreceives(i) - 1) = set2vector(receives(i))
       import_procs(head:head + nreceives(i) - 1) = i - 1
       head = head + nreceives(i)
    end do
    
    export_global_ids => null()
    export_local_ids => null()
    export_procs => null()
    export_to_part => null()
    
    ierr = Zoltan_Compute_Destinations(zz, &
         & num_import, import_global_ids, import_local_ids, import_procs, &
         & num_export, export_global_ids, export_local_ids, export_procs)
    assert(ierr == ZOLTAN_OK)
    
    ! Now we know the sends too! Thanks, Zoltan!
    
    deallocate(import_global_ids)
    deallocate(import_local_ids)
    deallocate(import_procs)
    
    ! Now create the sends sets .. easier than pulling it straight out of Zoltan's data structures
    ! as Zoltan does NOT explicitly guarantee that the sends are organised such that export_procs looks
    ! like 
    ! [ sends to process 0 | sends to process 1 | sends to process 2 ... ]
    ! If such a guarantee were available, then it would be just as easy to use that, but there
    ! is no such guarantee given in the documentation ...
    ! Is an appetite for destruction, slap a murder rap on this production
    
    do i=1,size(sends)
       call allocate(sends(i))
    end do
    
    do i=1,num_export
       call insert(sends(export_procs(i)+1), export_global_ids(i))
    end do
    
    do i=1,size(sends)
       nsends(i) = key_count(sends(i))
    end do
    
    ! Allocate the halo and such
    ! We had to grow dreads to change our description, two cops is on a milkbox, missin'
    
    allocate(new_positions%mesh%halos(2))
    call allocate(new_positions%mesh%halos(2), &
         nsends = nsends, &
         nreceives = nreceives, &
         name = halo_name(zoltan_global_zz_halo), &
         communicator = halo_communicator(zoltan_global_zz_halo), &
         nowned_nodes = key_count(new_nodes) - num_import, &
         data_type = halo_data_type(zoltan_global_zz_halo))

    do i=1,size(receives)
       call set_halo_sends(new_positions%mesh%halos(2), i, fetch(universal_to_new_local_numbering, set2vector(sends(i))))
       call set_halo_receives(new_positions%mesh%halos(2), i, fetch(universal_to_new_local_numbering, set2vector(receives(i))))
    end do

    ! Now derive all the other halos ...
    ! And me teevee's always off, cause I see something truly black then
    
    call derive_l1_from_l2_halo(new_positions%mesh, ordering_scheme = HALO_ORDER_GENERAL, create_caches = .false.)
    call renumber_positions_trailing_receives(new_positions, permutation=node_renumber_permutation)
    assert(has_ownership(new_positions%mesh%halos(2)))
    assert(has_ownership(new_positions%mesh%halos(1)))
    allocate(new_positions%mesh%element_halos(2))
    call derive_element_halo_from_node_halo(new_positions%mesh, create_caches = .false.)
    call renumber_positions_elements_trailing_receives(new_positions, permutation=ele_renumber_permutation)
    assert(has_ownership(new_positions%mesh%halos(2)))
    assert(has_ownership(new_positions%mesh%halos(1)))
    
    if(preserve_mesh_regions) then
       old_new_region_ids = new_positions%mesh%region_ids
    end if
    
    ! The previous routine has renumbered all the local elements to put the element halos in
    ! trailing receives status. However, we need the universal element number -> local element number
    ! later in the field transfer. So we need to update our records now.
    do i=1,ele_count(new_positions)
       universal_element_number = fetch(new_elements, i)
       old_new_local_element_number = i
       new_new_local_element_number = ele_renumber_permutation(old_new_local_element_number)
       call insert(uen_to_new_local_numbering, universal_element_number, new_new_local_element_number)
       if(preserve_mesh_regions) then
          new_positions%mesh%region_ids(new_new_local_element_number) = old_new_region_ids(old_new_local_element_number)
       end if
    end do
    ! We're also going to need the universal to new local numbering for 2+1d adaptivity
    do i=1,node_count(new_positions)
       universal_node_number = fetch(new_nodes, i)
       old_new_local_node_number = i
       new_new_local_node_number = node_renumber_permutation(old_new_local_node_number)
       call insert(universal_to_new_local_numbering, universal_node_number, new_new_local_node_number)
    end do
    
    do i=1,halo_count(new_positions)
       assert(halo_verifies(new_positions%mesh%halos(i), new_positions))
    end do
    
    ! Now cleanup
    
    ierr = Zoltan_LB_Free_Part(export_global_ids, export_local_ids, export_procs, export_to_part)
    assert(ierr == ZOLTAN_OK)

    do i=1,size(sends)
       call deallocate(sends(i))
    end do
      
    call reorder_element_numbering(new_positions)
    
    ewrite(1,*) "Exiting reconstruct_halo"
    
  end subroutine reconstruct_halo
    
  subroutine initialise_transfer(zz, states, new_positions_m1d, metric, full_metric, new_metric, initialise_fields, ignore_extrusion, mesh_name)
    type(zoltan_struct), pointer, intent(in) :: zz    
    type(state_type), dimension(:), intent(inout), target :: states
    type(vector_field), intent(inout) :: new_positions_m1d
    type(tensor_field), intent(inout), optional :: metric
    type(tensor_field), intent(inout), optional :: full_metric
    type(tensor_field), intent(out) :: new_metric
    logical, intent(in), optional :: initialise_fields
    logical, intent(in), optional :: ignore_extrusion
    character(len=*), optional :: mesh_name

    integer :: i
    type(state_type), dimension(size(states)) :: interpolate_states
    integer(zoltan_int) :: ierr
    character(len=FIELD_NAME_LEN), dimension(:), allocatable :: mesh_names
    type(mesh_type), pointer :: mesh
    integer :: no_meshes
    
    ewrite(1,*) 'in initialise_transfer'
    
    ! Set up source_states
    do i=1,size(states)
       call select_fields_to_interpolate(states(i), interpolate_states(i), no_positions=.true., &
            first_time_step=initialise_fields)
       ! Remove the current state as we've copied the bits we need
       call deallocate(states(i))
    end do
    
    ! Interpolate the metric, too
    if (present(full_metric)) then
       call insert(interpolate_states(1), full_metric, "ErrorMetric")
       call deallocate(full_metric)
    else if (present(metric)) then
       call insert(interpolate_states(1), metric, "ErrorMetric")
       call deallocate(metric)
    end if
    
    allocate( mesh_names(1:mesh_count(interpolate_states(1))) )
    no_meshes = 0
    do i=1, mesh_count(interpolate_states(1))
       mesh => extract_mesh(interpolate_states(1), i)
       if (zoltan_global_migrate_extruded_mesh .and. mesh_dim(mesh)/=mesh_dim(new_positions)) cycle
       no_meshes = no_meshes + 1
       mesh_names(no_meshes) = mesh%name
    end do
    
    allocate(source_states(no_meshes))
    call halo_update(interpolate_states, level=1)
    ! Place the fields we've picked out to interpolate onto the correct meshes of source_states
    call collect_fields_by_mesh(interpolate_states, mesh_names(1:no_meshes), source_states)
    
    ! Finished with interpolate_states for setting up source_states
    do i=1,size(interpolate_states)
       call deallocate(interpolate_states(i))
    end do
    
    if (mesh_periodic(zz_mesh)) then
       new_positions%mesh%periodic = .true.
    end if
    
    ! Start setting up states so that it can be populated with migrated fields data
    
    ! Put the new positions mesh into states
    
    if(zoltan_global_migrate_extruded_mesh) then
       if (mesh_periodic(zz_mesh)) then
          new_positions_m1d%mesh%periodic = .true.
       end if
       call insert(states, new_positions_m1d%mesh, name = new_positions_m1d%mesh%name)
       call insert(states, new_positions_m1d, name = new_positions_m1d%name)
    end if
    
    call insert(states, new_positions%mesh, name = new_positions%mesh%name)
    call insert(states, new_positions, name = new_positions%name)

    if(present(mesh_name)) then
       tmp_mesh = extract_mesh(states(1), trim(mesh_name))
    else
       tmp_mesh = get_external_mesh(states)
    end if
    call incref(tmp_mesh)
    
    tmp_mesh_nhalos = halo_count(tmp_mesh)
    assert(tmp_mesh_nhalos == 2)
    
    ! Allocate a new metric field on the new positions mesh and zero it
    if (present(metric).or.present(full_metric)) then
       call allocate(new_metric, new_positions%mesh, "ErrorMetric")
       call set(new_metric,spread(spread(666.0, 1, new_metric%dim(1)), 2, new_metric%dim(2)))
    end if

    ! Setup meshes and fields on states
    call restore_reserved_meshes(states)
    call insert_derived_meshes(states, skip_extrusion=ignore_extrusion)
    call allocate_and_insert_fields(states)
    call restore_reserved_fields(states)
    
    ! And set up target_states based on states
    do i=1,size(states)
       call select_fields_to_interpolate(states(i), interpolate_states(i), no_positions=.true., &
            first_time_step=initialise_fields)
    end do

    ! Metric will be interpolated too, it is 666.0 (for debugging purposes) at this point
    if (present(metric).or.present(full_metric)) then
       call insert(interpolate_states(1), new_metric, "ErrorMetric")
    end if
    
    allocate(target_states(no_meshes))
    call collect_fields_by_mesh(interpolate_states, mesh_names(1:no_meshes), target_states)
      
    ! Finished with interpolate states for setting up target_states
    do i=1,size(interpolate_states)
       call deallocate(interpolate_states(i))
    end do

    ! Tell Zoltan which callback functions to use for the migration
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_OBJ_SIZE_MULTI_FN_TYPE, zoltan_cb_pack_field_sizes); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_PACK_OBJ_MULTI_FN_TYPE, zoltan_cb_pack_fields); assert(ierr == ZOLTAN_OK)
    ierr = Zoltan_Set_Fn(zz, ZOLTAN_UNPACK_OBJ_MULTI_FN_TYPE, zoltan_cb_unpack_fields); assert(ierr == ZOLTAN_OK)
    
    ewrite(1,*) 'exiting initialise_transfer'
    
  end subroutine initialise_transfer


  subroutine update_detector_list_element(detector_list)
    ! Fix the detector%element field for every detector left in our lis
    type(detector_linked_list), intent(inout) :: detector_list

    integer :: i, j
    integer :: original_detector_list_length
    integer :: send_count
    integer :: old_local_element_number, new_local_element_number, old_universal_element_number
    type(detector_type), pointer :: detector => null(), send_detector => null(), delete_detector => null()
    type(detector_linked_list) :: detector_send_list
    integer, allocatable :: ndets_being_sent(:)
    integer :: ierr
    real, allocatable :: send_buff(:,:), recv_buff(:,:)
    type(element_type), pointer :: shape    

    ewrite(1,*) "In update_detector_list_element"

    ewrite(3,*) "Length of detector list to be updated: ", detector_list%length

    original_detector_list_length = detector_list%length

    detector => detector_list%firstnode

    send_count = 0

    ewrite(3,*) "Beginning update of detectors in detector_list"

    do i=1, original_detector_list_length

       ewrite(3,*) "Updating detector%id_number:", detector%id_number
       ewrite(3,*) "Old element owner of ", detector%id_number, "(ID): ", ele_owner(detector%element, zz_mesh, zoltan_global_zz_halo)
       ewrite(3,*) "Old element number of ", detector%id_number, "(ID): ", detector%element

       old_local_element_number = detector%element

       assert(has_key(old_local_numbering_to_uen, old_local_element_number) .EQV. .TRUE.)
       old_universal_element_number = fetch(old_local_numbering_to_uen, old_local_element_number)

       ewrite(3,*) "Universal element number of ", detector%id_number, "(ID): ", old_universal_element_number

       if(has_key(uen_to_new_local_numbering, old_universal_element_number)) then
          ! Update the element number for the detector
          detector%element = fetch(uen_to_new_local_numbering, old_universal_element_number)
          ewrite(3,*) "New element number of ", detector%id_number, "(ID): ", detector%element

          ewrite(3,*) "Finished updating detector%id_number:", detector%id_number
          detector => detector%next
       else
          ewrite(3,*) "No new element number of ", detector%id_number, "(ID) could be found"
          ! We no longer own the element containing this detector
          ! We're going to put it into a send list and count how many detectors we're sending
          send_count = send_count + 1

          send_detector => detector
          detector => detector%next
          
          ! Store the old universal element number for unpacking to new local at the receive
          send_detector%element = old_universal_element_number

          ! Remove detector from detector list
          ewrite(3,*) "Removing detector ", send_detector%id_number, "(ID) from the detector_list"
          call remove_det_from_current_det_list(detector_list, send_detector)

          ! Add allocated detector to send list
          ewrite(3,*) "Adding detector ", send_detector%id_number, "(ID) to the detector_send_list"
          call insert(detector_send_list, send_detector)

       end if
    end do

    ewrite(3,*) "Length of detector list AFTER being updated: ", detector_list%length
    ewrite(3,*) "Length of detector_send_list AFTER update: ", detector_send_list%length
    ewrite(3,*) "Finished updating of detectors in detector_list"

    ewrite(3,*) "Preparing to broadcast detectors in detector_send_list"

    allocate(ndets_being_sent(getnprocs()))

    ! Find out how many detectors each process wants to send
    call mpi_allgather(send_count, 1, getPINTEGER(), ndets_being_sent, 1 , getPINTEGER(), &
         MPI_COMM_WORLD, ierr)
    assert(ierr == MPI_SUCCESS)
    
    ewrite(3,*) "Gathered the number of detectors each process wants to broadcast"
    ewrite(3,*) "             ndets_being_sent: ", ndets_being_sent

    ! Allocate memory for all the detectors you're going to send
    allocate(send_buff(send_count,ndata_per_det))

    detector => detector_send_list%firstnode
    do i=1,send_count
       ! Pack the detector information
       call pack_detector(detector, send_buff(i, 1:ndata_per_det), &
            ndims, ndata_per_det)

       delete_detector => detector
       detector => detector%next
       call remove_det_from_current_det_list(detector_send_list, delete_detector)
       call deallocate(delete_detector)
    end do

    ewrite(3,*) "Packed the ", send_count, " detectors to be sent"
    
    do i=1,getnprocs()

       if (ndets_being_sent(i) > 0) then

          if (i == getprocno()) then
             ! Broadcast the detectors you want to send
             ewrite(3,*) "Broadcasting the ", send_count, " detectors in detector_send_list"
             call mpi_bcast(send_buff,send_count*ndata_per_det, getPREAL(), i-1, MPI_COMM_WORLD, ierr)
             assert(ierr == MPI_SUCCESS)
          else
             ! Allocate memory to receive into
             allocate(recv_buff(ndets_being_sent(i),ndata_per_det))
             
             ! Receive broadcast
             ewrite(3,*) "Receiving ", ndets_being_sent(i), " detectors from process ", i
             call mpi_bcast(recv_buff,ndets_being_sent(i)*ndata_per_det, getPREAL(), i-1, MPI_COMM_WORLD, ierr)
             assert(ierr == MPI_SUCCESS)

             ! Unpack detector if you own it
             do j=1,ndets_being_sent(i)
                old_universal_element_number = recv_buff(j,1)

                if (has_key(uen_to_new_local_numbering, old_universal_element_number)) then                   

                   new_local_element_number = fetch(uen_to_new_local_numbering, old_universal_element_number)

                   if(ele_owner(new_local_element_number, tmp_mesh, tmp_mesh%halos(tmp_mesh_nhalos)) == getprocno()) then

                      ewrite(3,*) "Unpacking ", recv_buff(j,ndims+2), "(ID) detector from process ", i

                      shape=>ele_shape(new_positions,1)                     
                      call allocate(detector, ndims, local_coord_count(shape))

                      call unpack_detector(detector, recv_buff(j, 1:ndata_per_det), &
                           ndims, ndata_per_det)
                      detector%element = new_local_element_number

                      call update_detector(detector, new_positions)

                      ewrite(3,*) "Unpacked detector%id_number: ", detector%id_number
                      ewrite(3,*) "Unpacked detector%position: ", detector%position
                      ewrite(3,*) "Unpacked detector given new_local_element_number: ", detector%element

                      call insert(detector_list, detector)
                      detector => null()

                   end if
                end if
             end do

             deallocate(recv_buff)

          end if
       end if
    end do

    deallocate(send_buff)             

    ewrite(3,*) "Length of detector_send_list AFTER moving of detectors: ", detector_send_list%length
    ewrite(3,*) "Length of detector list AFTER being updated and moving detectors: ", detector_list%length

    ewrite(1,*) "Exiting update_detector_list_element"

  end subroutine update_detector_list_element

  subroutine transfer_fields(zz)
    ! OK! So, here is how this is going to work. We are going to 
    ! loop through every element in which you own at least one node, and note
    ! that its information needs to be sent to the owners of its vertices.
    ! We also have to take special care of self-sends, since they don't
    ! get taken care of in the zoltan communication.

    type(zoltan_struct), pointer, intent(in) :: zz    
    
    integer :: old_ele
    integer, dimension(:), pointer :: old_local_nodes, nodes
    type(element_type), pointer :: eshape
    type(integer_set), dimension(halo_proc_count(zoltan_global_zz_halo)) :: sends
    integer :: i, j, new_owner, universal_element_number
    type(integer_set) :: self_sends
    integer :: num_import, num_export
    integer :: original_unpacked_detectors_list_length
    integer, dimension(:,:), allocatable :: vertex_order
    integer, dimension(:), pointer :: import_global_ids, import_local_ids, import_procs, import_to_part
    integer, dimension(:), pointer :: export_global_ids, export_local_ids, export_procs, export_to_part
    integer :: head
    integer(zoltan_int) :: ierr
    
    integer :: old_universal_element_number, new_local_element_number, old_local_element_number
    integer :: state_no, field_no
    type(scalar_field), pointer :: source_sfield, target_sfield
    type(vector_field), pointer :: source_vfield, target_vfield
    type(tensor_field), pointer :: source_tfield, target_tfield

    type(detector_type), pointer :: detector => null(), add_detector => null(), delete_detector => null()

    ewrite(1,*) 'in transfer_fields'
    
    do i=1,size(sends)
       call allocate(sends(i))
    end do
    call allocate(self_sends)
    
    
    do old_ele=1,ele_count(zz_positions)
       universal_element_number = halo_universal_number(zz_ele_halo, old_ele)
       old_local_nodes => ele_nodes(zz_positions, old_ele)
       if (.not. any(nodes_owned(zoltan_global_zz_halo, old_local_nodes))) cycle
       do i=1,size(old_local_nodes)
          if (has_value(nodes_we_are_keeping, old_local_nodes(i))) then
             assert(node_owned(zoltan_global_zz_halo, old_local_nodes(i)))
             call insert(self_sends, universal_element_number)
          else if (has_key(nodes_we_are_sending,  old_local_nodes(i))) then
             new_owner = fetch(nodes_we_are_sending, old_local_nodes(i))
             call insert(sends(new_owner+1), universal_element_number)
          end if
       end do
    end do
    
    num_export = sum(key_count(sends))
    allocate(export_global_ids(num_export))
    allocate(export_procs(num_export))

    ! allocate array for storing the number of detectors in each of the elements to be transferred
    allocate(ndets_in_ele(num_export))
    ndets_in_ele(:) = 0

    ! calculate the amount of data to be transferred per detector
    ndims = zz_positions%dim
    ndata_per_det = ndims + 3
    ewrite(3,*) "Amount of data to be transferred per detector: ", ndata_per_det
    
    head = 1
    do i=1,size(sends)
       export_global_ids(head:head + key_count(sends(i)) - 1) = set2vector(sends(i))
       export_procs(head:head + key_count(sends(i)) - 1) = i - 1
       head = head + key_count(sends(i))
    end do
    
    allocate(export_local_ids(num_export))
    export_local_ids = 666
    
    import_global_ids => null()
    import_local_ids => null()
    import_procs => null()
    import_to_part => null()
    export_to_part => null()
    
    ierr = Zoltan_Compute_Destinations(zz, &
         & num_export, export_global_ids, export_local_ids, export_procs, &
         & num_import, import_global_ids, import_local_ids, import_procs)
    assert(ierr == ZOLTAN_OK)

    ewrite(3,*) "Before migrate, detector_list%length: ", detector_list%length
    
    ierr = Zoltan_Migrate(zz, num_import, import_global_ids, import_local_ids, import_procs, &
         & import_to_part, num_export, export_global_ids, export_local_ids, export_procs, export_to_part) 
    
    assert(ierr == ZOLTAN_OK)
    
    deallocate(export_local_ids)
    deallocate(export_procs)
    deallocate(export_global_ids)

    deallocate(ndets_in_ele)
    
    call deallocate(tmp_mesh)

    ! update the detector%element for each detector in the detector_list
    call update_detector_list_element(detector_list)

    ewrite(3,*) "Merging unpacked_detectors_list with detector_list"

    ! Merge in any detectors we received as part of the transfer to our detector list
    detector => unpacked_detectors_list%firstnode
    original_unpacked_detectors_list_length = unpacked_detectors_list%length

    do j=1, original_unpacked_detectors_list_length

       call allocate(add_detector, detector)
       call copy(add_detector, detector)

       delete_detector => detector
       detector => detector%next
       call insert(detector_list, add_detector)
       call remove_det_from_current_det_list(unpacked_detectors_list, delete_detector)

       call deallocate(delete_detector)

    end do

    ewrite(3,*) "Finished merging unpacked_detectors_list with detector_list"

    ewrite(3,*) "After migrate and merge, detector_list%length: ", detector_list%length

    ierr = Zoltan_LB_Free_Part(import_global_ids, import_local_ids, import_procs, import_to_part)
    assert(ierr == ZOLTAN_OK)
    
    ! for all self-send elements, establish the vertex order in the new element such
    ! that it matches the local element ordering of the old element
    allocate(vertex_order(1:ele_loc(new_positions,1), key_count(self_sends)))
    do i=1, key_count(self_sends)
      old_universal_element_number = fetch(self_sends, i)
      new_local_element_number = fetch(uen_to_new_local_numbering, old_universal_element_number)
      old_local_element_number = fetch(uen_to_old_local_numbering, old_universal_element_number)
      ! this function takes the universal node numbers of the old element and the new global (over the local domain)
      ! node numbers, to compute the vertex order
      vertex_order(:,i) = local_vertex_order( &
         halo_universal_number(zoltan_global_zz_halo, ele_nodes(zz_positions, old_local_element_number)), &
         ele_nodes(new_positions, new_local_element_number))
    end do
    
    do state_no=1,size(source_states)
       assert(scalar_field_count(source_states(state_no)) == scalar_field_count(target_states(state_no)))
       assert(vector_field_count(source_states(state_no)) == vector_field_count(target_states(state_no)))
       assert(tensor_field_count(source_states(state_no)) == tensor_field_count(target_states(state_no)))
       
       do field_no=1,scalar_field_count(source_states(state_no))
          source_sfield => extract_scalar_field(source_states(state_no), field_no)
          target_sfield => extract_scalar_field(target_states(state_no), field_no)
          assert(trim(source_sfield%name) == trim(target_sfield%name))
          
          do i=1,key_count(self_sends)
             old_universal_element_number = fetch(self_sends, i)
             new_local_element_number = fetch(uen_to_new_local_numbering, old_universal_element_number)
             old_local_element_number = fetch(uen_to_old_local_numbering, old_universal_element_number)
             eshape => ele_shape(target_sfield, new_local_element_number)
             nodes => ele_nodes(target_sfield, new_local_element_number)
             call set(target_sfield, nodes(ele_local_num(vertex_order(:,i), eshape%numbering)), &
                               ele_val(source_sfield, old_local_element_number))
          end do
       end do
       
       do field_no=1,vector_field_count(source_states(state_no))
          source_vfield => extract_vector_field(source_states(state_no), field_no)
          target_vfield => extract_vector_field(target_states(state_no), field_no)
          assert(trim(source_vfield%name) == trim(target_vfield%name))
          if (source_vfield%name == new_positions%name) cycle
          
          do i=1,key_count(self_sends)
             old_universal_element_number = fetch(self_sends, i)
             new_local_element_number = fetch(uen_to_new_local_numbering, old_universal_element_number)
             old_local_element_number = fetch(uen_to_old_local_numbering, old_universal_element_number)
             eshape => ele_shape(target_vfield, new_local_element_number)
             nodes => ele_nodes(target_vfield, new_local_element_number)
             call set(target_vfield, nodes(ele_local_num(vertex_order(:,i), eshape%numbering)), &
                               ele_val(source_vfield, old_local_element_number))
          end do
       end do
       
       do field_no=1,tensor_field_count(source_states(state_no))
          source_tfield => extract_tensor_field(source_states(state_no), field_no)
          target_tfield => extract_tensor_field(target_states(state_no), field_no)
          assert(trim(source_tfield%name) == trim(target_tfield%name))
          
          do i=1,key_count(self_sends)
             old_universal_element_number = fetch(self_sends, i)
             new_local_element_number = fetch(uen_to_new_local_numbering, old_universal_element_number)
             old_local_element_number = fetch(uen_to_old_local_numbering, old_universal_element_number)
             eshape => ele_shape(target_tfield, new_local_element_number)
             nodes => ele_nodes(target_tfield, new_local_element_number)
             call set(target_tfield, nodes(ele_local_num(vertex_order(:,i), eshape%numbering)), &
                               ele_val(source_tfield, old_local_element_number))
          end do
       end do
    end do
    
    call deallocate(self_sends)
    call deallocate(sends)
    deallocate(vertex_order)    
    
    call halo_update(target_states)
    
    ewrite(1,*) 'exiting transfer_fields'
    
  end subroutine transfer_fields

  subroutine finalise_transfer(states, metric, full_metric, new_metric)
    type(state_type), dimension(:), intent(inout), target :: states

    type(tensor_field), intent(inout), optional :: metric
    type(tensor_field), intent(inout), optional :: full_metric
    type(tensor_field), intent(in) :: new_metric

    integer :: i
    call set_prescribed_field_values(states, exclude_interpolated = .true.)
    call populate_boundary_conditions(states)
    call set_boundary_conditions_values(states)
    call set_dirichlet_consistent(states)
    call alias_fields(states)
    
    if (present(full_metric)) then
       full_metric = new_metric
       call halo_update(full_metric)
    else if (present(metric)) then
       metric = new_metric
       call halo_update(metric)
    end if
    
    do i=1,size(source_states)
       call deallocate(source_states(i))
       call deallocate(target_states(i))
    end do
    deallocate(source_states)
    deallocate(target_states)
  end subroutine finalise_transfer

  subroutine dump_linear_mesh
    type(scalar_field) :: sends, receives, unn
    integer :: i, proc
    
    assert(associated(new_positions%refcount))
    assert(new_positions%refcount%count == 1)
    assert(associated(new_positions%mesh%refcount))
    assert(new_positions%mesh%refcount%count == 1)
    
    call allocate(sends, new_positions%mesh, "Sends")
    call zero(sends)
    call allocate(receives, new_positions%mesh, "Receives")
    call zero(receives)
    call allocate(unn, new_positions%mesh, "NewUniversalNodeNumber")
    call zero(unn)
    
    do proc=1,halo_proc_count(new_positions%mesh%halos(2))
       do i=1,size(new_positions%mesh%halos(2)%sends(proc)%ptr)
          call set(sends, new_positions%mesh%halos(2)%sends(proc)%ptr(i), 1.0)
       end do
       do i=1,size(new_positions%mesh%halos(2)%receives(proc)%ptr)
          call set(receives, new_positions%mesh%halos(2)%receives(proc)%ptr(i), 1.0)
       end do
    end do
    
    do i=1,node_count(new_positions)
       call set(unn, i, float(halo_universal_number(new_positions%mesh%halos(2), i)))
    end do
    
    call deallocate(sends)
    call deallocate(receives)
    call deallocate(unn)
  end subroutine dump_linear_mesh

  subroutine dump_suggested_owner(states, p1_num_export, p1_export_local_ids, p1_export_procs)
    type(state_type), dimension(:), intent(inout), target :: states
    integer(zoltan_int), intent(in) :: p1_num_export
    integer, dimension(:), pointer, intent(in) :: p1_export_local_ids, p1_export_procs

    integer :: rank, i
    type(scalar_field) :: suggested_owner, unn
    type(vector_field) :: positions
    
    rank = getrank()
    call allocate(suggested_owner, zz_mesh, "SuggestedOwner")
    
    call set(suggested_owner, float(rank))
    do i=1,p1_num_export
       call set(suggested_owner, p1_export_local_ids(i), float(p1_export_procs(i)))
    end do
    
    call allocate(unn, zz_mesh, "OldUniversalNodeNumber")
    do i=1,node_count(unn)
       call set(unn, i, float(halo_universal_number(zoltan_global_zz_halo, i)))
    end do
    
    positions = get_coordinate_field(states(1), zz_mesh)
    call halo_update(suggested_owner)
    call deallocate(positions)
    call deallocate(suggested_owner)
    call deallocate(unn)
    
  end subroutine dump_suggested_owner

#endif
end module zoltan_integration
