!  Copyright (C) 2006 Imperial College London and others.
!
!    Please see the AUTHORS file in the main source directory for a full list
!    of copyright holders.
!
!    Prof. C Pain
!    Applied Modelling and Computation Group
!    Department of Earth Science and Engineering
!    Imperial College London
!
!    amcgsoftware@imperial.ac.uk
!
!    This library is free software; you can redistribute it and/or
!    modify it under the terms of the GNU Lesser General Public
!    License as published by the Free Software Foundation; either
!    version 2.1 of the License, or (at your option) any later version.
!
!    This library is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
!    Lesser General Public License for more details.
!
!    You should have received a copy of the GNU Lesser General Public
!    License along with this library; if not, write to the Free Software
!    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
!    USA
#include "fdebug.h"

module supermesh_force

use fields
use supermesh_construction
!use tetrahedron_intersection_module
use sparsity_patterns
use solvers
use spud
implicit none
contains

  subroutine force_projection(fieldA, positionsA, fieldB, positionsB, sigma_s, fluid_force, solid_force)
    !! Return Force acting on the solid body and fluid to the solid and fluid mesh
    !! Since positionsA and positionsB are different, we need to supermesh!

    !A stands for fluid, B for solid, C for the supermesh in this case:
    type(vector_field), intent(in) :: fieldA, fieldB
    type(vector_field), intent(in) :: positionsA, positionsB
    real, intent(in) :: sigma_s
    type(ilist), dimension(ele_count(positionsB)) :: map_BA
    integer :: ele_A, ele_B

    type(quadrature_type) :: supermesh_quad
    type(element_type) :: supermesh_positions_shape, supermesh_field_shape

    type(vector_field) :: supermesh
    type(mesh_type) :: supermesh_field_mesh
    real :: ele_error
    
    type(vector_field) :: force_on_supermesh
    type(vector_field) :: fluid_force, solid_force

    type(csr_sparsity) :: sparsity_solid, sparsity_fluid
    type(csr_matrix) :: mass_matrix_solid, mass_matrix_fluid
    type(vector_field) :: rhs_fluid, rhs_solid

    real, dimension(ele_loc(positionsB, 1), ele_loc(positionsB, 1)) :: inversion_matrix_B
    real, dimension(ele_loc(positionsB, 1), ele_loc(positionsB, 1), ele_count(positionsA)) :: inversion_matrices_A
    integer :: dim, max_degree

    dim = mesh_dim(positionsB)
    call intersector_set_dimension(dim)

    ! Define polynomial degree and quadrature of the supermesh:
    max_degree = max(element_degree(fieldA, 1), element_degree(fieldB, 1))
    supermesh_quad = make_quadrature(vertices=ele_loc(positionsB, 1), dim=dim, degree=2*max_degree)
    ! Define the shape function of the supermesh:
    supermesh_positions_shape = make_element_shape(vertices=ele_loc(positionsB, 1), dim=dim, degree=1, quad=supermesh_quad)
    supermesh_field_shape = make_element_shape(vertices=ele_loc(positionsB, 1), dim=dim, degree=max_degree, quad=supermesh_quad)
    ! For each element in B get the list of intersecting elements in A
    map_BA = intersection_finder(positionsB, positionsA)

    sparsity_fluid = make_sparsity(fieldA%mesh, fieldA%mesh, "FluidMassMatrixSparsity")
    call allocate(mass_matrix_fluid, sparsity_fluid, name="FluidMassMatrix")
    call zero(mass_matrix_fluid)
    call deallocate(sparsity_fluid)

    ! get the matrix for the coordinates of mesh A:
    do ele_A=1,ele_count(positionsA)
      call local_coords_matrix(positionsA, ele_A, inversion_matrices_A(:, :, ele_A))
      call assemble_mass_matrix(mass_matrix_fluid, fieldA, positionsA, ele_A)
    end do

    sparsity_solid = make_sparsity(fieldB%mesh, fieldB%mesh, "SolidMassMatrixSparsity")
    call allocate(mass_matrix_solid, sparsity_solid, name="SolidMassMatrix")
    call zero(mass_matrix_solid)
    call deallocate(sparsity_solid)

    call allocate(rhs_fluid, fieldA%dim, fieldA%mesh, "ForceOnFluidRHS")
    call zero(rhs_fluid)
    call allocate(rhs_solid, fieldB%dim, fieldB%mesh, "ForceOnSolidRHS")
    call zero(rhs_solid)

    ! Looping over all the elements of mesh B:
    do ele_B=1,ele_count(positionsB)
      ! get the matrix for the coordinates of mesh B:
      call local_coords_matrix(positionsB, ele_B, inversion_matrix_B)
      ! Construct the supermesh associated with ele_B. 
      call construct_supermesh(positionsB, ele_B, positionsA, map_BA(ele_B), supermesh_positions_shape, supermesh)
      ! At this point, a portion of the supermesh is constructed, which refines the dimensional space
      ! of the intersection of ele_B with mesh A.
      ! This portion of the supermesh is stored in 'supermesh'

      ! 0th step: assemble the solid mass matrix
      call assemble_mass_matrix(mass_matrix_solid, fieldB, positionsB, ele_B)

      ! 1st step: Compute the force on the supermesh:

      ! Allocate field for the force on the supermesh:
      supermesh_field_mesh = make_mesh(supermesh%mesh, supermesh_field_shape, -1, "SupermeshFieldMesh")
      call allocate(force_on_supermesh, dim, supermesh_field_mesh, "SupermeshForce")
      call zero(force_on_supermesh)

      ! Get the force for this portion of the supermesh:
      call compute_force_on_supermesh(fieldA, positionsA, supermesh_field_shape, ele_val(fieldB, ele_B), positionsB, ele_B, supermesh, &
                                    inversion_matrices_A, inversion_matrix_B, force_on_supermesh)


      ! 2nd step: Compute the RHS of the Galerkin projection:
      ! Elemental Values of the Force of this part of the supermesh are now computed.
      ! Compute the RHS of 
      ! M_f * F_f = M_{f,sup} * F_{sup}
      ! and
      ! M_s * F_s = M_{s,sup} * F_{sup}
      ! and afterwards, the supermesh can be deleted as it is no longer needed,
      ! remember, (M_{f,sup} * F_{sup}) lives on the fluid mesh, not the supermesh.

      call compute_rhs_galerkin_projection_fsi(ele_B, rhs_fluid, rhs_solid, positionsA, positionsB, force_on_supermesh, &
                                            supermesh, inversion_matrices_A, inversion_matrix_B)

      ! Portion of supermesh no longer needed
      call deallocate(supermesh)
      call deallocate(supermesh_field_mesh)
      call deallocate(force_on_supermesh)
    end do

    call deallocate(supermesh_quad)
    call deallocate(supermesh_positions_shape)
    call deallocate(supermesh_field_shape)
    do ele_B=1,ele_count(positionsB)
      call deallocate(map_BA(ele_B))
    end do

    ! 3rd step: Project the force from the supermesh to the fluid and solid mesh:
    ! loop over fluid and solid elements and solve the last equation, which will
    ! project the force from the supermesh to the fluid and solid mesh

    ! Set solver options for the interpolations:
    fluid_force%option_path = "/temporary"
    solid_force%option_path = "/temporary"

    call set_solver_options(fluid_force, ksptype="cg", pctype="sor", rtol=1.e-10, max_its=10000)
    call petsc_solve(fluid_force, mass_matrix_fluid, rhs_fluid)

    call set_solver_options(solid_force, ksptype="cg", pctype="sor", rtol=1.e-10, max_its=10000)
    call petsc_solve(solid_force, mass_matrix_solid, rhs_solid)

    call delete_option("/temporary")

    ! Force was computed for the fluid, therefore the force for the solid
    ! is -1 * F:
    call scale(solid_force, -1.0)

    ewrite(2,*) "************************************************************************"
    ewrite(2,*) ":"
    ewrite_minmax(rhs_fluid%val(1,:))
    ewrite_minmax(rhs_fluid%val(2,:))
    ewrite_minmax(rhs_fluid%val(3,:))
    ewrite_minmax(fluid_force%val(1,:))
    ewrite_minmax(fluid_force%val(2,:))
    ewrite_minmax(fluid_force%val(3,:))
    ewrite_minmax(rhs_solid%val(1,:))
    ewrite_minmax(rhs_solid%val(2,:))
    ewrite_minmax(rhs_solid%val(3,:))
    ewrite_minmax(solid_force%val(1,:))
    ewrite_minmax(solid_force%val(2,:))
    ewrite_minmax(solid_force%val(3,:))
    ewrite_minmax(mass_matrix_fluid)
    ewrite_minmax(mass_matrix_solid)
    ewrite(2,*) "************************************************************************"

    call deallocate(mass_matrix_solid)
    call deallocate(mass_matrix_fluid)
    call deallocate(rhs_fluid)
    call deallocate(rhs_solid)

  end subroutine force_projection

  subroutine compute_force_on_supermesh(fluid_field, fluid_positions, supermesh_field_shape, solid_ele_value, solid_positions, ele_B, supermesh, &
                                    & inversion_matrices_A, inversion_matrix_B, force_on_supermesh)
    !A stands for fluid, B for solid, C for the supermesh in this case:
    type(vector_field), intent(in) :: fluid_field
    type(vector_field), intent(in) :: fluid_positions, solid_positions, supermesh
    type(element_type), intent(in), target :: supermesh_field_shape
    real, dimension(:, :), intent(in) :: solid_ele_value
    integer, intent(in) :: ele_B
    real, dimension(:, :, :), intent(in) :: inversion_matrices_A
    real, dimension(:, :), intent(in) :: inversion_matrix_B
    real, dimension(ele_loc(fluid_positions, 1), ele_loc(fluid_positions, 1)) :: inversion_matrix_A

    type(vector_field), intent(inout) :: force_on_supermesh

    type(mesh_type) :: supermesh_field_mesh
    type(vector_field) :: solid_velocity_on_supermesh, fluid_velocity_on_supermesh

    integer :: ele_C
    real, dimension(ele_ngi(supermesh, 1)) :: detwei_C
    integer, dimension(:), pointer :: nodes
    integer :: node_C, i, j, k

    integer :: ele_A
    real, dimension(ele_loc(solid_positions, ele_B)) :: local_coords
    integer :: dim
    real :: val
    type(vector_field) :: supermesh_positions_remapped
    real, dimension(fluid_field%dim, ele_loc(fluid_field, 1)) :: fluid_ele_values


    dim = fluid_positions%dim


    supermesh_field_mesh = make_mesh(supermesh%mesh, supermesh_field_shape, -1, "SupermeshFieldMesh")
    call allocate(supermesh_positions_remapped, dim, supermesh_field_mesh, "SupermeshPositionsRemapped")
    call remap_field(supermesh, supermesh_positions_remapped)

    call allocate(fluid_velocity_on_supermesh, dim, supermesh_field_mesh, "SubmeshField")
    call zero(fluid_velocity_on_supermesh)
    call allocate(solid_velocity_on_supermesh, dim, supermesh_field_mesh, "SubmeshField")
    call zero(solid_velocity_on_supermesh)


    ! Looping over all the elements of the portion of the supermesh:
    do ele_C=1,ele_count(supermesh)
      ! Get the global node numbers of element 'ele_C' of the supermesh:
      nodes => ele_nodes(fluid_velocity_on_supermesh, ele_C)
      ! ele_A is then the region (number) of the supermesh, which describes the intersection of 
      ! one element of mesh A with one element of mesh B; the supermesh being the supermesh of all 
      ! the intersections of element 'ele_B' with mesh A.
      ele_A = ele_region_id(supermesh, ele_C)
      ! store the inverted matrix with the coordinates of mesh region 'ele_A' in inversion_matrix_A:
      inversion_matrix_A = inversion_matrices_A(:, :, ele_A)

      ! Loop over the nodes of ele_C:
      do i=1,size(nodes)
        ! node_C = global node number of the i-th node of element ele_C:
        node_C = nodes(i)

        ! set local_coords to the values of node 'node_C' on the element 'ele_C' of the supermesh
        local_coords(1:dim) = node_val(supermesh_positions_remapped, node_C); local_coords(dim+1) = 1.0
        ! Compute the matrix multiplication of the coordinate matrix
        ! for region ele_A and local_coords, then store the result in local_coords:
        local_coords = matmul(inversion_matrix_A, local_coords)
        ! set 'fluid_ele_values' to the value of the field 'fluid_field' in region 'ele_A'
        fluid_ele_values = ele_val(fluid_field, ele_A)
        ! Looping over the nodes of element 'ele_A' of the field 'fluid_field'
        ! and with the values of all nodes in element 'ele_A'
        ! compute the value 'val' for this node 'node_C' of element 'ele_C'
        ! This will project a quantity from an input field to the supermesh:
        do k=1,fluid_field%dim
          val = 0.0
          do j=1,ele_loc(fluid_field, ele_A)
            val = val + eval_shape(ele_shape(fluid_field, ele_A), j, local_coords) * fluid_ele_values(k, j)
          end do
          ! set the projected field on the supermesh to the above computed value (for node 'node_C'):
          call set(fluid_velocity_on_supermesh, k, node_C, val)
        end do

        ! Redo the steps above for the second parent mesh (solid):
        local_coords(1:dim) = node_val(supermesh_positions_remapped, node_C); local_coords(dim+1) = 1.0
        local_coords = matmul(inversion_matrix_B, local_coords)
        do k=1,fluid_field%dim
          val = 0.0
          do j=1,supermesh_field_shape%loc
            val = val + eval_shape(supermesh_field_shape, j, local_coords) * solid_ele_value(k, j)
          end do
          call set(solid_velocity_on_supermesh, k, node_C, val)
        end do

      end do ! end of looping over the nodes of element 'ele_C' of the supermesh

    end do ! end of looping over elements of the supermesh

    ! Compute the force on the supermesh:
    ! THIS CURRENTLY YIELDS TO A WRONG FORCE, as the solid velocity inside the solid is nonzero,
    ! while the fluid velocity is zero. THIS NEEDS TO BE CHANGED IN FUTURE, SO THAT ONLY THE 
    ! FORCE AT THE SOLID'S BOUNDARY IS COMPUTED and therefore nonzero only at the boundary.
    ! Alternatively the volume fraction of (fluid volume)/(solid volume) could be computed for each solid element
    ! which could be used in order to achieve a zero solid velocity inside the solid, by computing:
    ! u_solid - alpha*u_solid, where alpha the volume fraction is.

    ! SEE subroutine 'intersect_tets_dt' in femtools/Tetrahedron_intersection.F90,
    ! that routine might give us the surface of intersecting meshes
    call set(force_on_supermesh, solid_velocity_on_supermesh)
    call addto(force_on_supermesh, fluid_velocity_on_supermesh, -1.0)

    ! supermesh_positions_remapped no longer needed:
    call deallocate(supermesh_positions_remapped)

    !ewrite(2,*) "************************************************************************"
    !ewrite_minmax(fluid_velocity_on_supermesh%val(1,:))
    !ewrite_minmax(fluid_velocity_on_supermesh%val(2,:))
    !ewrite_minmax(fluid_velocity_on_supermesh%val(3,:))
    !ewrite_minmax(solid_velocity_on_supermesh%val(1,:))
    !ewrite_minmax(solid_velocity_on_supermesh%val(2,:))
    !ewrite_minmax(solid_velocity_on_supermesh%val(3,:))
    !ewrite_minmax(force_on_supermesh%val(1,:))
    !ewrite_minmax(force_on_supermesh%val(2,:))
    !ewrite_minmax(force_on_supermesh%val(3,:))
    !ewrite(2,*) "************************************************************************"

    call deallocate(supermesh_field_mesh)
    call deallocate(fluid_velocity_on_supermesh)
    call deallocate(solid_velocity_on_supermesh)
  end subroutine compute_force_on_supermesh

  subroutine compute_rhs_galerkin_projection_fsi(ele_B, rhs_fluid, rhs_solid, positionsA, positionsB, force_on_supermesh, &
                                                 supermesh, inversion_matrices_A, inversion_matrix_B)
    ! FSI: fluid-solid interactions
    integer, intent(in) :: ele_B
    type(vector_field), intent(inout) :: rhs_fluid, rhs_solid
    type(vector_field), intent(in) :: positionsA, positionsB
    type(vector_field), intent(in) :: force_on_supermesh
    type(vector_field), intent(in) :: supermesh
    real, dimension(:, :), intent(in) :: inversion_matrix_B
    real, dimension(:, :, :), intent(in) :: inversion_matrices_A

    integer :: ele_A, ele_C

    do ele_C=1,ele_count(supermesh)
      ele_A = ele_region_id(supermesh, ele_C) ! get the parent fluid element
      call compute_rhs_galerkin_projection_fsi_ele(rhs_fluid, rhs_solid, positionsA, positionsB, force_on_supermesh, supermesh, &
                                                   inversion_matrices_A(:, :, ele_A), inversion_matrix_B, ele_A, ele_B, ele_C)
    end do
  end subroutine compute_rhs_galerkin_projection_fsi

  subroutine compute_rhs_galerkin_projection_fsi_ele(rhs_fluid, rhs_solid, positionsA, positionsB, force_on_supermesh, supermesh, &
                                                     inversion_matrix_A, inversion_matrix_B, ele_A, ele_B, ele_C)
    integer, intent(in) :: ele_A, ele_B, ele_C
    type(vector_field), intent(inout) :: rhs_fluid, rhs_solid
    type(vector_field), intent(in) :: positionsA, positionsB
    type(vector_field), intent(in) :: force_on_supermesh
    type(vector_field), intent(in) :: supermesh
    real, dimension(:, :), intent(in) :: inversion_matrix_A, inversion_matrix_B

    real, dimension(ele_ngi(supermesh, ele_C)) :: detwei_C
    real, dimension(positionsA%dim+1, ele_ngi(supermesh, ele_C)) :: local_coord_at_quad_fluid
    real, dimension(positionsB%dim+1, ele_ngi(supermesh, ele_C)) :: local_coord_at_quad_solid
    real, dimension(supermesh%dim+1, ele_ngi(supermesh, ele_C)) :: global_coord_at_quad

    real, dimension(ele_loc(rhs_fluid, ele_A), ele_ngi(supermesh, ele_C)) :: basis_at_quad_fluid
    real, dimension(ele_loc(rhs_solid, ele_B), ele_ngi(supermesh, ele_C)) :: basis_at_quad_solid
    real, dimension(ele_loc(force_on_supermesh, ele_C), ele_ngi(supermesh, ele_C)) :: basis_at_quad_force_supermesh

    real, dimension(ele_loc(rhs_fluid, ele_A), ele_loc(force_on_supermesh, ele_C)) :: mat_fluid
    real, dimension(ele_loc(rhs_solid, ele_B), ele_loc(force_on_supermesh, ele_C)) :: mat_solid

    real, dimension(force_on_supermesh%dim, ele_loc(supermesh, ele_C)) :: supermesh_val

    integer :: j, k, l, dim

    ! Compute the local coordinates of the fluid and solid meshes.
    global_coord_at_quad(1:supermesh%dim, :) = ele_val_at_quad(supermesh, ele_C)
    global_coord_at_quad(supermesh%dim+1, :) = 1.0
    local_coord_at_quad_fluid = matmul(inversion_matrix_A, global_coord_at_quad)
    local_coord_at_quad_solid = matmul(inversion_matrix_B, global_coord_at_quad)

    ! Compute the basis functions of the fluid, solid and supermesh force fields at these local coordinates.
    basis_at_quad_fluid = basis_at_quad(ele_shape(rhs_fluid, ele_A), local_coord_at_quad_fluid)
    basis_at_quad_solid = basis_at_quad(ele_shape(rhs_solid, ele_B), local_coord_at_quad_solid)
    basis_at_quad_force_supermesh = basis_at_quad(ele_shape(force_on_supermesh, ele_C), force_on_supermesh%mesh%shape%n)

    ! We need to integrate over the supermesh element, so get detwei_C
    call transform_to_physical(supermesh, ele_C, detwei=detwei_C)

    ! Compute the little mixed mass matrices
    mat_fluid = 0.0
    mat_solid = 0.0
    do j=1,ele_ngi(supermesh, ele_C)
      forall (k=1:ele_loc(rhs_fluid, ele_A),l=1:ele_loc(force_on_supermesh, ele_C))
        mat_fluid(k, l) = mat_fluid(k, l) + detwei_C(j) * basis_at_quad_fluid(k, j) * basis_at_quad_force_supermesh(l, j)
        mat_solid(k, l) = mat_solid(k, l) + detwei_C(j) * basis_at_quad_solid(k, j) * basis_at_quad_force_supermesh(l, j)
      end forall
    end do

    ! Now we apply that to the force on the supermesh, to compute the rhs contribution.
    supermesh_val = ele_val(force_on_supermesh, ele_C)
    do dim=1,force_on_supermesh%dim
      call addto(rhs_fluid, dim, ele_nodes(rhs_fluid, ele_A), matmul(mat_fluid, supermesh_val(dim, :)))
      call addto(rhs_solid, dim, ele_nodes(rhs_solid, ele_B), matmul(mat_solid, supermesh_val(dim, :)))
    end do
  end subroutine compute_rhs_galerkin_projection_fsi_ele

  subroutine assemble_mass_matrix(mass, field, positions, ele)
    type(csr_matrix), intent(inout) :: mass
    type(vector_field), intent(in) :: field
    type(vector_field), intent(in) :: positions
    integer, intent(in) :: ele

    real, dimension(ele_ngi(field, ele)) :: detwei
    real, dimension(ele_loc(field, ele), ele_loc(field, ele)) :: little_mass

    call transform_to_physical(positions, ele, detwei=detwei)
    little_mass = shape_shape(ele_shape(field, ele), ele_shape(field, ele), detwei)
    call addto(mass, ele_nodes(field, ele), ele_nodes(field, ele), little_mass)
  end subroutine assemble_mass_matrix

  function basis_at_quad(shape, local_coords) result(basis)
    type(element_type), intent(in) :: shape
    real, dimension(:, :), intent(in) :: local_coords
    real, dimension(shape%loc, size(local_coords, 2)) :: basis
    integer :: loc, gi

    if (shape%degree == 0) then
      basis = 1.0
    elseif (shape%degree == 1) then
      basis = local_coords
    else
      do loc=1,shape%loc
        do gi=1,size(local_coords, 2)
          basis(loc, gi) = eval_shape(shape, loc, local_coords(:, gi))
        end do
      end do
    end if
  end function basis_at_quad
end module supermesh_force

